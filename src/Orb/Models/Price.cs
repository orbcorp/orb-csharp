using System.Collections.Frozen;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Text.Json.Serialization;
using Orb.Core;
using Orb.Exceptions;
using System = System;

namespace Orb.Models;

/// <summary>
/// The Price resource represents a price that can be billed on a subscription, resulting
/// in a charge on an invoice in the form of an invoice line item. Prices take a quantity
/// and determine an amount to bill.
///
/// <para>Orb supports a few different pricing models out of the box. Each of these
/// models is serialized differently in a given Price object. The model_type field
/// determines the key for the configuration object that is present.</para>
///
/// <para>For more on the types of prices, see [the core concepts documentation](/core-concepts#plan-and-price)</para>
/// </summary>
[JsonConverter(typeof(PriceConverter))]
public record class Price
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public string ID
    {
        get
        {
            return Match(
                unit: (x) => x.ID,
                tiered: (x) => x.ID,
                bulk: (x) => x.ID,
                bulkWithFilters: (x) => x.ID,
                package: (x) => x.ID,
                matrix: (x) => x.ID,
                thresholdTotalAmount: (x) => x.ID,
                tieredPackage: (x) => x.ID,
                tieredWithMinimum: (x) => x.ID,
                groupedTiered: (x) => x.ID,
                tieredPackageWithMinimum: (x) => x.ID,
                packageWithAllocation: (x) => x.ID,
                unitWithPercent: (x) => x.ID,
                matrixWithAllocation: (x) => x.ID,
                tieredWithProration: (x) => x.ID,
                unitWithProration: (x) => x.ID,
                groupedAllocation: (x) => x.ID,
                bulkWithProration: (x) => x.ID,
                groupedWithProratedMinimum: (x) => x.ID,
                groupedWithMeteredMinimum: (x) => x.ID,
                groupedWithMinMaxThresholds: (x) => x.ID,
                matrixWithDisplayName: (x) => x.ID,
                groupedTieredPackage: (x) => x.ID,
                maxGroupTieredPackage: (x) => x.ID,
                scalableMatrixWithUnitPricing: (x) => x.ID,
                scalableMatrixWithTieredPricing: (x) => x.ID,
                cumulativeGroupedBulk: (x) => x.ID,
                cumulativeGroupedAllocation: (x) => x.ID,
                minimum: (x) => x.ID,
                percent: (x) => x.ID,
                eventOutput: (x) => x.ID
            );
        }
    }

    public BillableMetricTiny? BillableMetric
    {
        get
        {
            return Match<BillableMetricTiny?>(
                unit: (x) => x.BillableMetric,
                tiered: (x) => x.BillableMetric,
                bulk: (x) => x.BillableMetric,
                bulkWithFilters: (x) => x.BillableMetric,
                package: (x) => x.BillableMetric,
                matrix: (x) => x.BillableMetric,
                thresholdTotalAmount: (x) => x.BillableMetric,
                tieredPackage: (x) => x.BillableMetric,
                tieredWithMinimum: (x) => x.BillableMetric,
                groupedTiered: (x) => x.BillableMetric,
                tieredPackageWithMinimum: (x) => x.BillableMetric,
                packageWithAllocation: (x) => x.BillableMetric,
                unitWithPercent: (x) => x.BillableMetric,
                matrixWithAllocation: (x) => x.BillableMetric,
                tieredWithProration: (x) => x.BillableMetric,
                unitWithProration: (x) => x.BillableMetric,
                groupedAllocation: (x) => x.BillableMetric,
                bulkWithProration: (x) => x.BillableMetric,
                groupedWithProratedMinimum: (x) => x.BillableMetric,
                groupedWithMeteredMinimum: (x) => x.BillableMetric,
                groupedWithMinMaxThresholds: (x) => x.BillableMetric,
                matrixWithDisplayName: (x) => x.BillableMetric,
                groupedTieredPackage: (x) => x.BillableMetric,
                maxGroupTieredPackage: (x) => x.BillableMetric,
                scalableMatrixWithUnitPricing: (x) => x.BillableMetric,
                scalableMatrixWithTieredPricing: (x) => x.BillableMetric,
                cumulativeGroupedBulk: (x) => x.BillableMetric,
                cumulativeGroupedAllocation: (x) => x.BillableMetric,
                minimum: (x) => x.BillableMetric,
                percent: (x) => x.BillableMetric,
                eventOutput: (x) => x.BillableMetric
            );
        }
    }

    public BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return Match(
                unit: (x) => x.BillingCycleConfiguration,
                tiered: (x) => x.BillingCycleConfiguration,
                bulk: (x) => x.BillingCycleConfiguration,
                bulkWithFilters: (x) => x.BillingCycleConfiguration,
                package: (x) => x.BillingCycleConfiguration,
                matrix: (x) => x.BillingCycleConfiguration,
                thresholdTotalAmount: (x) => x.BillingCycleConfiguration,
                tieredPackage: (x) => x.BillingCycleConfiguration,
                tieredWithMinimum: (x) => x.BillingCycleConfiguration,
                groupedTiered: (x) => x.BillingCycleConfiguration,
                tieredPackageWithMinimum: (x) => x.BillingCycleConfiguration,
                packageWithAllocation: (x) => x.BillingCycleConfiguration,
                unitWithPercent: (x) => x.BillingCycleConfiguration,
                matrixWithAllocation: (x) => x.BillingCycleConfiguration,
                tieredWithProration: (x) => x.BillingCycleConfiguration,
                unitWithProration: (x) => x.BillingCycleConfiguration,
                groupedAllocation: (x) => x.BillingCycleConfiguration,
                bulkWithProration: (x) => x.BillingCycleConfiguration,
                groupedWithProratedMinimum: (x) => x.BillingCycleConfiguration,
                groupedWithMeteredMinimum: (x) => x.BillingCycleConfiguration,
                groupedWithMinMaxThresholds: (x) => x.BillingCycleConfiguration,
                matrixWithDisplayName: (x) => x.BillingCycleConfiguration,
                groupedTieredPackage: (x) => x.BillingCycleConfiguration,
                maxGroupTieredPackage: (x) => x.BillingCycleConfiguration,
                scalableMatrixWithUnitPricing: (x) => x.BillingCycleConfiguration,
                scalableMatrixWithTieredPricing: (x) => x.BillingCycleConfiguration,
                cumulativeGroupedBulk: (x) => x.BillingCycleConfiguration,
                cumulativeGroupedAllocation: (x) => x.BillingCycleConfiguration,
                minimum: (x) => x.BillingCycleConfiguration,
                percent: (x) => x.BillingCycleConfiguration,
                eventOutput: (x) => x.BillingCycleConfiguration
            );
        }
    }

    public double? ConversionRate
    {
        get
        {
            return Match<double?>(
                unit: (x) => x.ConversionRate,
                tiered: (x) => x.ConversionRate,
                bulk: (x) => x.ConversionRate,
                bulkWithFilters: (x) => x.ConversionRate,
                package: (x) => x.ConversionRate,
                matrix: (x) => x.ConversionRate,
                thresholdTotalAmount: (x) => x.ConversionRate,
                tieredPackage: (x) => x.ConversionRate,
                tieredWithMinimum: (x) => x.ConversionRate,
                groupedTiered: (x) => x.ConversionRate,
                tieredPackageWithMinimum: (x) => x.ConversionRate,
                packageWithAllocation: (x) => x.ConversionRate,
                unitWithPercent: (x) => x.ConversionRate,
                matrixWithAllocation: (x) => x.ConversionRate,
                tieredWithProration: (x) => x.ConversionRate,
                unitWithProration: (x) => x.ConversionRate,
                groupedAllocation: (x) => x.ConversionRate,
                bulkWithProration: (x) => x.ConversionRate,
                groupedWithProratedMinimum: (x) => x.ConversionRate,
                groupedWithMeteredMinimum: (x) => x.ConversionRate,
                groupedWithMinMaxThresholds: (x) => x.ConversionRate,
                matrixWithDisplayName: (x) => x.ConversionRate,
                groupedTieredPackage: (x) => x.ConversionRate,
                maxGroupTieredPackage: (x) => x.ConversionRate,
                scalableMatrixWithUnitPricing: (x) => x.ConversionRate,
                scalableMatrixWithTieredPricing: (x) => x.ConversionRate,
                cumulativeGroupedBulk: (x) => x.ConversionRate,
                cumulativeGroupedAllocation: (x) => x.ConversionRate,
                minimum: (x) => x.ConversionRate,
                percent: (x) => x.ConversionRate,
                eventOutput: (x) => x.ConversionRate
            );
        }
    }

    public System::DateTimeOffset CreatedAt
    {
        get
        {
            return Match(
                unit: (x) => x.CreatedAt,
                tiered: (x) => x.CreatedAt,
                bulk: (x) => x.CreatedAt,
                bulkWithFilters: (x) => x.CreatedAt,
                package: (x) => x.CreatedAt,
                matrix: (x) => x.CreatedAt,
                thresholdTotalAmount: (x) => x.CreatedAt,
                tieredPackage: (x) => x.CreatedAt,
                tieredWithMinimum: (x) => x.CreatedAt,
                groupedTiered: (x) => x.CreatedAt,
                tieredPackageWithMinimum: (x) => x.CreatedAt,
                packageWithAllocation: (x) => x.CreatedAt,
                unitWithPercent: (x) => x.CreatedAt,
                matrixWithAllocation: (x) => x.CreatedAt,
                tieredWithProration: (x) => x.CreatedAt,
                unitWithProration: (x) => x.CreatedAt,
                groupedAllocation: (x) => x.CreatedAt,
                bulkWithProration: (x) => x.CreatedAt,
                groupedWithProratedMinimum: (x) => x.CreatedAt,
                groupedWithMeteredMinimum: (x) => x.CreatedAt,
                groupedWithMinMaxThresholds: (x) => x.CreatedAt,
                matrixWithDisplayName: (x) => x.CreatedAt,
                groupedTieredPackage: (x) => x.CreatedAt,
                maxGroupTieredPackage: (x) => x.CreatedAt,
                scalableMatrixWithUnitPricing: (x) => x.CreatedAt,
                scalableMatrixWithTieredPricing: (x) => x.CreatedAt,
                cumulativeGroupedBulk: (x) => x.CreatedAt,
                cumulativeGroupedAllocation: (x) => x.CreatedAt,
                minimum: (x) => x.CreatedAt,
                percent: (x) => x.CreatedAt,
                eventOutput: (x) => x.CreatedAt
            );
        }
    }

    public Allocation? CreditAllocation
    {
        get
        {
            return Match<Allocation?>(
                unit: (x) => x.CreditAllocation,
                tiered: (x) => x.CreditAllocation,
                bulk: (x) => x.CreditAllocation,
                bulkWithFilters: (x) => x.CreditAllocation,
                package: (x) => x.CreditAllocation,
                matrix: (x) => x.CreditAllocation,
                thresholdTotalAmount: (x) => x.CreditAllocation,
                tieredPackage: (x) => x.CreditAllocation,
                tieredWithMinimum: (x) => x.CreditAllocation,
                groupedTiered: (x) => x.CreditAllocation,
                tieredPackageWithMinimum: (x) => x.CreditAllocation,
                packageWithAllocation: (x) => x.CreditAllocation,
                unitWithPercent: (x) => x.CreditAllocation,
                matrixWithAllocation: (x) => x.CreditAllocation,
                tieredWithProration: (x) => x.CreditAllocation,
                unitWithProration: (x) => x.CreditAllocation,
                groupedAllocation: (x) => x.CreditAllocation,
                bulkWithProration: (x) => x.CreditAllocation,
                groupedWithProratedMinimum: (x) => x.CreditAllocation,
                groupedWithMeteredMinimum: (x) => x.CreditAllocation,
                groupedWithMinMaxThresholds: (x) => x.CreditAllocation,
                matrixWithDisplayName: (x) => x.CreditAllocation,
                groupedTieredPackage: (x) => x.CreditAllocation,
                maxGroupTieredPackage: (x) => x.CreditAllocation,
                scalableMatrixWithUnitPricing: (x) => x.CreditAllocation,
                scalableMatrixWithTieredPricing: (x) => x.CreditAllocation,
                cumulativeGroupedBulk: (x) => x.CreditAllocation,
                cumulativeGroupedAllocation: (x) => x.CreditAllocation,
                minimum: (x) => x.CreditAllocation,
                percent: (x) => x.CreditAllocation,
                eventOutput: (x) => x.CreditAllocation
            );
        }
    }

    public string Currency
    {
        get
        {
            return Match(
                unit: (x) => x.Currency,
                tiered: (x) => x.Currency,
                bulk: (x) => x.Currency,
                bulkWithFilters: (x) => x.Currency,
                package: (x) => x.Currency,
                matrix: (x) => x.Currency,
                thresholdTotalAmount: (x) => x.Currency,
                tieredPackage: (x) => x.Currency,
                tieredWithMinimum: (x) => x.Currency,
                groupedTiered: (x) => x.Currency,
                tieredPackageWithMinimum: (x) => x.Currency,
                packageWithAllocation: (x) => x.Currency,
                unitWithPercent: (x) => x.Currency,
                matrixWithAllocation: (x) => x.Currency,
                tieredWithProration: (x) => x.Currency,
                unitWithProration: (x) => x.Currency,
                groupedAllocation: (x) => x.Currency,
                bulkWithProration: (x) => x.Currency,
                groupedWithProratedMinimum: (x) => x.Currency,
                groupedWithMeteredMinimum: (x) => x.Currency,
                groupedWithMinMaxThresholds: (x) => x.Currency,
                matrixWithDisplayName: (x) => x.Currency,
                groupedTieredPackage: (x) => x.Currency,
                maxGroupTieredPackage: (x) => x.Currency,
                scalableMatrixWithUnitPricing: (x) => x.Currency,
                scalableMatrixWithTieredPricing: (x) => x.Currency,
                cumulativeGroupedBulk: (x) => x.Currency,
                cumulativeGroupedAllocation: (x) => x.Currency,
                minimum: (x) => x.Currency,
                percent: (x) => x.Currency,
                eventOutput: (x) => x.Currency
            );
        }
    }

    public SharedDiscount? Discount
    {
        get
        {
            return Match<SharedDiscount?>(
                unit: (x) => x.Discount,
                tiered: (x) => x.Discount,
                bulk: (x) => x.Discount,
                bulkWithFilters: (x) => x.Discount,
                package: (x) => x.Discount,
                matrix: (x) => x.Discount,
                thresholdTotalAmount: (x) => x.Discount,
                tieredPackage: (x) => x.Discount,
                tieredWithMinimum: (x) => x.Discount,
                groupedTiered: (x) => x.Discount,
                tieredPackageWithMinimum: (x) => x.Discount,
                packageWithAllocation: (x) => x.Discount,
                unitWithPercent: (x) => x.Discount,
                matrixWithAllocation: (x) => x.Discount,
                tieredWithProration: (x) => x.Discount,
                unitWithProration: (x) => x.Discount,
                groupedAllocation: (x) => x.Discount,
                bulkWithProration: (x) => x.Discount,
                groupedWithProratedMinimum: (x) => x.Discount,
                groupedWithMeteredMinimum: (x) => x.Discount,
                groupedWithMinMaxThresholds: (x) => x.Discount,
                matrixWithDisplayName: (x) => x.Discount,
                groupedTieredPackage: (x) => x.Discount,
                maxGroupTieredPackage: (x) => x.Discount,
                scalableMatrixWithUnitPricing: (x) => x.Discount,
                scalableMatrixWithTieredPricing: (x) => x.Discount,
                cumulativeGroupedBulk: (x) => x.Discount,
                cumulativeGroupedAllocation: (x) => x.Discount,
                minimum: (x) => x.Discount,
                percent: (x) => x.Discount,
                eventOutput: (x) => x.Discount
            );
        }
    }

    public string? ExternalPriceID
    {
        get
        {
            return Match<string?>(
                unit: (x) => x.ExternalPriceID,
                tiered: (x) => x.ExternalPriceID,
                bulk: (x) => x.ExternalPriceID,
                bulkWithFilters: (x) => x.ExternalPriceID,
                package: (x) => x.ExternalPriceID,
                matrix: (x) => x.ExternalPriceID,
                thresholdTotalAmount: (x) => x.ExternalPriceID,
                tieredPackage: (x) => x.ExternalPriceID,
                tieredWithMinimum: (x) => x.ExternalPriceID,
                groupedTiered: (x) => x.ExternalPriceID,
                tieredPackageWithMinimum: (x) => x.ExternalPriceID,
                packageWithAllocation: (x) => x.ExternalPriceID,
                unitWithPercent: (x) => x.ExternalPriceID,
                matrixWithAllocation: (x) => x.ExternalPriceID,
                tieredWithProration: (x) => x.ExternalPriceID,
                unitWithProration: (x) => x.ExternalPriceID,
                groupedAllocation: (x) => x.ExternalPriceID,
                bulkWithProration: (x) => x.ExternalPriceID,
                groupedWithProratedMinimum: (x) => x.ExternalPriceID,
                groupedWithMeteredMinimum: (x) => x.ExternalPriceID,
                groupedWithMinMaxThresholds: (x) => x.ExternalPriceID,
                matrixWithDisplayName: (x) => x.ExternalPriceID,
                groupedTieredPackage: (x) => x.ExternalPriceID,
                maxGroupTieredPackage: (x) => x.ExternalPriceID,
                scalableMatrixWithUnitPricing: (x) => x.ExternalPriceID,
                scalableMatrixWithTieredPricing: (x) => x.ExternalPriceID,
                cumulativeGroupedBulk: (x) => x.ExternalPriceID,
                cumulativeGroupedAllocation: (x) => x.ExternalPriceID,
                minimum: (x) => x.ExternalPriceID,
                percent: (x) => x.ExternalPriceID,
                eventOutput: (x) => x.ExternalPriceID
            );
        }
    }

    public double? FixedPriceQuantity
    {
        get
        {
            return Match<double?>(
                unit: (x) => x.FixedPriceQuantity,
                tiered: (x) => x.FixedPriceQuantity,
                bulk: (x) => x.FixedPriceQuantity,
                bulkWithFilters: (x) => x.FixedPriceQuantity,
                package: (x) => x.FixedPriceQuantity,
                matrix: (x) => x.FixedPriceQuantity,
                thresholdTotalAmount: (x) => x.FixedPriceQuantity,
                tieredPackage: (x) => x.FixedPriceQuantity,
                tieredWithMinimum: (x) => x.FixedPriceQuantity,
                groupedTiered: (x) => x.FixedPriceQuantity,
                tieredPackageWithMinimum: (x) => x.FixedPriceQuantity,
                packageWithAllocation: (x) => x.FixedPriceQuantity,
                unitWithPercent: (x) => x.FixedPriceQuantity,
                matrixWithAllocation: (x) => x.FixedPriceQuantity,
                tieredWithProration: (x) => x.FixedPriceQuantity,
                unitWithProration: (x) => x.FixedPriceQuantity,
                groupedAllocation: (x) => x.FixedPriceQuantity,
                bulkWithProration: (x) => x.FixedPriceQuantity,
                groupedWithProratedMinimum: (x) => x.FixedPriceQuantity,
                groupedWithMeteredMinimum: (x) => x.FixedPriceQuantity,
                groupedWithMinMaxThresholds: (x) => x.FixedPriceQuantity,
                matrixWithDisplayName: (x) => x.FixedPriceQuantity,
                groupedTieredPackage: (x) => x.FixedPriceQuantity,
                maxGroupTieredPackage: (x) => x.FixedPriceQuantity,
                scalableMatrixWithUnitPricing: (x) => x.FixedPriceQuantity,
                scalableMatrixWithTieredPricing: (x) => x.FixedPriceQuantity,
                cumulativeGroupedBulk: (x) => x.FixedPriceQuantity,
                cumulativeGroupedAllocation: (x) => x.FixedPriceQuantity,
                minimum: (x) => x.FixedPriceQuantity,
                percent: (x) => x.FixedPriceQuantity,
                eventOutput: (x) => x.FixedPriceQuantity
            );
        }
    }

    public BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return Match<BillingCycleConfiguration?>(
                unit: (x) => x.InvoicingCycleConfiguration,
                tiered: (x) => x.InvoicingCycleConfiguration,
                bulk: (x) => x.InvoicingCycleConfiguration,
                bulkWithFilters: (x) => x.InvoicingCycleConfiguration,
                package: (x) => x.InvoicingCycleConfiguration,
                matrix: (x) => x.InvoicingCycleConfiguration,
                thresholdTotalAmount: (x) => x.InvoicingCycleConfiguration,
                tieredPackage: (x) => x.InvoicingCycleConfiguration,
                tieredWithMinimum: (x) => x.InvoicingCycleConfiguration,
                groupedTiered: (x) => x.InvoicingCycleConfiguration,
                tieredPackageWithMinimum: (x) => x.InvoicingCycleConfiguration,
                packageWithAllocation: (x) => x.InvoicingCycleConfiguration,
                unitWithPercent: (x) => x.InvoicingCycleConfiguration,
                matrixWithAllocation: (x) => x.InvoicingCycleConfiguration,
                tieredWithProration: (x) => x.InvoicingCycleConfiguration,
                unitWithProration: (x) => x.InvoicingCycleConfiguration,
                groupedAllocation: (x) => x.InvoicingCycleConfiguration,
                bulkWithProration: (x) => x.InvoicingCycleConfiguration,
                groupedWithProratedMinimum: (x) => x.InvoicingCycleConfiguration,
                groupedWithMeteredMinimum: (x) => x.InvoicingCycleConfiguration,
                groupedWithMinMaxThresholds: (x) => x.InvoicingCycleConfiguration,
                matrixWithDisplayName: (x) => x.InvoicingCycleConfiguration,
                groupedTieredPackage: (x) => x.InvoicingCycleConfiguration,
                maxGroupTieredPackage: (x) => x.InvoicingCycleConfiguration,
                scalableMatrixWithUnitPricing: (x) => x.InvoicingCycleConfiguration,
                scalableMatrixWithTieredPricing: (x) => x.InvoicingCycleConfiguration,
                cumulativeGroupedBulk: (x) => x.InvoicingCycleConfiguration,
                cumulativeGroupedAllocation: (x) => x.InvoicingCycleConfiguration,
                minimum: (x) => x.InvoicingCycleConfiguration,
                percent: (x) => x.InvoicingCycleConfiguration,
                eventOutput: (x) => x.InvoicingCycleConfiguration
            );
        }
    }

    public ItemSlim Item
    {
        get
        {
            return Match(
                unit: (x) => x.Item,
                tiered: (x) => x.Item,
                bulk: (x) => x.Item,
                bulkWithFilters: (x) => x.Item,
                package: (x) => x.Item,
                matrix: (x) => x.Item,
                thresholdTotalAmount: (x) => x.Item,
                tieredPackage: (x) => x.Item,
                tieredWithMinimum: (x) => x.Item,
                groupedTiered: (x) => x.Item,
                tieredPackageWithMinimum: (x) => x.Item,
                packageWithAllocation: (x) => x.Item,
                unitWithPercent: (x) => x.Item,
                matrixWithAllocation: (x) => x.Item,
                tieredWithProration: (x) => x.Item,
                unitWithProration: (x) => x.Item,
                groupedAllocation: (x) => x.Item,
                bulkWithProration: (x) => x.Item,
                groupedWithProratedMinimum: (x) => x.Item,
                groupedWithMeteredMinimum: (x) => x.Item,
                groupedWithMinMaxThresholds: (x) => x.Item,
                matrixWithDisplayName: (x) => x.Item,
                groupedTieredPackage: (x) => x.Item,
                maxGroupTieredPackage: (x) => x.Item,
                scalableMatrixWithUnitPricing: (x) => x.Item,
                scalableMatrixWithTieredPricing: (x) => x.Item,
                cumulativeGroupedBulk: (x) => x.Item,
                cumulativeGroupedAllocation: (x) => x.Item,
                minimum: (x) => x.Item,
                percent: (x) => x.Item,
                eventOutput: (x) => x.Item
            );
        }
    }

    public Maximum? Maximum
    {
        get
        {
            return Match<Maximum?>(
                unit: (x) => x.Maximum,
                tiered: (x) => x.Maximum,
                bulk: (x) => x.Maximum,
                bulkWithFilters: (x) => x.Maximum,
                package: (x) => x.Maximum,
                matrix: (x) => x.Maximum,
                thresholdTotalAmount: (x) => x.Maximum,
                tieredPackage: (x) => x.Maximum,
                tieredWithMinimum: (x) => x.Maximum,
                groupedTiered: (x) => x.Maximum,
                tieredPackageWithMinimum: (x) => x.Maximum,
                packageWithAllocation: (x) => x.Maximum,
                unitWithPercent: (x) => x.Maximum,
                matrixWithAllocation: (x) => x.Maximum,
                tieredWithProration: (x) => x.Maximum,
                unitWithProration: (x) => x.Maximum,
                groupedAllocation: (x) => x.Maximum,
                bulkWithProration: (x) => x.Maximum,
                groupedWithProratedMinimum: (x) => x.Maximum,
                groupedWithMeteredMinimum: (x) => x.Maximum,
                groupedWithMinMaxThresholds: (x) => x.Maximum,
                matrixWithDisplayName: (x) => x.Maximum,
                groupedTieredPackage: (x) => x.Maximum,
                maxGroupTieredPackage: (x) => x.Maximum,
                scalableMatrixWithUnitPricing: (x) => x.Maximum,
                scalableMatrixWithTieredPricing: (x) => x.Maximum,
                cumulativeGroupedBulk: (x) => x.Maximum,
                cumulativeGroupedAllocation: (x) => x.Maximum,
                minimum: (x) => x.Maximum,
                percent: (x) => x.Maximum,
                eventOutput: (x) => x.Maximum
            );
        }
    }

    public string? MaximumAmount
    {
        get
        {
            return Match<string?>(
                unit: (x) => x.MaximumAmount,
                tiered: (x) => x.MaximumAmount,
                bulk: (x) => x.MaximumAmount,
                bulkWithFilters: (x) => x.MaximumAmount,
                package: (x) => x.MaximumAmount,
                matrix: (x) => x.MaximumAmount,
                thresholdTotalAmount: (x) => x.MaximumAmount,
                tieredPackage: (x) => x.MaximumAmount,
                tieredWithMinimum: (x) => x.MaximumAmount,
                groupedTiered: (x) => x.MaximumAmount,
                tieredPackageWithMinimum: (x) => x.MaximumAmount,
                packageWithAllocation: (x) => x.MaximumAmount,
                unitWithPercent: (x) => x.MaximumAmount,
                matrixWithAllocation: (x) => x.MaximumAmount,
                tieredWithProration: (x) => x.MaximumAmount,
                unitWithProration: (x) => x.MaximumAmount,
                groupedAllocation: (x) => x.MaximumAmount,
                bulkWithProration: (x) => x.MaximumAmount,
                groupedWithProratedMinimum: (x) => x.MaximumAmount,
                groupedWithMeteredMinimum: (x) => x.MaximumAmount,
                groupedWithMinMaxThresholds: (x) => x.MaximumAmount,
                matrixWithDisplayName: (x) => x.MaximumAmount,
                groupedTieredPackage: (x) => x.MaximumAmount,
                maxGroupTieredPackage: (x) => x.MaximumAmount,
                scalableMatrixWithUnitPricing: (x) => x.MaximumAmount,
                scalableMatrixWithTieredPricing: (x) => x.MaximumAmount,
                cumulativeGroupedBulk: (x) => x.MaximumAmount,
                cumulativeGroupedAllocation: (x) => x.MaximumAmount,
                minimum: (x) => x.MaximumAmount,
                percent: (x) => x.MaximumAmount,
                eventOutput: (x) => x.MaximumAmount
            );
        }
    }

    public Minimum? Minimum
    {
        get
        {
            return Match<Minimum?>(
                unit: (x) => x.Minimum,
                tiered: (x) => x.Minimum,
                bulk: (x) => x.Minimum,
                bulkWithFilters: (x) => x.Minimum,
                package: (x) => x.Minimum,
                matrix: (x) => x.Minimum,
                thresholdTotalAmount: (x) => x.Minimum,
                tieredPackage: (x) => x.Minimum,
                tieredWithMinimum: (x) => x.Minimum,
                groupedTiered: (x) => x.Minimum,
                tieredPackageWithMinimum: (x) => x.Minimum,
                packageWithAllocation: (x) => x.Minimum,
                unitWithPercent: (x) => x.Minimum,
                matrixWithAllocation: (x) => x.Minimum,
                tieredWithProration: (x) => x.Minimum,
                unitWithProration: (x) => x.Minimum,
                groupedAllocation: (x) => x.Minimum,
                bulkWithProration: (x) => x.Minimum,
                groupedWithProratedMinimum: (x) => x.Minimum,
                groupedWithMeteredMinimum: (x) => x.Minimum,
                groupedWithMinMaxThresholds: (x) => x.Minimum,
                matrixWithDisplayName: (x) => x.Minimum,
                groupedTieredPackage: (x) => x.Minimum,
                maxGroupTieredPackage: (x) => x.Minimum,
                scalableMatrixWithUnitPricing: (x) => x.Minimum,
                scalableMatrixWithTieredPricing: (x) => x.Minimum,
                cumulativeGroupedBulk: (x) => x.Minimum,
                cumulativeGroupedAllocation: (x) => x.Minimum,
                minimum: (x) => x.Minimum,
                percent: (x) => x.Minimum,
                eventOutput: (x) => x.Minimum
            );
        }
    }

    public string? MinimumAmount
    {
        get
        {
            return Match<string?>(
                unit: (x) => x.MinimumAmount,
                tiered: (x) => x.MinimumAmount,
                bulk: (x) => x.MinimumAmount,
                bulkWithFilters: (x) => x.MinimumAmount,
                package: (x) => x.MinimumAmount,
                matrix: (x) => x.MinimumAmount,
                thresholdTotalAmount: (x) => x.MinimumAmount,
                tieredPackage: (x) => x.MinimumAmount,
                tieredWithMinimum: (x) => x.MinimumAmount,
                groupedTiered: (x) => x.MinimumAmount,
                tieredPackageWithMinimum: (x) => x.MinimumAmount,
                packageWithAllocation: (x) => x.MinimumAmount,
                unitWithPercent: (x) => x.MinimumAmount,
                matrixWithAllocation: (x) => x.MinimumAmount,
                tieredWithProration: (x) => x.MinimumAmount,
                unitWithProration: (x) => x.MinimumAmount,
                groupedAllocation: (x) => x.MinimumAmount,
                bulkWithProration: (x) => x.MinimumAmount,
                groupedWithProratedMinimum: (x) => x.MinimumAmount,
                groupedWithMeteredMinimum: (x) => x.MinimumAmount,
                groupedWithMinMaxThresholds: (x) => x.MinimumAmount,
                matrixWithDisplayName: (x) => x.MinimumAmount,
                groupedTieredPackage: (x) => x.MinimumAmount,
                maxGroupTieredPackage: (x) => x.MinimumAmount,
                scalableMatrixWithUnitPricing: (x) => x.MinimumAmount,
                scalableMatrixWithTieredPricing: (x) => x.MinimumAmount,
                cumulativeGroupedBulk: (x) => x.MinimumAmount,
                cumulativeGroupedAllocation: (x) => x.MinimumAmount,
                minimum: (x) => x.MinimumAmount,
                percent: (x) => x.MinimumAmount,
                eventOutput: (x) => x.MinimumAmount
            );
        }
    }

    public JsonElement ModelType
    {
        get
        {
            return Match(
                unit: (x) => x.ModelType,
                tiered: (x) => x.ModelType,
                bulk: (x) => x.ModelType,
                bulkWithFilters: (x) => x.ModelType,
                package: (x) => x.ModelType,
                matrix: (x) => x.ModelType,
                thresholdTotalAmount: (x) => x.ModelType,
                tieredPackage: (x) => x.ModelType,
                tieredWithMinimum: (x) => x.ModelType,
                groupedTiered: (x) => x.ModelType,
                tieredPackageWithMinimum: (x) => x.ModelType,
                packageWithAllocation: (x) => x.ModelType,
                unitWithPercent: (x) => x.ModelType,
                matrixWithAllocation: (x) => x.ModelType,
                tieredWithProration: (x) => x.ModelType,
                unitWithProration: (x) => x.ModelType,
                groupedAllocation: (x) => x.ModelType,
                bulkWithProration: (x) => x.ModelType,
                groupedWithProratedMinimum: (x) => x.ModelType,
                groupedWithMeteredMinimum: (x) => x.ModelType,
                groupedWithMinMaxThresholds: (x) => x.ModelType,
                matrixWithDisplayName: (x) => x.ModelType,
                groupedTieredPackage: (x) => x.ModelType,
                maxGroupTieredPackage: (x) => x.ModelType,
                scalableMatrixWithUnitPricing: (x) => x.ModelType,
                scalableMatrixWithTieredPricing: (x) => x.ModelType,
                cumulativeGroupedBulk: (x) => x.ModelType,
                cumulativeGroupedAllocation: (x) => x.ModelType,
                minimum: (x) => x.ModelType,
                percent: (x) => x.ModelType,
                eventOutput: (x) => x.ModelType
            );
        }
    }

    public string Name
    {
        get
        {
            return Match(
                unit: (x) => x.Name,
                tiered: (x) => x.Name,
                bulk: (x) => x.Name,
                bulkWithFilters: (x) => x.Name,
                package: (x) => x.Name,
                matrix: (x) => x.Name,
                thresholdTotalAmount: (x) => x.Name,
                tieredPackage: (x) => x.Name,
                tieredWithMinimum: (x) => x.Name,
                groupedTiered: (x) => x.Name,
                tieredPackageWithMinimum: (x) => x.Name,
                packageWithAllocation: (x) => x.Name,
                unitWithPercent: (x) => x.Name,
                matrixWithAllocation: (x) => x.Name,
                tieredWithProration: (x) => x.Name,
                unitWithProration: (x) => x.Name,
                groupedAllocation: (x) => x.Name,
                bulkWithProration: (x) => x.Name,
                groupedWithProratedMinimum: (x) => x.Name,
                groupedWithMeteredMinimum: (x) => x.Name,
                groupedWithMinMaxThresholds: (x) => x.Name,
                matrixWithDisplayName: (x) => x.Name,
                groupedTieredPackage: (x) => x.Name,
                maxGroupTieredPackage: (x) => x.Name,
                scalableMatrixWithUnitPricing: (x) => x.Name,
                scalableMatrixWithTieredPricing: (x) => x.Name,
                cumulativeGroupedBulk: (x) => x.Name,
                cumulativeGroupedAllocation: (x) => x.Name,
                minimum: (x) => x.Name,
                percent: (x) => x.Name,
                eventOutput: (x) => x.Name
            );
        }
    }

    public long? PlanPhaseOrder
    {
        get
        {
            return Match<long?>(
                unit: (x) => x.PlanPhaseOrder,
                tiered: (x) => x.PlanPhaseOrder,
                bulk: (x) => x.PlanPhaseOrder,
                bulkWithFilters: (x) => x.PlanPhaseOrder,
                package: (x) => x.PlanPhaseOrder,
                matrix: (x) => x.PlanPhaseOrder,
                thresholdTotalAmount: (x) => x.PlanPhaseOrder,
                tieredPackage: (x) => x.PlanPhaseOrder,
                tieredWithMinimum: (x) => x.PlanPhaseOrder,
                groupedTiered: (x) => x.PlanPhaseOrder,
                tieredPackageWithMinimum: (x) => x.PlanPhaseOrder,
                packageWithAllocation: (x) => x.PlanPhaseOrder,
                unitWithPercent: (x) => x.PlanPhaseOrder,
                matrixWithAllocation: (x) => x.PlanPhaseOrder,
                tieredWithProration: (x) => x.PlanPhaseOrder,
                unitWithProration: (x) => x.PlanPhaseOrder,
                groupedAllocation: (x) => x.PlanPhaseOrder,
                bulkWithProration: (x) => x.PlanPhaseOrder,
                groupedWithProratedMinimum: (x) => x.PlanPhaseOrder,
                groupedWithMeteredMinimum: (x) => x.PlanPhaseOrder,
                groupedWithMinMaxThresholds: (x) => x.PlanPhaseOrder,
                matrixWithDisplayName: (x) => x.PlanPhaseOrder,
                groupedTieredPackage: (x) => x.PlanPhaseOrder,
                maxGroupTieredPackage: (x) => x.PlanPhaseOrder,
                scalableMatrixWithUnitPricing: (x) => x.PlanPhaseOrder,
                scalableMatrixWithTieredPricing: (x) => x.PlanPhaseOrder,
                cumulativeGroupedBulk: (x) => x.PlanPhaseOrder,
                cumulativeGroupedAllocation: (x) => x.PlanPhaseOrder,
                minimum: (x) => x.PlanPhaseOrder,
                percent: (x) => x.PlanPhaseOrder,
                eventOutput: (x) => x.PlanPhaseOrder
            );
        }
    }

    public string? ReplacesPriceID
    {
        get
        {
            return Match<string?>(
                unit: (x) => x.ReplacesPriceID,
                tiered: (x) => x.ReplacesPriceID,
                bulk: (x) => x.ReplacesPriceID,
                bulkWithFilters: (x) => x.ReplacesPriceID,
                package: (x) => x.ReplacesPriceID,
                matrix: (x) => x.ReplacesPriceID,
                thresholdTotalAmount: (x) => x.ReplacesPriceID,
                tieredPackage: (x) => x.ReplacesPriceID,
                tieredWithMinimum: (x) => x.ReplacesPriceID,
                groupedTiered: (x) => x.ReplacesPriceID,
                tieredPackageWithMinimum: (x) => x.ReplacesPriceID,
                packageWithAllocation: (x) => x.ReplacesPriceID,
                unitWithPercent: (x) => x.ReplacesPriceID,
                matrixWithAllocation: (x) => x.ReplacesPriceID,
                tieredWithProration: (x) => x.ReplacesPriceID,
                unitWithProration: (x) => x.ReplacesPriceID,
                groupedAllocation: (x) => x.ReplacesPriceID,
                bulkWithProration: (x) => x.ReplacesPriceID,
                groupedWithProratedMinimum: (x) => x.ReplacesPriceID,
                groupedWithMeteredMinimum: (x) => x.ReplacesPriceID,
                groupedWithMinMaxThresholds: (x) => x.ReplacesPriceID,
                matrixWithDisplayName: (x) => x.ReplacesPriceID,
                groupedTieredPackage: (x) => x.ReplacesPriceID,
                maxGroupTieredPackage: (x) => x.ReplacesPriceID,
                scalableMatrixWithUnitPricing: (x) => x.ReplacesPriceID,
                scalableMatrixWithTieredPricing: (x) => x.ReplacesPriceID,
                cumulativeGroupedBulk: (x) => x.ReplacesPriceID,
                cumulativeGroupedAllocation: (x) => x.ReplacesPriceID,
                minimum: (x) => x.ReplacesPriceID,
                percent: (x) => x.ReplacesPriceID,
                eventOutput: (x) => x.ReplacesPriceID
            );
        }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return Match<DimensionalPriceConfiguration?>(
                unit: (x) => x.DimensionalPriceConfiguration,
                tiered: (x) => x.DimensionalPriceConfiguration,
                bulk: (x) => x.DimensionalPriceConfiguration,
                bulkWithFilters: (x) => x.DimensionalPriceConfiguration,
                package: (x) => x.DimensionalPriceConfiguration,
                matrix: (x) => x.DimensionalPriceConfiguration,
                thresholdTotalAmount: (x) => x.DimensionalPriceConfiguration,
                tieredPackage: (x) => x.DimensionalPriceConfiguration,
                tieredWithMinimum: (x) => x.DimensionalPriceConfiguration,
                groupedTiered: (x) => x.DimensionalPriceConfiguration,
                tieredPackageWithMinimum: (x) => x.DimensionalPriceConfiguration,
                packageWithAllocation: (x) => x.DimensionalPriceConfiguration,
                unitWithPercent: (x) => x.DimensionalPriceConfiguration,
                matrixWithAllocation: (x) => x.DimensionalPriceConfiguration,
                tieredWithProration: (x) => x.DimensionalPriceConfiguration,
                unitWithProration: (x) => x.DimensionalPriceConfiguration,
                groupedAllocation: (x) => x.DimensionalPriceConfiguration,
                bulkWithProration: (x) => x.DimensionalPriceConfiguration,
                groupedWithProratedMinimum: (x) => x.DimensionalPriceConfiguration,
                groupedWithMeteredMinimum: (x) => x.DimensionalPriceConfiguration,
                groupedWithMinMaxThresholds: (x) => x.DimensionalPriceConfiguration,
                matrixWithDisplayName: (x) => x.DimensionalPriceConfiguration,
                groupedTieredPackage: (x) => x.DimensionalPriceConfiguration,
                maxGroupTieredPackage: (x) => x.DimensionalPriceConfiguration,
                scalableMatrixWithUnitPricing: (x) => x.DimensionalPriceConfiguration,
                scalableMatrixWithTieredPricing: (x) => x.DimensionalPriceConfiguration,
                cumulativeGroupedBulk: (x) => x.DimensionalPriceConfiguration,
                cumulativeGroupedAllocation: (x) => x.DimensionalPriceConfiguration,
                minimum: (x) => x.DimensionalPriceConfiguration,
                percent: (x) => x.DimensionalPriceConfiguration,
                eventOutput: (x) => x.DimensionalPriceConfiguration
            );
        }
    }

    public Price(Unit value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(Tiered value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(Bulk value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(BulkWithFilters value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(Package value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(Matrix value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(ThresholdTotalAmount value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(TieredPackage value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(TieredWithMinimum value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(GroupedTiered value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(TieredPackageWithMinimum value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(PackageWithAllocation value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(UnitWithPercent value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(MatrixWithAllocation value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(TieredWithProration value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(UnitWithProration value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(GroupedAllocation value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(BulkWithProration value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(GroupedWithProratedMinimum value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(GroupedWithMeteredMinimum value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(GroupedWithMinMaxThresholds value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(MatrixWithDisplayName value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(GroupedTieredPackage value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(MaxGroupTieredPackage value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(ScalableMatrixWithUnitPricing value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(ScalableMatrixWithTieredPricing value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(CumulativeGroupedBulk value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(CumulativeGroupedAllocation value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(PriceMinimum value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(Percent value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(EventOutput value, JsonElement? element = null)
    {
        this.Value = value;
        this._element = element;
    }

    public Price(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="Unit"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `Unit`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out Unit? value)
    {
        value = this.Value as Unit;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="Tiered"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `Tiered`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out Tiered? value)
    {
        value = this.Value as Tiered;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="Bulk"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickBulk(out var value)) {
    ///     // `value` is of type `Bulk`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickBulk([NotNullWhen(true)] out Bulk? value)
    {
        value = this.Value as Bulk;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="BulkWithFilters"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickBulkWithFilters(out var value)) {
    ///     // `value` is of type `BulkWithFilters`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickBulkWithFilters([NotNullWhen(true)] out BulkWithFilters? value)
    {
        value = this.Value as BulkWithFilters;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="Package"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickPackage(out var value)) {
    ///     // `value` is of type `Package`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickPackage([NotNullWhen(true)] out Package? value)
    {
        value = this.Value as Package;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="Matrix"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickMatrix(out var value)) {
    ///     // `value` is of type `Matrix`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickMatrix([NotNullWhen(true)] out Matrix? value)
    {
        value = this.Value as Matrix;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="ThresholdTotalAmount"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickThresholdTotalAmount(out var value)) {
    ///     // `value` is of type `ThresholdTotalAmount`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickThresholdTotalAmount([NotNullWhen(true)] out ThresholdTotalAmount? value)
    {
        value = this.Value as ThresholdTotalAmount;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="TieredPackage"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTieredPackage(out var value)) {
    ///     // `value` is of type `TieredPackage`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTieredPackage([NotNullWhen(true)] out TieredPackage? value)
    {
        value = this.Value as TieredPackage;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="TieredWithMinimum"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTieredWithMinimum(out var value)) {
    ///     // `value` is of type `TieredWithMinimum`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTieredWithMinimum([NotNullWhen(true)] out TieredWithMinimum? value)
    {
        value = this.Value as TieredWithMinimum;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="GroupedTiered"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickGroupedTiered(out var value)) {
    ///     // `value` is of type `GroupedTiered`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickGroupedTiered([NotNullWhen(true)] out GroupedTiered? value)
    {
        value = this.Value as GroupedTiered;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="TieredPackageWithMinimum"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTieredPackageWithMinimum(out var value)) {
    ///     // `value` is of type `TieredPackageWithMinimum`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTieredPackageWithMinimum(
        [NotNullWhen(true)] out TieredPackageWithMinimum? value
    )
    {
        value = this.Value as TieredPackageWithMinimum;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="PackageWithAllocation"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickPackageWithAllocation(out var value)) {
    ///     // `value` is of type `PackageWithAllocation`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickPackageWithAllocation([NotNullWhen(true)] out PackageWithAllocation? value)
    {
        value = this.Value as PackageWithAllocation;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="UnitWithPercent"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnitWithPercent(out var value)) {
    ///     // `value` is of type `UnitWithPercent`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnitWithPercent([NotNullWhen(true)] out UnitWithPercent? value)
    {
        value = this.Value as UnitWithPercent;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="MatrixWithAllocation"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickMatrixWithAllocation(out var value)) {
    ///     // `value` is of type `MatrixWithAllocation`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickMatrixWithAllocation([NotNullWhen(true)] out MatrixWithAllocation? value)
    {
        value = this.Value as MatrixWithAllocation;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="TieredWithProration"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTieredWithProration(out var value)) {
    ///     // `value` is of type `TieredWithProration`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTieredWithProration([NotNullWhen(true)] out TieredWithProration? value)
    {
        value = this.Value as TieredWithProration;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="UnitWithProration"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnitWithProration(out var value)) {
    ///     // `value` is of type `UnitWithProration`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnitWithProration([NotNullWhen(true)] out UnitWithProration? value)
    {
        value = this.Value as UnitWithProration;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="GroupedAllocation"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickGroupedAllocation(out var value)) {
    ///     // `value` is of type `GroupedAllocation`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickGroupedAllocation([NotNullWhen(true)] out GroupedAllocation? value)
    {
        value = this.Value as GroupedAllocation;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="BulkWithProration"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickBulkWithProration(out var value)) {
    ///     // `value` is of type `BulkWithProration`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickBulkWithProration([NotNullWhen(true)] out BulkWithProration? value)
    {
        value = this.Value as BulkWithProration;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="GroupedWithProratedMinimum"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickGroupedWithProratedMinimum(out var value)) {
    ///     // `value` is of type `GroupedWithProratedMinimum`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickGroupedWithProratedMinimum(
        [NotNullWhen(true)] out GroupedWithProratedMinimum? value
    )
    {
        value = this.Value as GroupedWithProratedMinimum;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="GroupedWithMeteredMinimum"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickGroupedWithMeteredMinimum(out var value)) {
    ///     // `value` is of type `GroupedWithMeteredMinimum`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickGroupedWithMeteredMinimum(
        [NotNullWhen(true)] out GroupedWithMeteredMinimum? value
    )
    {
        value = this.Value as GroupedWithMeteredMinimum;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="GroupedWithMinMaxThresholds"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickGroupedWithMinMaxThresholds(out var value)) {
    ///     // `value` is of type `GroupedWithMinMaxThresholds`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickGroupedWithMinMaxThresholds(
        [NotNullWhen(true)] out GroupedWithMinMaxThresholds? value
    )
    {
        value = this.Value as GroupedWithMinMaxThresholds;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="MatrixWithDisplayName"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickMatrixWithDisplayName(out var value)) {
    ///     // `value` is of type `MatrixWithDisplayName`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickMatrixWithDisplayName([NotNullWhen(true)] out MatrixWithDisplayName? value)
    {
        value = this.Value as MatrixWithDisplayName;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="GroupedTieredPackage"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickGroupedTieredPackage(out var value)) {
    ///     // `value` is of type `GroupedTieredPackage`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickGroupedTieredPackage([NotNullWhen(true)] out GroupedTieredPackage? value)
    {
        value = this.Value as GroupedTieredPackage;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="MaxGroupTieredPackage"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickMaxGroupTieredPackage(out var value)) {
    ///     // `value` is of type `MaxGroupTieredPackage`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickMaxGroupTieredPackage([NotNullWhen(true)] out MaxGroupTieredPackage? value)
    {
        value = this.Value as MaxGroupTieredPackage;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="ScalableMatrixWithUnitPricing"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickScalableMatrixWithUnitPricing(out var value)) {
    ///     // `value` is of type `ScalableMatrixWithUnitPricing`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickScalableMatrixWithUnitPricing(
        [NotNullWhen(true)] out ScalableMatrixWithUnitPricing? value
    )
    {
        value = this.Value as ScalableMatrixWithUnitPricing;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="ScalableMatrixWithTieredPricing"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickScalableMatrixWithTieredPricing(out var value)) {
    ///     // `value` is of type `ScalableMatrixWithTieredPricing`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickScalableMatrixWithTieredPricing(
        [NotNullWhen(true)] out ScalableMatrixWithTieredPricing? value
    )
    {
        value = this.Value as ScalableMatrixWithTieredPricing;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="CumulativeGroupedBulk"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickCumulativeGroupedBulk(out var value)) {
    ///     // `value` is of type `CumulativeGroupedBulk`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickCumulativeGroupedBulk([NotNullWhen(true)] out CumulativeGroupedBulk? value)
    {
        value = this.Value as CumulativeGroupedBulk;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="CumulativeGroupedAllocation"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickCumulativeGroupedAllocation(out var value)) {
    ///     // `value` is of type `CumulativeGroupedAllocation`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickCumulativeGroupedAllocation(
        [NotNullWhen(true)] out CumulativeGroupedAllocation? value
    )
    {
        value = this.Value as CumulativeGroupedAllocation;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="PriceMinimum"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickMinimum(out var value)) {
    ///     // `value` is of type `PriceMinimum`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickMinimum([NotNullWhen(true)] out PriceMinimum? value)
    {
        value = this.Value as PriceMinimum;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="Percent"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickPercent(out var value)) {
    ///     // `value` is of type `Percent`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickPercent([NotNullWhen(true)] out Percent? value)
    {
        value = this.Value as Percent;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="EventOutput"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickEventOutput(out var value)) {
    ///     // `value` is of type `EventOutput`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickEventOutput([NotNullWhen(true)] out EventOutput? value)
    {
        value = this.Value as EventOutput;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (Unit value) => {...},
    ///     (Tiered value) => {...},
    ///     (Bulk value) => {...},
    ///     (BulkWithFilters value) => {...},
    ///     (Package value) => {...},
    ///     (Matrix value) => {...},
    ///     (ThresholdTotalAmount value) => {...},
    ///     (TieredPackage value) => {...},
    ///     (TieredWithMinimum value) => {...},
    ///     (GroupedTiered value) => {...},
    ///     (TieredPackageWithMinimum value) => {...},
    ///     (PackageWithAllocation value) => {...},
    ///     (UnitWithPercent value) => {...},
    ///     (MatrixWithAllocation value) => {...},
    ///     (TieredWithProration value) => {...},
    ///     (UnitWithProration value) => {...},
    ///     (GroupedAllocation value) => {...},
    ///     (BulkWithProration value) => {...},
    ///     (GroupedWithProratedMinimum value) => {...},
    ///     (GroupedWithMeteredMinimum value) => {...},
    ///     (GroupedWithMinMaxThresholds value) => {...},
    ///     (MatrixWithDisplayName value) => {...},
    ///     (GroupedTieredPackage value) => {...},
    ///     (MaxGroupTieredPackage value) => {...},
    ///     (ScalableMatrixWithUnitPricing value) => {...},
    ///     (ScalableMatrixWithTieredPricing value) => {...},
    ///     (CumulativeGroupedBulk value) => {...},
    ///     (CumulativeGroupedAllocation value) => {...},
    ///     (PriceMinimum value) => {...},
    ///     (Percent value) => {...},
    ///     (EventOutput value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<Unit> unit,
        System::Action<Tiered> tiered,
        System::Action<Bulk> bulk,
        System::Action<BulkWithFilters> bulkWithFilters,
        System::Action<Package> package,
        System::Action<Matrix> matrix,
        System::Action<ThresholdTotalAmount> thresholdTotalAmount,
        System::Action<TieredPackage> tieredPackage,
        System::Action<TieredWithMinimum> tieredWithMinimum,
        System::Action<GroupedTiered> groupedTiered,
        System::Action<TieredPackageWithMinimum> tieredPackageWithMinimum,
        System::Action<PackageWithAllocation> packageWithAllocation,
        System::Action<UnitWithPercent> unitWithPercent,
        System::Action<MatrixWithAllocation> matrixWithAllocation,
        System::Action<TieredWithProration> tieredWithProration,
        System::Action<UnitWithProration> unitWithProration,
        System::Action<GroupedAllocation> groupedAllocation,
        System::Action<BulkWithProration> bulkWithProration,
        System::Action<GroupedWithProratedMinimum> groupedWithProratedMinimum,
        System::Action<GroupedWithMeteredMinimum> groupedWithMeteredMinimum,
        System::Action<GroupedWithMinMaxThresholds> groupedWithMinMaxThresholds,
        System::Action<MatrixWithDisplayName> matrixWithDisplayName,
        System::Action<GroupedTieredPackage> groupedTieredPackage,
        System::Action<MaxGroupTieredPackage> maxGroupTieredPackage,
        System::Action<ScalableMatrixWithUnitPricing> scalableMatrixWithUnitPricing,
        System::Action<ScalableMatrixWithTieredPricing> scalableMatrixWithTieredPricing,
        System::Action<CumulativeGroupedBulk> cumulativeGroupedBulk,
        System::Action<CumulativeGroupedAllocation> cumulativeGroupedAllocation,
        System::Action<PriceMinimum> minimum,
        System::Action<Percent> percent,
        System::Action<EventOutput> eventOutput
    )
    {
        switch (this.Value)
        {
            case Unit value:
                unit(value);
                break;
            case Tiered value:
                tiered(value);
                break;
            case Bulk value:
                bulk(value);
                break;
            case BulkWithFilters value:
                bulkWithFilters(value);
                break;
            case Package value:
                package(value);
                break;
            case Matrix value:
                matrix(value);
                break;
            case ThresholdTotalAmount value:
                thresholdTotalAmount(value);
                break;
            case TieredPackage value:
                tieredPackage(value);
                break;
            case TieredWithMinimum value:
                tieredWithMinimum(value);
                break;
            case GroupedTiered value:
                groupedTiered(value);
                break;
            case TieredPackageWithMinimum value:
                tieredPackageWithMinimum(value);
                break;
            case PackageWithAllocation value:
                packageWithAllocation(value);
                break;
            case UnitWithPercent value:
                unitWithPercent(value);
                break;
            case MatrixWithAllocation value:
                matrixWithAllocation(value);
                break;
            case TieredWithProration value:
                tieredWithProration(value);
                break;
            case UnitWithProration value:
                unitWithProration(value);
                break;
            case GroupedAllocation value:
                groupedAllocation(value);
                break;
            case BulkWithProration value:
                bulkWithProration(value);
                break;
            case GroupedWithProratedMinimum value:
                groupedWithProratedMinimum(value);
                break;
            case GroupedWithMeteredMinimum value:
                groupedWithMeteredMinimum(value);
                break;
            case GroupedWithMinMaxThresholds value:
                groupedWithMinMaxThresholds(value);
                break;
            case MatrixWithDisplayName value:
                matrixWithDisplayName(value);
                break;
            case GroupedTieredPackage value:
                groupedTieredPackage(value);
                break;
            case MaxGroupTieredPackage value:
                maxGroupTieredPackage(value);
                break;
            case ScalableMatrixWithUnitPricing value:
                scalableMatrixWithUnitPricing(value);
                break;
            case ScalableMatrixWithTieredPricing value:
                scalableMatrixWithTieredPricing(value);
                break;
            case CumulativeGroupedBulk value:
                cumulativeGroupedBulk(value);
                break;
            case CumulativeGroupedAllocation value:
                cumulativeGroupedAllocation(value);
                break;
            case PriceMinimum value:
                minimum(value);
                break;
            case Percent value:
                percent(value);
                break;
            case EventOutput value:
                eventOutput(value);
                break;
            default:
                throw new OrbInvalidDataException("Data did not match any variant of Price");
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (Unit value) => {...},
    ///     (Tiered value) => {...},
    ///     (Bulk value) => {...},
    ///     (BulkWithFilters value) => {...},
    ///     (Package value) => {...},
    ///     (Matrix value) => {...},
    ///     (ThresholdTotalAmount value) => {...},
    ///     (TieredPackage value) => {...},
    ///     (TieredWithMinimum value) => {...},
    ///     (GroupedTiered value) => {...},
    ///     (TieredPackageWithMinimum value) => {...},
    ///     (PackageWithAllocation value) => {...},
    ///     (UnitWithPercent value) => {...},
    ///     (MatrixWithAllocation value) => {...},
    ///     (TieredWithProration value) => {...},
    ///     (UnitWithProration value) => {...},
    ///     (GroupedAllocation value) => {...},
    ///     (BulkWithProration value) => {...},
    ///     (GroupedWithProratedMinimum value) => {...},
    ///     (GroupedWithMeteredMinimum value) => {...},
    ///     (GroupedWithMinMaxThresholds value) => {...},
    ///     (MatrixWithDisplayName value) => {...},
    ///     (GroupedTieredPackage value) => {...},
    ///     (MaxGroupTieredPackage value) => {...},
    ///     (ScalableMatrixWithUnitPricing value) => {...},
    ///     (ScalableMatrixWithTieredPricing value) => {...},
    ///     (CumulativeGroupedBulk value) => {...},
    ///     (CumulativeGroupedAllocation value) => {...},
    ///     (PriceMinimum value) => {...},
    ///     (Percent value) => {...},
    ///     (EventOutput value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<Unit, T> unit,
        System::Func<Tiered, T> tiered,
        System::Func<Bulk, T> bulk,
        System::Func<BulkWithFilters, T> bulkWithFilters,
        System::Func<Package, T> package,
        System::Func<Matrix, T> matrix,
        System::Func<ThresholdTotalAmount, T> thresholdTotalAmount,
        System::Func<TieredPackage, T> tieredPackage,
        System::Func<TieredWithMinimum, T> tieredWithMinimum,
        System::Func<GroupedTiered, T> groupedTiered,
        System::Func<TieredPackageWithMinimum, T> tieredPackageWithMinimum,
        System::Func<PackageWithAllocation, T> packageWithAllocation,
        System::Func<UnitWithPercent, T> unitWithPercent,
        System::Func<MatrixWithAllocation, T> matrixWithAllocation,
        System::Func<TieredWithProration, T> tieredWithProration,
        System::Func<UnitWithProration, T> unitWithProration,
        System::Func<GroupedAllocation, T> groupedAllocation,
        System::Func<BulkWithProration, T> bulkWithProration,
        System::Func<GroupedWithProratedMinimum, T> groupedWithProratedMinimum,
        System::Func<GroupedWithMeteredMinimum, T> groupedWithMeteredMinimum,
        System::Func<GroupedWithMinMaxThresholds, T> groupedWithMinMaxThresholds,
        System::Func<MatrixWithDisplayName, T> matrixWithDisplayName,
        System::Func<GroupedTieredPackage, T> groupedTieredPackage,
        System::Func<MaxGroupTieredPackage, T> maxGroupTieredPackage,
        System::Func<ScalableMatrixWithUnitPricing, T> scalableMatrixWithUnitPricing,
        System::Func<ScalableMatrixWithTieredPricing, T> scalableMatrixWithTieredPricing,
        System::Func<CumulativeGroupedBulk, T> cumulativeGroupedBulk,
        System::Func<CumulativeGroupedAllocation, T> cumulativeGroupedAllocation,
        System::Func<PriceMinimum, T> minimum,
        System::Func<Percent, T> percent,
        System::Func<EventOutput, T> eventOutput
    )
    {
        return this.Value switch
        {
            Unit value => unit(value),
            Tiered value => tiered(value),
            Bulk value => bulk(value),
            BulkWithFilters value => bulkWithFilters(value),
            Package value => package(value),
            Matrix value => matrix(value),
            ThresholdTotalAmount value => thresholdTotalAmount(value),
            TieredPackage value => tieredPackage(value),
            TieredWithMinimum value => tieredWithMinimum(value),
            GroupedTiered value => groupedTiered(value),
            TieredPackageWithMinimum value => tieredPackageWithMinimum(value),
            PackageWithAllocation value => packageWithAllocation(value),
            UnitWithPercent value => unitWithPercent(value),
            MatrixWithAllocation value => matrixWithAllocation(value),
            TieredWithProration value => tieredWithProration(value),
            UnitWithProration value => unitWithProration(value),
            GroupedAllocation value => groupedAllocation(value),
            BulkWithProration value => bulkWithProration(value),
            GroupedWithProratedMinimum value => groupedWithProratedMinimum(value),
            GroupedWithMeteredMinimum value => groupedWithMeteredMinimum(value),
            GroupedWithMinMaxThresholds value => groupedWithMinMaxThresholds(value),
            MatrixWithDisplayName value => matrixWithDisplayName(value),
            GroupedTieredPackage value => groupedTieredPackage(value),
            MaxGroupTieredPackage value => maxGroupTieredPackage(value),
            ScalableMatrixWithUnitPricing value => scalableMatrixWithUnitPricing(value),
            ScalableMatrixWithTieredPricing value => scalableMatrixWithTieredPricing(value),
            CumulativeGroupedBulk value => cumulativeGroupedBulk(value),
            CumulativeGroupedAllocation value => cumulativeGroupedAllocation(value),
            PriceMinimum value => minimum(value),
            Percent value => percent(value),
            EventOutput value => eventOutput(value),
            _ => throw new OrbInvalidDataException("Data did not match any variant of Price"),
        };
    }

    public static implicit operator Price(Unit value) => new(value);

    public static implicit operator Price(Tiered value) => new(value);

    public static implicit operator Price(Bulk value) => new(value);

    public static implicit operator Price(BulkWithFilters value) => new(value);

    public static implicit operator Price(Package value) => new(value);

    public static implicit operator Price(Matrix value) => new(value);

    public static implicit operator Price(ThresholdTotalAmount value) => new(value);

    public static implicit operator Price(TieredPackage value) => new(value);

    public static implicit operator Price(TieredWithMinimum value) => new(value);

    public static implicit operator Price(GroupedTiered value) => new(value);

    public static implicit operator Price(TieredPackageWithMinimum value) => new(value);

    public static implicit operator Price(PackageWithAllocation value) => new(value);

    public static implicit operator Price(UnitWithPercent value) => new(value);

    public static implicit operator Price(MatrixWithAllocation value) => new(value);

    public static implicit operator Price(TieredWithProration value) => new(value);

    public static implicit operator Price(UnitWithProration value) => new(value);

    public static implicit operator Price(GroupedAllocation value) => new(value);

    public static implicit operator Price(BulkWithProration value) => new(value);

    public static implicit operator Price(GroupedWithProratedMinimum value) => new(value);

    public static implicit operator Price(GroupedWithMeteredMinimum value) => new(value);

    public static implicit operator Price(GroupedWithMinMaxThresholds value) => new(value);

    public static implicit operator Price(MatrixWithDisplayName value) => new(value);

    public static implicit operator Price(GroupedTieredPackage value) => new(value);

    public static implicit operator Price(MaxGroupTieredPackage value) => new(value);

    public static implicit operator Price(ScalableMatrixWithUnitPricing value) => new(value);

    public static implicit operator Price(ScalableMatrixWithTieredPricing value) => new(value);

    public static implicit operator Price(CumulativeGroupedBulk value) => new(value);

    public static implicit operator Price(CumulativeGroupedAllocation value) => new(value);

    public static implicit operator Price(PriceMinimum value) => new(value);

    public static implicit operator Price(Percent value) => new(value);

    public static implicit operator Price(EventOutput value) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException("Data did not match any variant of Price");
        }
        this.Switch(
            (unit) => unit.Validate(),
            (tiered) => tiered.Validate(),
            (bulk) => bulk.Validate(),
            (bulkWithFilters) => bulkWithFilters.Validate(),
            (package) => package.Validate(),
            (matrix) => matrix.Validate(),
            (thresholdTotalAmount) => thresholdTotalAmount.Validate(),
            (tieredPackage) => tieredPackage.Validate(),
            (tieredWithMinimum) => tieredWithMinimum.Validate(),
            (groupedTiered) => groupedTiered.Validate(),
            (tieredPackageWithMinimum) => tieredPackageWithMinimum.Validate(),
            (packageWithAllocation) => packageWithAllocation.Validate(),
            (unitWithPercent) => unitWithPercent.Validate(),
            (matrixWithAllocation) => matrixWithAllocation.Validate(),
            (tieredWithProration) => tieredWithProration.Validate(),
            (unitWithProration) => unitWithProration.Validate(),
            (groupedAllocation) => groupedAllocation.Validate(),
            (bulkWithProration) => bulkWithProration.Validate(),
            (groupedWithProratedMinimum) => groupedWithProratedMinimum.Validate(),
            (groupedWithMeteredMinimum) => groupedWithMeteredMinimum.Validate(),
            (groupedWithMinMaxThresholds) => groupedWithMinMaxThresholds.Validate(),
            (matrixWithDisplayName) => matrixWithDisplayName.Validate(),
            (groupedTieredPackage) => groupedTieredPackage.Validate(),
            (maxGroupTieredPackage) => maxGroupTieredPackage.Validate(),
            (scalableMatrixWithUnitPricing) => scalableMatrixWithUnitPricing.Validate(),
            (scalableMatrixWithTieredPricing) => scalableMatrixWithTieredPricing.Validate(),
            (cumulativeGroupedBulk) => cumulativeGroupedBulk.Validate(),
            (cumulativeGroupedAllocation) => cumulativeGroupedAllocation.Validate(),
            (minimum) => minimum.Validate(),
            (percent) => percent.Validate(),
            (eventOutput) => eventOutput.Validate()
        );
    }

    public virtual bool Equals(Price? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class PriceConverter : JsonConverter<Price>
{
    public override Price? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? modelType;
        try
        {
            modelType = element.GetProperty("model_type").GetString();
        }
        catch
        {
            modelType = null;
        }

        switch (modelType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<Unit>(element, options);
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<Tiered>(element, options);
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "bulk":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<Bulk>(element, options);
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "bulk_with_filters":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<BulkWithFilters>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "package":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<Package>(element, options);
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "matrix":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<Matrix>(element, options);
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "threshold_total_amount":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<ThresholdTotalAmount>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered_package":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<TieredPackage>(element, options);
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered_with_minimum":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<TieredWithMinimum>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "grouped_tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<GroupedTiered>(element, options);
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered_package_with_minimum":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<TieredPackageWithMinimum>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "package_with_allocation":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<PackageWithAllocation>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "unit_with_percent":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<UnitWithPercent>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "matrix_with_allocation":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<MatrixWithAllocation>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered_with_proration":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<TieredWithProration>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "unit_with_proration":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<UnitWithProration>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "grouped_allocation":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<GroupedAllocation>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "bulk_with_proration":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<BulkWithProration>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "grouped_with_prorated_minimum":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<GroupedWithProratedMinimum>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "grouped_with_metered_minimum":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<GroupedWithMeteredMinimum>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "grouped_with_min_max_thresholds":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<GroupedWithMinMaxThresholds>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "matrix_with_display_name":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<MatrixWithDisplayName>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "grouped_tiered_package":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<GroupedTieredPackage>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "max_group_tiered_package":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<MaxGroupTieredPackage>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "scalable_matrix_with_unit_pricing":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<ScalableMatrixWithUnitPricing>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "scalable_matrix_with_tiered_pricing":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<ScalableMatrixWithTieredPricing>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "cumulative_grouped_bulk":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<CumulativeGroupedBulk>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "cumulative_grouped_allocation":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<CumulativeGroupedAllocation>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "minimum":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<PriceMinimum>(element, options);
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "percent":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<Percent>(element, options);
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "event_output":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<EventOutput>(element, options);
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new Price(element);
            }
        }
    }

    public override void Write(Utf8JsonWriter writer, Price value, JsonSerializerOptions options)
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(JsonModelConverter<Unit, UnitFromRaw>))]
public sealed record class Unit : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, BillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, BillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, UnitCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, UnitCadence>>(this.RawData, "cadence");
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<CompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<CompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required UnitConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<UnitConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, UnitPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, UnitPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    /// <summary>
    /// Configuration for unit pricing
    /// </summary>
    public required UnitConfig UnitConfig
    {
        get { return JsonModel.GetNotNullClass<UnitConfig>(this.RawData, "unit_config"); }
        init { JsonModel.Set(this._rawData, "unit_config", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"unit\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.UnitConfig.Validate();
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Unit()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"unit\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Unit(Unit unit)
        : base(unit) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Unit(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"unit\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    Unit(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="UnitFromRaw.FromRawUnchecked"/>
    public static Unit FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class UnitFromRaw : IFromRawJson<Unit>
{
    /// <inheritdoc/>
    public Unit FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        Unit.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(BillingModeConverter))]
public enum BillingMode
{
    InAdvance,
    InArrear,
}

sealed class BillingModeConverter : JsonConverter<BillingMode>
{
    public override BillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => BillingMode.InAdvance,
            "in_arrear" => BillingMode.InArrear,
            _ => (BillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BillingMode.InAdvance => "in_advance",
                BillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(UnitCadenceConverter))]
public enum UnitCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class UnitCadenceConverter : JsonConverter<UnitCadence>
{
    public override UnitCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => UnitCadence.OneTime,
            "monthly" => UnitCadence.Monthly,
            "quarterly" => UnitCadence.Quarterly,
            "semi_annual" => UnitCadence.SemiAnnual,
            "annual" => UnitCadence.Annual,
            "custom" => UnitCadence.Custom,
            _ => (UnitCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        UnitCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                UnitCadence.OneTime => "one_time",
                UnitCadence.Monthly => "monthly",
                UnitCadence.Quarterly => "quarterly",
                UnitCadence.SemiAnnual => "semi_annual",
                UnitCadence.Annual => "annual",
                UnitCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<CompositePriceFilter, CompositePriceFilterFromRaw>))]
public sealed record class CompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, CompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, CompositePriceFilterField>>(
                this.RawData,
                "field"
            );
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, CompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, CompositePriceFilterOperator>>(
                this.RawData,
                "operator"
            );
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public CompositePriceFilter() { }

    public CompositePriceFilter(CompositePriceFilter compositePriceFilter)
        : base(compositePriceFilter) { }

    public CompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    CompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="CompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static CompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class CompositePriceFilterFromRaw : IFromRawJson<CompositePriceFilter>
{
    /// <inheritdoc/>
    public CompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => CompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(CompositePriceFilterFieldConverter))]
public enum CompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class CompositePriceFilterFieldConverter : JsonConverter<CompositePriceFilterField>
{
    public override CompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => CompositePriceFilterField.PriceID,
            "item_id" => CompositePriceFilterField.ItemID,
            "price_type" => CompositePriceFilterField.PriceType,
            "currency" => CompositePriceFilterField.Currency,
            "pricing_unit_id" => CompositePriceFilterField.PricingUnitID,
            _ => (CompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        CompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                CompositePriceFilterField.PriceID => "price_id",
                CompositePriceFilterField.ItemID => "item_id",
                CompositePriceFilterField.PriceType => "price_type",
                CompositePriceFilterField.Currency => "currency",
                CompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(CompositePriceFilterOperatorConverter))]
public enum CompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class CompositePriceFilterOperatorConverter : JsonConverter<CompositePriceFilterOperator>
{
    public override CompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => CompositePriceFilterOperator.Includes,
            "excludes" => CompositePriceFilterOperator.Excludes,
            _ => (CompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        CompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                CompositePriceFilterOperator.Includes => "includes",
                CompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(UnitConversionRateConfigConverter))]
public record class UnitConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public UnitConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public UnitConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public UnitConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of UnitConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of UnitConversionRateConfig"
            ),
        };
    }

    public static implicit operator UnitConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator UnitConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of UnitConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(UnitConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class UnitConversionRateConfigConverter : JsonConverter<UnitConversionRateConfig>
{
    public override UnitConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new UnitConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        UnitConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(UnitPriceTypeConverter))]
public enum UnitPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class UnitPriceTypeConverter : JsonConverter<UnitPriceType>
{
    public override UnitPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => UnitPriceType.UsagePrice,
            "fixed_price" => UnitPriceType.FixedPrice,
            "composite_price" => UnitPriceType.CompositePrice,
            _ => (UnitPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        UnitPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                UnitPriceType.UsagePrice => "usage_price",
                UnitPriceType.FixedPrice => "fixed_price",
                UnitPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<Tiered, TieredFromRaw>))]
public sealed record class Tiered : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, TieredBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, TieredCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<TieredCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<TieredCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required TieredConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<TieredConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, TieredPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    /// <summary>
    /// Configuration for tiered pricing
    /// </summary>
    public required TieredConfig TieredConfig
    {
        get { return JsonModel.GetNotNullClass<TieredConfig>(this.RawData, "tiered_config"); }
        init { JsonModel.Set(this._rawData, "tiered_config", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"tiered\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.TieredConfig.Validate();
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Tiered()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"tiered\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Tiered(Tiered tiered)
        : base(tiered) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Tiered(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"tiered\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    Tiered(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredFromRaw.FromRawUnchecked"/>
    public static Tiered FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredFromRaw : IFromRawJson<Tiered>
{
    /// <inheritdoc/>
    public Tiered FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        Tiered.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(TieredBillingModeConverter))]
public enum TieredBillingMode
{
    InAdvance,
    InArrear,
}

sealed class TieredBillingModeConverter : JsonConverter<TieredBillingMode>
{
    public override TieredBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => TieredBillingMode.InAdvance,
            "in_arrear" => TieredBillingMode.InArrear,
            _ => (TieredBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredBillingMode.InAdvance => "in_advance",
                TieredBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(TieredCadenceConverter))]
public enum TieredCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class TieredCadenceConverter : JsonConverter<TieredCadence>
{
    public override TieredCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => TieredCadence.OneTime,
            "monthly" => TieredCadence.Monthly,
            "quarterly" => TieredCadence.Quarterly,
            "semi_annual" => TieredCadence.SemiAnnual,
            "annual" => TieredCadence.Annual,
            "custom" => TieredCadence.Custom,
            _ => (TieredCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredCadence.OneTime => "one_time",
                TieredCadence.Monthly => "monthly",
                TieredCadence.Quarterly => "quarterly",
                TieredCadence.SemiAnnual => "semi_annual",
                TieredCadence.Annual => "annual",
                TieredCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<TieredCompositePriceFilter, TieredCompositePriceFilterFromRaw>)
)]
public sealed record class TieredCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, TieredCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredCompositePriceFilterField>>(
                this.RawData,
                "field"
            );
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, TieredCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredCompositePriceFilterOperator>>(
                this.RawData,
                "operator"
            );
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public TieredCompositePriceFilter() { }

    public TieredCompositePriceFilter(TieredCompositePriceFilter tieredCompositePriceFilter)
        : base(tieredCompositePriceFilter) { }

    public TieredCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    TieredCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static TieredCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredCompositePriceFilterFromRaw : IFromRawJson<TieredCompositePriceFilter>
{
    /// <inheritdoc/>
    public TieredCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => TieredCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(TieredCompositePriceFilterFieldConverter))]
public enum TieredCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class TieredCompositePriceFilterFieldConverter
    : JsonConverter<TieredCompositePriceFilterField>
{
    public override TieredCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => TieredCompositePriceFilterField.PriceID,
            "item_id" => TieredCompositePriceFilterField.ItemID,
            "price_type" => TieredCompositePriceFilterField.PriceType,
            "currency" => TieredCompositePriceFilterField.Currency,
            "pricing_unit_id" => TieredCompositePriceFilterField.PricingUnitID,
            _ => (TieredCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredCompositePriceFilterField.PriceID => "price_id",
                TieredCompositePriceFilterField.ItemID => "item_id",
                TieredCompositePriceFilterField.PriceType => "price_type",
                TieredCompositePriceFilterField.Currency => "currency",
                TieredCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(TieredCompositePriceFilterOperatorConverter))]
public enum TieredCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class TieredCompositePriceFilterOperatorConverter
    : JsonConverter<TieredCompositePriceFilterOperator>
{
    public override TieredCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => TieredCompositePriceFilterOperator.Includes,
            "excludes" => TieredCompositePriceFilterOperator.Excludes,
            _ => (TieredCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredCompositePriceFilterOperator.Includes => "includes",
                TieredCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(TieredConversionRateConfigConverter))]
public record class TieredConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public TieredConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public TieredConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public TieredConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of TieredConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of TieredConversionRateConfig"
            ),
        };
    }

    public static implicit operator TieredConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator TieredConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of TieredConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(TieredConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class TieredConversionRateConfigConverter : JsonConverter<TieredConversionRateConfig>
{
    public override TieredConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new TieredConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(TieredPriceTypeConverter))]
public enum TieredPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class TieredPriceTypeConverter : JsonConverter<TieredPriceType>
{
    public override TieredPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => TieredPriceType.UsagePrice,
            "fixed_price" => TieredPriceType.FixedPrice,
            "composite_price" => TieredPriceType.CompositePrice,
            _ => (TieredPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredPriceType.UsagePrice => "usage_price",
                TieredPriceType.FixedPrice => "fixed_price",
                TieredPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<Bulk, BulkFromRaw>))]
public sealed record class Bulk : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, BulkBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, BulkBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    /// <summary>
    /// Configuration for bulk pricing
    /// </summary>
    public required BulkConfig BulkConfig
    {
        get { return JsonModel.GetNotNullClass<BulkConfig>(this.RawData, "bulk_config"); }
        init { JsonModel.Set(this._rawData, "bulk_config", value); }
    }

    public required ApiEnum<string, BulkCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, BulkCadence>>(this.RawData, "cadence");
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<BulkCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<BulkCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required BulkConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<BulkConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, BulkPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, BulkPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.BulkConfig.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"bulk\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Bulk()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"bulk\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Bulk(Bulk bulk)
        : base(bulk) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Bulk(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"bulk\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    Bulk(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="BulkFromRaw.FromRawUnchecked"/>
    public static Bulk FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class BulkFromRaw : IFromRawJson<Bulk>
{
    /// <inheritdoc/>
    public Bulk FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        Bulk.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(BulkBillingModeConverter))]
public enum BulkBillingMode
{
    InAdvance,
    InArrear,
}

sealed class BulkBillingModeConverter : JsonConverter<BulkBillingMode>
{
    public override BulkBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => BulkBillingMode.InAdvance,
            "in_arrear" => BulkBillingMode.InArrear,
            _ => (BulkBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BulkBillingMode.InAdvance => "in_advance",
                BulkBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(BulkCadenceConverter))]
public enum BulkCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class BulkCadenceConverter : JsonConverter<BulkCadence>
{
    public override BulkCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => BulkCadence.OneTime,
            "monthly" => BulkCadence.Monthly,
            "quarterly" => BulkCadence.Quarterly,
            "semi_annual" => BulkCadence.SemiAnnual,
            "annual" => BulkCadence.Annual,
            "custom" => BulkCadence.Custom,
            _ => (BulkCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BulkCadence.OneTime => "one_time",
                BulkCadence.Monthly => "monthly",
                BulkCadence.Quarterly => "quarterly",
                BulkCadence.SemiAnnual => "semi_annual",
                BulkCadence.Annual => "annual",
                BulkCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<BulkCompositePriceFilter, BulkCompositePriceFilterFromRaw>)
)]
public sealed record class BulkCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, BulkCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, BulkCompositePriceFilterField>>(
                this.RawData,
                "field"
            );
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, BulkCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, BulkCompositePriceFilterOperator>>(
                this.RawData,
                "operator"
            );
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public BulkCompositePriceFilter() { }

    public BulkCompositePriceFilter(BulkCompositePriceFilter bulkCompositePriceFilter)
        : base(bulkCompositePriceFilter) { }

    public BulkCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    BulkCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="BulkCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static BulkCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class BulkCompositePriceFilterFromRaw : IFromRawJson<BulkCompositePriceFilter>
{
    /// <inheritdoc/>
    public BulkCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => BulkCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(BulkCompositePriceFilterFieldConverter))]
public enum BulkCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class BulkCompositePriceFilterFieldConverter : JsonConverter<BulkCompositePriceFilterField>
{
    public override BulkCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => BulkCompositePriceFilterField.PriceID,
            "item_id" => BulkCompositePriceFilterField.ItemID,
            "price_type" => BulkCompositePriceFilterField.PriceType,
            "currency" => BulkCompositePriceFilterField.Currency,
            "pricing_unit_id" => BulkCompositePriceFilterField.PricingUnitID,
            _ => (BulkCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BulkCompositePriceFilterField.PriceID => "price_id",
                BulkCompositePriceFilterField.ItemID => "item_id",
                BulkCompositePriceFilterField.PriceType => "price_type",
                BulkCompositePriceFilterField.Currency => "currency",
                BulkCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(BulkCompositePriceFilterOperatorConverter))]
public enum BulkCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class BulkCompositePriceFilterOperatorConverter
    : JsonConverter<BulkCompositePriceFilterOperator>
{
    public override BulkCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => BulkCompositePriceFilterOperator.Includes,
            "excludes" => BulkCompositePriceFilterOperator.Excludes,
            _ => (BulkCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BulkCompositePriceFilterOperator.Includes => "includes",
                BulkCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(BulkConversionRateConfigConverter))]
public record class BulkConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public BulkConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public BulkConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public BulkConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of BulkConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of BulkConversionRateConfig"
            ),
        };
    }

    public static implicit operator BulkConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator BulkConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of BulkConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(BulkConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class BulkConversionRateConfigConverter : JsonConverter<BulkConversionRateConfig>
{
    public override BulkConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new BulkConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(BulkPriceTypeConverter))]
public enum BulkPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class BulkPriceTypeConverter : JsonConverter<BulkPriceType>
{
    public override BulkPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => BulkPriceType.UsagePrice,
            "fixed_price" => BulkPriceType.FixedPrice,
            "composite_price" => BulkPriceType.CompositePrice,
            _ => (BulkPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BulkPriceType.UsagePrice => "usage_price",
                BulkPriceType.FixedPrice => "fixed_price",
                BulkPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<BulkWithFilters, BulkWithFiltersFromRaw>))]
public sealed record class BulkWithFilters : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, BulkWithFiltersBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, BulkWithFiltersBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    /// <summary>
    /// Configuration for bulk_with_filters pricing
    /// </summary>
    public required BulkWithFiltersConfig BulkWithFiltersConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<BulkWithFiltersConfig>(
                this.RawData,
                "bulk_with_filters_config"
            );
        }
        init { JsonModel.Set(this._rawData, "bulk_with_filters_config", value); }
    }

    public required ApiEnum<string, BulkWithFiltersCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, BulkWithFiltersCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<BulkWithFiltersCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<BulkWithFiltersCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required BulkWithFiltersConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<BulkWithFiltersConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, BulkWithFiltersPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, BulkWithFiltersPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.BulkWithFiltersConfig.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"bulk_with_filters\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public BulkWithFilters()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"bulk_with_filters\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public BulkWithFilters(BulkWithFilters bulkWithFilters)
        : base(bulkWithFilters) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public BulkWithFilters(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"bulk_with_filters\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    BulkWithFilters(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="BulkWithFiltersFromRaw.FromRawUnchecked"/>
    public static BulkWithFilters FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class BulkWithFiltersFromRaw : IFromRawJson<BulkWithFilters>
{
    /// <inheritdoc/>
    public BulkWithFilters FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        BulkWithFilters.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(BulkWithFiltersBillingModeConverter))]
public enum BulkWithFiltersBillingMode
{
    InAdvance,
    InArrear,
}

sealed class BulkWithFiltersBillingModeConverter : JsonConverter<BulkWithFiltersBillingMode>
{
    public override BulkWithFiltersBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => BulkWithFiltersBillingMode.InAdvance,
            "in_arrear" => BulkWithFiltersBillingMode.InArrear,
            _ => (BulkWithFiltersBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkWithFiltersBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BulkWithFiltersBillingMode.InAdvance => "in_advance",
                BulkWithFiltersBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Configuration for bulk_with_filters pricing
/// </summary>
[JsonConverter(typeof(JsonModelConverter<BulkWithFiltersConfig, BulkWithFiltersConfigFromRaw>))]
public sealed record class BulkWithFiltersConfig : JsonModel
{
    /// <summary>
    /// Property filters to apply (all must match)
    /// </summary>
    public required IReadOnlyList<BulkWithFiltersConfigFilter> Filters
    {
        get
        {
            return JsonModel.GetNotNullClass<List<BulkWithFiltersConfigFilter>>(
                this.RawData,
                "filters"
            );
        }
        init { JsonModel.Set(this._rawData, "filters", value); }
    }

    /// <summary>
    /// Bulk tiers for rating based on total usage volume
    /// </summary>
    public required IReadOnlyList<BulkWithFiltersConfigTier> Tiers
    {
        get
        {
            return JsonModel.GetNotNullClass<List<BulkWithFiltersConfigTier>>(
                this.RawData,
                "tiers"
            );
        }
        init { JsonModel.Set(this._rawData, "tiers", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        foreach (var item in this.Filters)
        {
            item.Validate();
        }
        foreach (var item in this.Tiers)
        {
            item.Validate();
        }
    }

    public BulkWithFiltersConfig() { }

    public BulkWithFiltersConfig(BulkWithFiltersConfig bulkWithFiltersConfig)
        : base(bulkWithFiltersConfig) { }

    public BulkWithFiltersConfig(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    BulkWithFiltersConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="BulkWithFiltersConfigFromRaw.FromRawUnchecked"/>
    public static BulkWithFiltersConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class BulkWithFiltersConfigFromRaw : IFromRawJson<BulkWithFiltersConfig>
{
    /// <inheritdoc/>
    public BulkWithFiltersConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => BulkWithFiltersConfig.FromRawUnchecked(rawData);
}

/// <summary>
/// Configuration for a single property filter
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<BulkWithFiltersConfigFilter, BulkWithFiltersConfigFilterFromRaw>)
)]
public sealed record class BulkWithFiltersConfigFilter : JsonModel
{
    /// <summary>
    /// Event property key to filter on
    /// </summary>
    public required string PropertyKey
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "property_key"); }
        init { JsonModel.Set(this._rawData, "property_key", value); }
    }

    /// <summary>
    /// Event property value to match
    /// </summary>
    public required string PropertyValue
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "property_value"); }
        init { JsonModel.Set(this._rawData, "property_value", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.PropertyKey;
        _ = this.PropertyValue;
    }

    public BulkWithFiltersConfigFilter() { }

    public BulkWithFiltersConfigFilter(BulkWithFiltersConfigFilter bulkWithFiltersConfigFilter)
        : base(bulkWithFiltersConfigFilter) { }

    public BulkWithFiltersConfigFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    BulkWithFiltersConfigFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="BulkWithFiltersConfigFilterFromRaw.FromRawUnchecked"/>
    public static BulkWithFiltersConfigFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class BulkWithFiltersConfigFilterFromRaw : IFromRawJson<BulkWithFiltersConfigFilter>
{
    /// <inheritdoc/>
    public BulkWithFiltersConfigFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => BulkWithFiltersConfigFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// Configuration for a single bulk pricing tier
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<BulkWithFiltersConfigTier, BulkWithFiltersConfigTierFromRaw>)
)]
public sealed record class BulkWithFiltersConfigTier : JsonModel
{
    /// <summary>
    /// Amount per unit
    /// </summary>
    public required string UnitAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_amount"); }
        init { JsonModel.Set(this._rawData, "unit_amount", value); }
    }

    /// <summary>
    /// The lower bound for this tier
    /// </summary>
    public string? TierLowerBound
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "tier_lower_bound"); }
        init { JsonModel.Set(this._rawData, "tier_lower_bound", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.UnitAmount;
        _ = this.TierLowerBound;
    }

    public BulkWithFiltersConfigTier() { }

    public BulkWithFiltersConfigTier(BulkWithFiltersConfigTier bulkWithFiltersConfigTier)
        : base(bulkWithFiltersConfigTier) { }

    public BulkWithFiltersConfigTier(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    BulkWithFiltersConfigTier(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="BulkWithFiltersConfigTierFromRaw.FromRawUnchecked"/>
    public static BulkWithFiltersConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }

    [SetsRequiredMembers]
    public BulkWithFiltersConfigTier(string unitAmount)
        : this()
    {
        this.UnitAmount = unitAmount;
    }
}

class BulkWithFiltersConfigTierFromRaw : IFromRawJson<BulkWithFiltersConfigTier>
{
    /// <inheritdoc/>
    public BulkWithFiltersConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => BulkWithFiltersConfigTier.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(BulkWithFiltersCadenceConverter))]
public enum BulkWithFiltersCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class BulkWithFiltersCadenceConverter : JsonConverter<BulkWithFiltersCadence>
{
    public override BulkWithFiltersCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => BulkWithFiltersCadence.OneTime,
            "monthly" => BulkWithFiltersCadence.Monthly,
            "quarterly" => BulkWithFiltersCadence.Quarterly,
            "semi_annual" => BulkWithFiltersCadence.SemiAnnual,
            "annual" => BulkWithFiltersCadence.Annual,
            "custom" => BulkWithFiltersCadence.Custom,
            _ => (BulkWithFiltersCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkWithFiltersCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BulkWithFiltersCadence.OneTime => "one_time",
                BulkWithFiltersCadence.Monthly => "monthly",
                BulkWithFiltersCadence.Quarterly => "quarterly",
                BulkWithFiltersCadence.SemiAnnual => "semi_annual",
                BulkWithFiltersCadence.Annual => "annual",
                BulkWithFiltersCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        BulkWithFiltersCompositePriceFilter,
        BulkWithFiltersCompositePriceFilterFromRaw
    >)
)]
public sealed record class BulkWithFiltersCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, BulkWithFiltersCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, BulkWithFiltersCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, BulkWithFiltersCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, BulkWithFiltersCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public BulkWithFiltersCompositePriceFilter() { }

    public BulkWithFiltersCompositePriceFilter(
        BulkWithFiltersCompositePriceFilter bulkWithFiltersCompositePriceFilter
    )
        : base(bulkWithFiltersCompositePriceFilter) { }

    public BulkWithFiltersCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    BulkWithFiltersCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="BulkWithFiltersCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static BulkWithFiltersCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class BulkWithFiltersCompositePriceFilterFromRaw : IFromRawJson<BulkWithFiltersCompositePriceFilter>
{
    /// <inheritdoc/>
    public BulkWithFiltersCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => BulkWithFiltersCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(BulkWithFiltersCompositePriceFilterFieldConverter))]
public enum BulkWithFiltersCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class BulkWithFiltersCompositePriceFilterFieldConverter
    : JsonConverter<BulkWithFiltersCompositePriceFilterField>
{
    public override BulkWithFiltersCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => BulkWithFiltersCompositePriceFilterField.PriceID,
            "item_id" => BulkWithFiltersCompositePriceFilterField.ItemID,
            "price_type" => BulkWithFiltersCompositePriceFilterField.PriceType,
            "currency" => BulkWithFiltersCompositePriceFilterField.Currency,
            "pricing_unit_id" => BulkWithFiltersCompositePriceFilterField.PricingUnitID,
            _ => (BulkWithFiltersCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkWithFiltersCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BulkWithFiltersCompositePriceFilterField.PriceID => "price_id",
                BulkWithFiltersCompositePriceFilterField.ItemID => "item_id",
                BulkWithFiltersCompositePriceFilterField.PriceType => "price_type",
                BulkWithFiltersCompositePriceFilterField.Currency => "currency",
                BulkWithFiltersCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(BulkWithFiltersCompositePriceFilterOperatorConverter))]
public enum BulkWithFiltersCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class BulkWithFiltersCompositePriceFilterOperatorConverter
    : JsonConverter<BulkWithFiltersCompositePriceFilterOperator>
{
    public override BulkWithFiltersCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => BulkWithFiltersCompositePriceFilterOperator.Includes,
            "excludes" => BulkWithFiltersCompositePriceFilterOperator.Excludes,
            _ => (BulkWithFiltersCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkWithFiltersCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BulkWithFiltersCompositePriceFilterOperator.Includes => "includes",
                BulkWithFiltersCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(BulkWithFiltersConversionRateConfigConverter))]
public record class BulkWithFiltersConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public BulkWithFiltersConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public BulkWithFiltersConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public BulkWithFiltersConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of BulkWithFiltersConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of BulkWithFiltersConversionRateConfig"
            ),
        };
    }

    public static implicit operator BulkWithFiltersConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator BulkWithFiltersConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of BulkWithFiltersConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(BulkWithFiltersConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class BulkWithFiltersConversionRateConfigConverter
    : JsonConverter<BulkWithFiltersConversionRateConfig>
{
    public override BulkWithFiltersConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new BulkWithFiltersConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkWithFiltersConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(BulkWithFiltersPriceTypeConverter))]
public enum BulkWithFiltersPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class BulkWithFiltersPriceTypeConverter : JsonConverter<BulkWithFiltersPriceType>
{
    public override BulkWithFiltersPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => BulkWithFiltersPriceType.UsagePrice,
            "fixed_price" => BulkWithFiltersPriceType.FixedPrice,
            "composite_price" => BulkWithFiltersPriceType.CompositePrice,
            _ => (BulkWithFiltersPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkWithFiltersPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BulkWithFiltersPriceType.UsagePrice => "usage_price",
                BulkWithFiltersPriceType.FixedPrice => "fixed_price",
                BulkWithFiltersPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<Package, PackageFromRaw>))]
public sealed record class Package : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, PackageBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PackageBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, PackageCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PackageCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<PackageCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<PackageCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required PackageConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<PackageConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    /// <summary>
    /// Configuration for package pricing
    /// </summary>
    public required PackageConfig PackageConfig
    {
        get { return JsonModel.GetNotNullClass<PackageConfig>(this.RawData, "package_config"); }
        init { JsonModel.Set(this._rawData, "package_config", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, PackagePriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PackagePriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"package\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        this.PackageConfig.Validate();
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Package()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"package\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Package(Package package)
        : base(package) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Package(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"package\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    Package(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="PackageFromRaw.FromRawUnchecked"/>
    public static Package FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class PackageFromRaw : IFromRawJson<Package>
{
    /// <inheritdoc/>
    public Package FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        Package.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(PackageBillingModeConverter))]
public enum PackageBillingMode
{
    InAdvance,
    InArrear,
}

sealed class PackageBillingModeConverter : JsonConverter<PackageBillingMode>
{
    public override PackageBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => PackageBillingMode.InAdvance,
            "in_arrear" => PackageBillingMode.InArrear,
            _ => (PackageBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PackageBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PackageBillingMode.InAdvance => "in_advance",
                PackageBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(PackageCadenceConverter))]
public enum PackageCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class PackageCadenceConverter : JsonConverter<PackageCadence>
{
    public override PackageCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => PackageCadence.OneTime,
            "monthly" => PackageCadence.Monthly,
            "quarterly" => PackageCadence.Quarterly,
            "semi_annual" => PackageCadence.SemiAnnual,
            "annual" => PackageCadence.Annual,
            "custom" => PackageCadence.Custom,
            _ => (PackageCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PackageCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PackageCadence.OneTime => "one_time",
                PackageCadence.Monthly => "monthly",
                PackageCadence.Quarterly => "quarterly",
                PackageCadence.SemiAnnual => "semi_annual",
                PackageCadence.Annual => "annual",
                PackageCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<PackageCompositePriceFilter, PackageCompositePriceFilterFromRaw>)
)]
public sealed record class PackageCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, PackageCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PackageCompositePriceFilterField>>(
                this.RawData,
                "field"
            );
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, PackageCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PackageCompositePriceFilterOperator>>(
                this.RawData,
                "operator"
            );
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public PackageCompositePriceFilter() { }

    public PackageCompositePriceFilter(PackageCompositePriceFilter packageCompositePriceFilter)
        : base(packageCompositePriceFilter) { }

    public PackageCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    PackageCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="PackageCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static PackageCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class PackageCompositePriceFilterFromRaw : IFromRawJson<PackageCompositePriceFilter>
{
    /// <inheritdoc/>
    public PackageCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => PackageCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(PackageCompositePriceFilterFieldConverter))]
public enum PackageCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class PackageCompositePriceFilterFieldConverter
    : JsonConverter<PackageCompositePriceFilterField>
{
    public override PackageCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => PackageCompositePriceFilterField.PriceID,
            "item_id" => PackageCompositePriceFilterField.ItemID,
            "price_type" => PackageCompositePriceFilterField.PriceType,
            "currency" => PackageCompositePriceFilterField.Currency,
            "pricing_unit_id" => PackageCompositePriceFilterField.PricingUnitID,
            _ => (PackageCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PackageCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PackageCompositePriceFilterField.PriceID => "price_id",
                PackageCompositePriceFilterField.ItemID => "item_id",
                PackageCompositePriceFilterField.PriceType => "price_type",
                PackageCompositePriceFilterField.Currency => "currency",
                PackageCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(PackageCompositePriceFilterOperatorConverter))]
public enum PackageCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class PackageCompositePriceFilterOperatorConverter
    : JsonConverter<PackageCompositePriceFilterOperator>
{
    public override PackageCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => PackageCompositePriceFilterOperator.Includes,
            "excludes" => PackageCompositePriceFilterOperator.Excludes,
            _ => (PackageCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PackageCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PackageCompositePriceFilterOperator.Includes => "includes",
                PackageCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(PackageConversionRateConfigConverter))]
public record class PackageConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public PackageConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public PackageConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public PackageConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of PackageConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of PackageConversionRateConfig"
            ),
        };
    }

    public static implicit operator PackageConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator PackageConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of PackageConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(PackageConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class PackageConversionRateConfigConverter : JsonConverter<PackageConversionRateConfig>
{
    public override PackageConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new PackageConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        PackageConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(PackagePriceTypeConverter))]
public enum PackagePriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class PackagePriceTypeConverter : JsonConverter<PackagePriceType>
{
    public override PackagePriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => PackagePriceType.UsagePrice,
            "fixed_price" => PackagePriceType.FixedPrice,
            "composite_price" => PackagePriceType.CompositePrice,
            _ => (PackagePriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PackagePriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PackagePriceType.UsagePrice => "usage_price",
                PackagePriceType.FixedPrice => "fixed_price",
                PackagePriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<Matrix, MatrixFromRaw>))]
public sealed record class Matrix : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, MatrixBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, MatrixBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, MatrixCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, MatrixCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<MatrixCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<MatrixCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required MatrixConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<MatrixConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    /// <summary>
    /// Configuration for matrix pricing
    /// </summary>
    public required MatrixConfig MatrixConfig
    {
        get { return JsonModel.GetNotNullClass<MatrixConfig>(this.RawData, "matrix_config"); }
        init { JsonModel.Set(this._rawData, "matrix_config", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, MatrixPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, MatrixPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.MatrixConfig.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"matrix\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Matrix()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"matrix\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Matrix(Matrix matrix)
        : base(matrix) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Matrix(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"matrix\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    Matrix(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="MatrixFromRaw.FromRawUnchecked"/>
    public static Matrix FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class MatrixFromRaw : IFromRawJson<Matrix>
{
    /// <inheritdoc/>
    public Matrix FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        Matrix.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(MatrixBillingModeConverter))]
public enum MatrixBillingMode
{
    InAdvance,
    InArrear,
}

sealed class MatrixBillingModeConverter : JsonConverter<MatrixBillingMode>
{
    public override MatrixBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => MatrixBillingMode.InAdvance,
            "in_arrear" => MatrixBillingMode.InArrear,
            _ => (MatrixBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MatrixBillingMode.InAdvance => "in_advance",
                MatrixBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(MatrixCadenceConverter))]
public enum MatrixCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class MatrixCadenceConverter : JsonConverter<MatrixCadence>
{
    public override MatrixCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => MatrixCadence.OneTime,
            "monthly" => MatrixCadence.Monthly,
            "quarterly" => MatrixCadence.Quarterly,
            "semi_annual" => MatrixCadence.SemiAnnual,
            "annual" => MatrixCadence.Annual,
            "custom" => MatrixCadence.Custom,
            _ => (MatrixCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MatrixCadence.OneTime => "one_time",
                MatrixCadence.Monthly => "monthly",
                MatrixCadence.Quarterly => "quarterly",
                MatrixCadence.SemiAnnual => "semi_annual",
                MatrixCadence.Annual => "annual",
                MatrixCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<MatrixCompositePriceFilter, MatrixCompositePriceFilterFromRaw>)
)]
public sealed record class MatrixCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, MatrixCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, MatrixCompositePriceFilterField>>(
                this.RawData,
                "field"
            );
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, MatrixCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, MatrixCompositePriceFilterOperator>>(
                this.RawData,
                "operator"
            );
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public MatrixCompositePriceFilter() { }

    public MatrixCompositePriceFilter(MatrixCompositePriceFilter matrixCompositePriceFilter)
        : base(matrixCompositePriceFilter) { }

    public MatrixCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    MatrixCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="MatrixCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static MatrixCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class MatrixCompositePriceFilterFromRaw : IFromRawJson<MatrixCompositePriceFilter>
{
    /// <inheritdoc/>
    public MatrixCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => MatrixCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(MatrixCompositePriceFilterFieldConverter))]
public enum MatrixCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class MatrixCompositePriceFilterFieldConverter
    : JsonConverter<MatrixCompositePriceFilterField>
{
    public override MatrixCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => MatrixCompositePriceFilterField.PriceID,
            "item_id" => MatrixCompositePriceFilterField.ItemID,
            "price_type" => MatrixCompositePriceFilterField.PriceType,
            "currency" => MatrixCompositePriceFilterField.Currency,
            "pricing_unit_id" => MatrixCompositePriceFilterField.PricingUnitID,
            _ => (MatrixCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MatrixCompositePriceFilterField.PriceID => "price_id",
                MatrixCompositePriceFilterField.ItemID => "item_id",
                MatrixCompositePriceFilterField.PriceType => "price_type",
                MatrixCompositePriceFilterField.Currency => "currency",
                MatrixCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(MatrixCompositePriceFilterOperatorConverter))]
public enum MatrixCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class MatrixCompositePriceFilterOperatorConverter
    : JsonConverter<MatrixCompositePriceFilterOperator>
{
    public override MatrixCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => MatrixCompositePriceFilterOperator.Includes,
            "excludes" => MatrixCompositePriceFilterOperator.Excludes,
            _ => (MatrixCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MatrixCompositePriceFilterOperator.Includes => "includes",
                MatrixCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(MatrixConversionRateConfigConverter))]
public record class MatrixConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public MatrixConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public MatrixConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public MatrixConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of MatrixConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of MatrixConversionRateConfig"
            ),
        };
    }

    public static implicit operator MatrixConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator MatrixConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of MatrixConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(MatrixConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class MatrixConversionRateConfigConverter : JsonConverter<MatrixConversionRateConfig>
{
    public override MatrixConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new MatrixConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(MatrixPriceTypeConverter))]
public enum MatrixPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class MatrixPriceTypeConverter : JsonConverter<MatrixPriceType>
{
    public override MatrixPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => MatrixPriceType.UsagePrice,
            "fixed_price" => MatrixPriceType.FixedPrice,
            "composite_price" => MatrixPriceType.CompositePrice,
            _ => (MatrixPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MatrixPriceType.UsagePrice => "usage_price",
                MatrixPriceType.FixedPrice => "fixed_price",
                MatrixPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<ThresholdTotalAmount, ThresholdTotalAmountFromRaw>))]
public sealed record class ThresholdTotalAmount : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, ThresholdTotalAmountBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, ThresholdTotalAmountBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, ThresholdTotalAmountCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, ThresholdTotalAmountCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<ThresholdTotalAmountCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<ThresholdTotalAmountCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required ThresholdTotalAmountConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<ThresholdTotalAmountConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, ThresholdTotalAmountPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, ThresholdTotalAmountPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    /// <summary>
    /// Configuration for threshold_total_amount pricing
    /// </summary>
    public required ThresholdTotalAmountThresholdTotalAmountConfig ThresholdTotalAmountConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<ThresholdTotalAmountThresholdTotalAmountConfig>(
                this.RawData,
                "threshold_total_amount_config"
            );
        }
        init { JsonModel.Set(this._rawData, "threshold_total_amount_config", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"threshold_total_amount\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.ThresholdTotalAmountConfig.Validate();
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public ThresholdTotalAmount()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"threshold_total_amount\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public ThresholdTotalAmount(ThresholdTotalAmount thresholdTotalAmount)
        : base(thresholdTotalAmount) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public ThresholdTotalAmount(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"threshold_total_amount\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    ThresholdTotalAmount(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="ThresholdTotalAmountFromRaw.FromRawUnchecked"/>
    public static ThresholdTotalAmount FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class ThresholdTotalAmountFromRaw : IFromRawJson<ThresholdTotalAmount>
{
    /// <inheritdoc/>
    public ThresholdTotalAmount FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => ThresholdTotalAmount.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(ThresholdTotalAmountBillingModeConverter))]
public enum ThresholdTotalAmountBillingMode
{
    InAdvance,
    InArrear,
}

sealed class ThresholdTotalAmountBillingModeConverter
    : JsonConverter<ThresholdTotalAmountBillingMode>
{
    public override ThresholdTotalAmountBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => ThresholdTotalAmountBillingMode.InAdvance,
            "in_arrear" => ThresholdTotalAmountBillingMode.InArrear,
            _ => (ThresholdTotalAmountBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        ThresholdTotalAmountBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                ThresholdTotalAmountBillingMode.InAdvance => "in_advance",
                ThresholdTotalAmountBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(ThresholdTotalAmountCadenceConverter))]
public enum ThresholdTotalAmountCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class ThresholdTotalAmountCadenceConverter : JsonConverter<ThresholdTotalAmountCadence>
{
    public override ThresholdTotalAmountCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => ThresholdTotalAmountCadence.OneTime,
            "monthly" => ThresholdTotalAmountCadence.Monthly,
            "quarterly" => ThresholdTotalAmountCadence.Quarterly,
            "semi_annual" => ThresholdTotalAmountCadence.SemiAnnual,
            "annual" => ThresholdTotalAmountCadence.Annual,
            "custom" => ThresholdTotalAmountCadence.Custom,
            _ => (ThresholdTotalAmountCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        ThresholdTotalAmountCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                ThresholdTotalAmountCadence.OneTime => "one_time",
                ThresholdTotalAmountCadence.Monthly => "monthly",
                ThresholdTotalAmountCadence.Quarterly => "quarterly",
                ThresholdTotalAmountCadence.SemiAnnual => "semi_annual",
                ThresholdTotalAmountCadence.Annual => "annual",
                ThresholdTotalAmountCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        ThresholdTotalAmountCompositePriceFilter,
        ThresholdTotalAmountCompositePriceFilterFromRaw
    >)
)]
public sealed record class ThresholdTotalAmountCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, ThresholdTotalAmountCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, ThresholdTotalAmountCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, ThresholdTotalAmountCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, ThresholdTotalAmountCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public ThresholdTotalAmountCompositePriceFilter() { }

    public ThresholdTotalAmountCompositePriceFilter(
        ThresholdTotalAmountCompositePriceFilter thresholdTotalAmountCompositePriceFilter
    )
        : base(thresholdTotalAmountCompositePriceFilter) { }

    public ThresholdTotalAmountCompositePriceFilter(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    ThresholdTotalAmountCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="ThresholdTotalAmountCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static ThresholdTotalAmountCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class ThresholdTotalAmountCompositePriceFilterFromRaw
    : IFromRawJson<ThresholdTotalAmountCompositePriceFilter>
{
    /// <inheritdoc/>
    public ThresholdTotalAmountCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => ThresholdTotalAmountCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(ThresholdTotalAmountCompositePriceFilterFieldConverter))]
public enum ThresholdTotalAmountCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class ThresholdTotalAmountCompositePriceFilterFieldConverter
    : JsonConverter<ThresholdTotalAmountCompositePriceFilterField>
{
    public override ThresholdTotalAmountCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => ThresholdTotalAmountCompositePriceFilterField.PriceID,
            "item_id" => ThresholdTotalAmountCompositePriceFilterField.ItemID,
            "price_type" => ThresholdTotalAmountCompositePriceFilterField.PriceType,
            "currency" => ThresholdTotalAmountCompositePriceFilterField.Currency,
            "pricing_unit_id" => ThresholdTotalAmountCompositePriceFilterField.PricingUnitID,
            _ => (ThresholdTotalAmountCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        ThresholdTotalAmountCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                ThresholdTotalAmountCompositePriceFilterField.PriceID => "price_id",
                ThresholdTotalAmountCompositePriceFilterField.ItemID => "item_id",
                ThresholdTotalAmountCompositePriceFilterField.PriceType => "price_type",
                ThresholdTotalAmountCompositePriceFilterField.Currency => "currency",
                ThresholdTotalAmountCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(ThresholdTotalAmountCompositePriceFilterOperatorConverter))]
public enum ThresholdTotalAmountCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class ThresholdTotalAmountCompositePriceFilterOperatorConverter
    : JsonConverter<ThresholdTotalAmountCompositePriceFilterOperator>
{
    public override ThresholdTotalAmountCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => ThresholdTotalAmountCompositePriceFilterOperator.Includes,
            "excludes" => ThresholdTotalAmountCompositePriceFilterOperator.Excludes,
            _ => (ThresholdTotalAmountCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        ThresholdTotalAmountCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                ThresholdTotalAmountCompositePriceFilterOperator.Includes => "includes",
                ThresholdTotalAmountCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(ThresholdTotalAmountConversionRateConfigConverter))]
public record class ThresholdTotalAmountConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public ThresholdTotalAmountConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public ThresholdTotalAmountConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public ThresholdTotalAmountConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of ThresholdTotalAmountConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of ThresholdTotalAmountConversionRateConfig"
            ),
        };
    }

    public static implicit operator ThresholdTotalAmountConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator ThresholdTotalAmountConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of ThresholdTotalAmountConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(ThresholdTotalAmountConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class ThresholdTotalAmountConversionRateConfigConverter
    : JsonConverter<ThresholdTotalAmountConversionRateConfig>
{
    public override ThresholdTotalAmountConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new ThresholdTotalAmountConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        ThresholdTotalAmountConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(ThresholdTotalAmountPriceTypeConverter))]
public enum ThresholdTotalAmountPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class ThresholdTotalAmountPriceTypeConverter : JsonConverter<ThresholdTotalAmountPriceType>
{
    public override ThresholdTotalAmountPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => ThresholdTotalAmountPriceType.UsagePrice,
            "fixed_price" => ThresholdTotalAmountPriceType.FixedPrice,
            "composite_price" => ThresholdTotalAmountPriceType.CompositePrice,
            _ => (ThresholdTotalAmountPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        ThresholdTotalAmountPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                ThresholdTotalAmountPriceType.UsagePrice => "usage_price",
                ThresholdTotalAmountPriceType.FixedPrice => "fixed_price",
                ThresholdTotalAmountPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Configuration for threshold_total_amount pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        ThresholdTotalAmountThresholdTotalAmountConfig,
        ThresholdTotalAmountThresholdTotalAmountConfigFromRaw
    >)
)]
public sealed record class ThresholdTotalAmountThresholdTotalAmountConfig : JsonModel
{
    /// <summary>
    /// When the quantity consumed passes a provided threshold, the configured total
    /// will be charged
    /// </summary>
    public required IReadOnlyList<ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTable> ConsumptionTable
    {
        get
        {
            return JsonModel.GetNotNullClass<
                List<ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTable>
            >(this.RawData, "consumption_table");
        }
        init { JsonModel.Set(this._rawData, "consumption_table", value); }
    }

    /// <summary>
    /// If true, the unit price will be prorated to the billing period
    /// </summary>
    public bool? Prorate
    {
        get { return JsonModel.GetNullableStruct<bool>(this.RawData, "prorate"); }
        init { JsonModel.Set(this._rawData, "prorate", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        foreach (var item in this.ConsumptionTable)
        {
            item.Validate();
        }
        _ = this.Prorate;
    }

    public ThresholdTotalAmountThresholdTotalAmountConfig() { }

    public ThresholdTotalAmountThresholdTotalAmountConfig(
        ThresholdTotalAmountThresholdTotalAmountConfig thresholdTotalAmountThresholdTotalAmountConfig
    )
        : base(thresholdTotalAmountThresholdTotalAmountConfig) { }

    public ThresholdTotalAmountThresholdTotalAmountConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    ThresholdTotalAmountThresholdTotalAmountConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="ThresholdTotalAmountThresholdTotalAmountConfigFromRaw.FromRawUnchecked"/>
    public static ThresholdTotalAmountThresholdTotalAmountConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }

    [SetsRequiredMembers]
    public ThresholdTotalAmountThresholdTotalAmountConfig(
        List<ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTable> consumptionTable
    )
        : this()
    {
        this.ConsumptionTable = consumptionTable;
    }
}

class ThresholdTotalAmountThresholdTotalAmountConfigFromRaw
    : IFromRawJson<ThresholdTotalAmountThresholdTotalAmountConfig>
{
    /// <inheritdoc/>
    public ThresholdTotalAmountThresholdTotalAmountConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => ThresholdTotalAmountThresholdTotalAmountConfig.FromRawUnchecked(rawData);
}

/// <summary>
/// Configuration for a single threshold
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTable,
        ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTableFromRaw
    >)
)]
public sealed record class ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTable
    : JsonModel
{
    /// <summary>
    /// Quantity threshold
    /// </summary>
    public required string Threshold
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "threshold"); }
        init { JsonModel.Set(this._rawData, "threshold", value); }
    }

    /// <summary>
    /// Total amount for this threshold
    /// </summary>
    public required string TotalAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "total_amount"); }
        init { JsonModel.Set(this._rawData, "total_amount", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.Threshold;
        _ = this.TotalAmount;
    }

    public ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTable() { }

    public ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTable(
        ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTable thresholdTotalAmountThresholdTotalAmountConfigConsumptionTable
    )
        : base(thresholdTotalAmountThresholdTotalAmountConfigConsumptionTable) { }

    public ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTable(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTable(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTableFromRaw.FromRawUnchecked"/>
    public static ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTable FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTableFromRaw
    : IFromRawJson<ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTable>
{
    /// <inheritdoc/>
    public ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTable FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => ThresholdTotalAmountThresholdTotalAmountConfigConsumptionTable.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(JsonModelConverter<TieredPackage, TieredPackageFromRaw>))]
public sealed record class TieredPackage : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, TieredPackageBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredPackageBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, TieredPackageCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredPackageCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<TieredPackageCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<TieredPackageCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required TieredPackageConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<TieredPackageConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, TieredPackagePriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredPackagePriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    /// <summary>
    /// Configuration for tiered_package pricing
    /// </summary>
    public required TieredPackageTieredPackageConfig TieredPackageConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<TieredPackageTieredPackageConfig>(
                this.RawData,
                "tiered_package_config"
            );
        }
        init { JsonModel.Set(this._rawData, "tiered_package_config", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"tiered_package\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.TieredPackageConfig.Validate();
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public TieredPackage()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"tiered_package\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public TieredPackage(TieredPackage tieredPackage)
        : base(tieredPackage) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public TieredPackage(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"tiered_package\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    TieredPackage(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredPackageFromRaw.FromRawUnchecked"/>
    public static TieredPackage FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredPackageFromRaw : IFromRawJson<TieredPackage>
{
    /// <inheritdoc/>
    public TieredPackage FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        TieredPackage.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(TieredPackageBillingModeConverter))]
public enum TieredPackageBillingMode
{
    InAdvance,
    InArrear,
}

sealed class TieredPackageBillingModeConverter : JsonConverter<TieredPackageBillingMode>
{
    public override TieredPackageBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => TieredPackageBillingMode.InAdvance,
            "in_arrear" => TieredPackageBillingMode.InArrear,
            _ => (TieredPackageBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredPackageBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredPackageBillingMode.InAdvance => "in_advance",
                TieredPackageBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(TieredPackageCadenceConverter))]
public enum TieredPackageCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class TieredPackageCadenceConverter : JsonConverter<TieredPackageCadence>
{
    public override TieredPackageCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => TieredPackageCadence.OneTime,
            "monthly" => TieredPackageCadence.Monthly,
            "quarterly" => TieredPackageCadence.Quarterly,
            "semi_annual" => TieredPackageCadence.SemiAnnual,
            "annual" => TieredPackageCadence.Annual,
            "custom" => TieredPackageCadence.Custom,
            _ => (TieredPackageCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredPackageCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredPackageCadence.OneTime => "one_time",
                TieredPackageCadence.Monthly => "monthly",
                TieredPackageCadence.Quarterly => "quarterly",
                TieredPackageCadence.SemiAnnual => "semi_annual",
                TieredPackageCadence.Annual => "annual",
                TieredPackageCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        TieredPackageCompositePriceFilter,
        TieredPackageCompositePriceFilterFromRaw
    >)
)]
public sealed record class TieredPackageCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, TieredPackageCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, TieredPackageCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, TieredPackageCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, TieredPackageCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public TieredPackageCompositePriceFilter() { }

    public TieredPackageCompositePriceFilter(
        TieredPackageCompositePriceFilter tieredPackageCompositePriceFilter
    )
        : base(tieredPackageCompositePriceFilter) { }

    public TieredPackageCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    TieredPackageCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredPackageCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static TieredPackageCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredPackageCompositePriceFilterFromRaw : IFromRawJson<TieredPackageCompositePriceFilter>
{
    /// <inheritdoc/>
    public TieredPackageCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => TieredPackageCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(TieredPackageCompositePriceFilterFieldConverter))]
public enum TieredPackageCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class TieredPackageCompositePriceFilterFieldConverter
    : JsonConverter<TieredPackageCompositePriceFilterField>
{
    public override TieredPackageCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => TieredPackageCompositePriceFilterField.PriceID,
            "item_id" => TieredPackageCompositePriceFilterField.ItemID,
            "price_type" => TieredPackageCompositePriceFilterField.PriceType,
            "currency" => TieredPackageCompositePriceFilterField.Currency,
            "pricing_unit_id" => TieredPackageCompositePriceFilterField.PricingUnitID,
            _ => (TieredPackageCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredPackageCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredPackageCompositePriceFilterField.PriceID => "price_id",
                TieredPackageCompositePriceFilterField.ItemID => "item_id",
                TieredPackageCompositePriceFilterField.PriceType => "price_type",
                TieredPackageCompositePriceFilterField.Currency => "currency",
                TieredPackageCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(TieredPackageCompositePriceFilterOperatorConverter))]
public enum TieredPackageCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class TieredPackageCompositePriceFilterOperatorConverter
    : JsonConverter<TieredPackageCompositePriceFilterOperator>
{
    public override TieredPackageCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => TieredPackageCompositePriceFilterOperator.Includes,
            "excludes" => TieredPackageCompositePriceFilterOperator.Excludes,
            _ => (TieredPackageCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredPackageCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredPackageCompositePriceFilterOperator.Includes => "includes",
                TieredPackageCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(TieredPackageConversionRateConfigConverter))]
public record class TieredPackageConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public TieredPackageConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public TieredPackageConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public TieredPackageConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of TieredPackageConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of TieredPackageConversionRateConfig"
            ),
        };
    }

    public static implicit operator TieredPackageConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator TieredPackageConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of TieredPackageConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(TieredPackageConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class TieredPackageConversionRateConfigConverter
    : JsonConverter<TieredPackageConversionRateConfig>
{
    public override TieredPackageConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new TieredPackageConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredPackageConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(TieredPackagePriceTypeConverter))]
public enum TieredPackagePriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class TieredPackagePriceTypeConverter : JsonConverter<TieredPackagePriceType>
{
    public override TieredPackagePriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => TieredPackagePriceType.UsagePrice,
            "fixed_price" => TieredPackagePriceType.FixedPrice,
            "composite_price" => TieredPackagePriceType.CompositePrice,
            _ => (TieredPackagePriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredPackagePriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredPackagePriceType.UsagePrice => "usage_price",
                TieredPackagePriceType.FixedPrice => "fixed_price",
                TieredPackagePriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Configuration for tiered_package pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        TieredPackageTieredPackageConfig,
        TieredPackageTieredPackageConfigFromRaw
    >)
)]
public sealed record class TieredPackageTieredPackageConfig : JsonModel
{
    /// <summary>
    /// Package size
    /// </summary>
    public required string PackageSize
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "package_size"); }
        init { JsonModel.Set(this._rawData, "package_size", value); }
    }

    /// <summary>
    /// Apply tiered pricing after rounding up the quantity to the package size.
    /// Tiers are defined using exclusive lower bounds. The tier bounds are defined
    /// based on the total quantity rather than the number of packages, so they must
    /// be multiples of the package size.
    /// </summary>
    public required IReadOnlyList<TieredPackageTieredPackageConfigTier> Tiers
    {
        get
        {
            return JsonModel.GetNotNullClass<List<TieredPackageTieredPackageConfigTier>>(
                this.RawData,
                "tiers"
            );
        }
        init { JsonModel.Set(this._rawData, "tiers", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.PackageSize;
        foreach (var item in this.Tiers)
        {
            item.Validate();
        }
    }

    public TieredPackageTieredPackageConfig() { }

    public TieredPackageTieredPackageConfig(
        TieredPackageTieredPackageConfig tieredPackageTieredPackageConfig
    )
        : base(tieredPackageTieredPackageConfig) { }

    public TieredPackageTieredPackageConfig(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    TieredPackageTieredPackageConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredPackageTieredPackageConfigFromRaw.FromRawUnchecked"/>
    public static TieredPackageTieredPackageConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredPackageTieredPackageConfigFromRaw : IFromRawJson<TieredPackageTieredPackageConfig>
{
    /// <inheritdoc/>
    public TieredPackageTieredPackageConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => TieredPackageTieredPackageConfig.FromRawUnchecked(rawData);
}

/// <summary>
/// Configuration for a single tier with business logic
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        TieredPackageTieredPackageConfigTier,
        TieredPackageTieredPackageConfigTierFromRaw
    >)
)]
public sealed record class TieredPackageTieredPackageConfigTier : JsonModel
{
    /// <summary>
    /// Price per package
    /// </summary>
    public required string PerUnit
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "per_unit"); }
        init { JsonModel.Set(this._rawData, "per_unit", value); }
    }

    /// <summary>
    /// Tier lower bound
    /// </summary>
    public required string TierLowerBound
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "tier_lower_bound"); }
        init { JsonModel.Set(this._rawData, "tier_lower_bound", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.PerUnit;
        _ = this.TierLowerBound;
    }

    public TieredPackageTieredPackageConfigTier() { }

    public TieredPackageTieredPackageConfigTier(
        TieredPackageTieredPackageConfigTier tieredPackageTieredPackageConfigTier
    )
        : base(tieredPackageTieredPackageConfigTier) { }

    public TieredPackageTieredPackageConfigTier(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    TieredPackageTieredPackageConfigTier(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredPackageTieredPackageConfigTierFromRaw.FromRawUnchecked"/>
    public static TieredPackageTieredPackageConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredPackageTieredPackageConfigTierFromRaw
    : IFromRawJson<TieredPackageTieredPackageConfigTier>
{
    /// <inheritdoc/>
    public TieredPackageTieredPackageConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => TieredPackageTieredPackageConfigTier.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(JsonModelConverter<TieredWithMinimum, TieredWithMinimumFromRaw>))]
public sealed record class TieredWithMinimum : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, TieredWithMinimumBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredWithMinimumBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, TieredWithMinimumCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredWithMinimumCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<TieredWithMinimumCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<TieredWithMinimumCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required TieredWithMinimumConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<TieredWithMinimumConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, TieredWithMinimumPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredWithMinimumPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    /// <summary>
    /// Configuration for tiered_with_minimum pricing
    /// </summary>
    public required TieredWithMinimumTieredWithMinimumConfig TieredWithMinimumConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<TieredWithMinimumTieredWithMinimumConfig>(
                this.RawData,
                "tiered_with_minimum_config"
            );
        }
        init { JsonModel.Set(this._rawData, "tiered_with_minimum_config", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"tiered_with_minimum\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.TieredWithMinimumConfig.Validate();
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public TieredWithMinimum()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"tiered_with_minimum\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public TieredWithMinimum(TieredWithMinimum tieredWithMinimum)
        : base(tieredWithMinimum) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public TieredWithMinimum(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"tiered_with_minimum\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    TieredWithMinimum(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredWithMinimumFromRaw.FromRawUnchecked"/>
    public static TieredWithMinimum FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredWithMinimumFromRaw : IFromRawJson<TieredWithMinimum>
{
    /// <inheritdoc/>
    public TieredWithMinimum FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        TieredWithMinimum.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(TieredWithMinimumBillingModeConverter))]
public enum TieredWithMinimumBillingMode
{
    InAdvance,
    InArrear,
}

sealed class TieredWithMinimumBillingModeConverter : JsonConverter<TieredWithMinimumBillingMode>
{
    public override TieredWithMinimumBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => TieredWithMinimumBillingMode.InAdvance,
            "in_arrear" => TieredWithMinimumBillingMode.InArrear,
            _ => (TieredWithMinimumBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredWithMinimumBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredWithMinimumBillingMode.InAdvance => "in_advance",
                TieredWithMinimumBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(TieredWithMinimumCadenceConverter))]
public enum TieredWithMinimumCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class TieredWithMinimumCadenceConverter : JsonConverter<TieredWithMinimumCadence>
{
    public override TieredWithMinimumCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => TieredWithMinimumCadence.OneTime,
            "monthly" => TieredWithMinimumCadence.Monthly,
            "quarterly" => TieredWithMinimumCadence.Quarterly,
            "semi_annual" => TieredWithMinimumCadence.SemiAnnual,
            "annual" => TieredWithMinimumCadence.Annual,
            "custom" => TieredWithMinimumCadence.Custom,
            _ => (TieredWithMinimumCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredWithMinimumCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredWithMinimumCadence.OneTime => "one_time",
                TieredWithMinimumCadence.Monthly => "monthly",
                TieredWithMinimumCadence.Quarterly => "quarterly",
                TieredWithMinimumCadence.SemiAnnual => "semi_annual",
                TieredWithMinimumCadence.Annual => "annual",
                TieredWithMinimumCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        TieredWithMinimumCompositePriceFilter,
        TieredWithMinimumCompositePriceFilterFromRaw
    >)
)]
public sealed record class TieredWithMinimumCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, TieredWithMinimumCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, TieredWithMinimumCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, TieredWithMinimumCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, TieredWithMinimumCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public TieredWithMinimumCompositePriceFilter() { }

    public TieredWithMinimumCompositePriceFilter(
        TieredWithMinimumCompositePriceFilter tieredWithMinimumCompositePriceFilter
    )
        : base(tieredWithMinimumCompositePriceFilter) { }

    public TieredWithMinimumCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    TieredWithMinimumCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredWithMinimumCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static TieredWithMinimumCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredWithMinimumCompositePriceFilterFromRaw
    : IFromRawJson<TieredWithMinimumCompositePriceFilter>
{
    /// <inheritdoc/>
    public TieredWithMinimumCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => TieredWithMinimumCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(TieredWithMinimumCompositePriceFilterFieldConverter))]
public enum TieredWithMinimumCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class TieredWithMinimumCompositePriceFilterFieldConverter
    : JsonConverter<TieredWithMinimumCompositePriceFilterField>
{
    public override TieredWithMinimumCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => TieredWithMinimumCompositePriceFilterField.PriceID,
            "item_id" => TieredWithMinimumCompositePriceFilterField.ItemID,
            "price_type" => TieredWithMinimumCompositePriceFilterField.PriceType,
            "currency" => TieredWithMinimumCompositePriceFilterField.Currency,
            "pricing_unit_id" => TieredWithMinimumCompositePriceFilterField.PricingUnitID,
            _ => (TieredWithMinimumCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredWithMinimumCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredWithMinimumCompositePriceFilterField.PriceID => "price_id",
                TieredWithMinimumCompositePriceFilterField.ItemID => "item_id",
                TieredWithMinimumCompositePriceFilterField.PriceType => "price_type",
                TieredWithMinimumCompositePriceFilterField.Currency => "currency",
                TieredWithMinimumCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(TieredWithMinimumCompositePriceFilterOperatorConverter))]
public enum TieredWithMinimumCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class TieredWithMinimumCompositePriceFilterOperatorConverter
    : JsonConverter<TieredWithMinimumCompositePriceFilterOperator>
{
    public override TieredWithMinimumCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => TieredWithMinimumCompositePriceFilterOperator.Includes,
            "excludes" => TieredWithMinimumCompositePriceFilterOperator.Excludes,
            _ => (TieredWithMinimumCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredWithMinimumCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredWithMinimumCompositePriceFilterOperator.Includes => "includes",
                TieredWithMinimumCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(TieredWithMinimumConversionRateConfigConverter))]
public record class TieredWithMinimumConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public TieredWithMinimumConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public TieredWithMinimumConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public TieredWithMinimumConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of TieredWithMinimumConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of TieredWithMinimumConversionRateConfig"
            ),
        };
    }

    public static implicit operator TieredWithMinimumConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator TieredWithMinimumConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of TieredWithMinimumConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(TieredWithMinimumConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class TieredWithMinimumConversionRateConfigConverter
    : JsonConverter<TieredWithMinimumConversionRateConfig>
{
    public override TieredWithMinimumConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new TieredWithMinimumConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredWithMinimumConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(TieredWithMinimumPriceTypeConverter))]
public enum TieredWithMinimumPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class TieredWithMinimumPriceTypeConverter : JsonConverter<TieredWithMinimumPriceType>
{
    public override TieredWithMinimumPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => TieredWithMinimumPriceType.UsagePrice,
            "fixed_price" => TieredWithMinimumPriceType.FixedPrice,
            "composite_price" => TieredWithMinimumPriceType.CompositePrice,
            _ => (TieredWithMinimumPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredWithMinimumPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredWithMinimumPriceType.UsagePrice => "usage_price",
                TieredWithMinimumPriceType.FixedPrice => "fixed_price",
                TieredWithMinimumPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Configuration for tiered_with_minimum pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        TieredWithMinimumTieredWithMinimumConfig,
        TieredWithMinimumTieredWithMinimumConfigFromRaw
    >)
)]
public sealed record class TieredWithMinimumTieredWithMinimumConfig : JsonModel
{
    /// <summary>
    /// Tiered pricing with a minimum amount dependent on the volume tier. Tiers
    /// are defined using exclusive lower bounds.
    /// </summary>
    public required IReadOnlyList<TieredWithMinimumTieredWithMinimumConfigTier> Tiers
    {
        get
        {
            return JsonModel.GetNotNullClass<List<TieredWithMinimumTieredWithMinimumConfigTier>>(
                this.RawData,
                "tiers"
            );
        }
        init { JsonModel.Set(this._rawData, "tiers", value); }
    }

    /// <summary>
    /// If true, tiers with an accrued amount of 0 will not be included in the rating.
    /// </summary>
    public bool? HideZeroAmountTiers
    {
        get { return JsonModel.GetNullableStruct<bool>(this.RawData, "hide_zero_amount_tiers"); }
        init
        {
            if (value == null)
            {
                return;
            }

            JsonModel.Set(this._rawData, "hide_zero_amount_tiers", value);
        }
    }

    /// <summary>
    /// If true, the unit price will be prorated to the billing period
    /// </summary>
    public bool? Prorate
    {
        get { return JsonModel.GetNullableStruct<bool>(this.RawData, "prorate"); }
        init
        {
            if (value == null)
            {
                return;
            }

            JsonModel.Set(this._rawData, "prorate", value);
        }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        foreach (var item in this.Tiers)
        {
            item.Validate();
        }
        _ = this.HideZeroAmountTiers;
        _ = this.Prorate;
    }

    public TieredWithMinimumTieredWithMinimumConfig() { }

    public TieredWithMinimumTieredWithMinimumConfig(
        TieredWithMinimumTieredWithMinimumConfig tieredWithMinimumTieredWithMinimumConfig
    )
        : base(tieredWithMinimumTieredWithMinimumConfig) { }

    public TieredWithMinimumTieredWithMinimumConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    TieredWithMinimumTieredWithMinimumConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredWithMinimumTieredWithMinimumConfigFromRaw.FromRawUnchecked"/>
    public static TieredWithMinimumTieredWithMinimumConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }

    [SetsRequiredMembers]
    public TieredWithMinimumTieredWithMinimumConfig(
        List<TieredWithMinimumTieredWithMinimumConfigTier> tiers
    )
        : this()
    {
        this.Tiers = tiers;
    }
}

class TieredWithMinimumTieredWithMinimumConfigFromRaw
    : IFromRawJson<TieredWithMinimumTieredWithMinimumConfig>
{
    /// <inheritdoc/>
    public TieredWithMinimumTieredWithMinimumConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => TieredWithMinimumTieredWithMinimumConfig.FromRawUnchecked(rawData);
}

/// <summary>
/// Configuration for a single tier
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        TieredWithMinimumTieredWithMinimumConfigTier,
        TieredWithMinimumTieredWithMinimumConfigTierFromRaw
    >)
)]
public sealed record class TieredWithMinimumTieredWithMinimumConfigTier : JsonModel
{
    /// <summary>
    /// Minimum amount
    /// </summary>
    public required string MinimumAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// Tier lower bound
    /// </summary>
    public required string TierLowerBound
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "tier_lower_bound"); }
        init { JsonModel.Set(this._rawData, "tier_lower_bound", value); }
    }

    /// <summary>
    /// Per unit amount
    /// </summary>
    public required string UnitAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_amount"); }
        init { JsonModel.Set(this._rawData, "unit_amount", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.MinimumAmount;
        _ = this.TierLowerBound;
        _ = this.UnitAmount;
    }

    public TieredWithMinimumTieredWithMinimumConfigTier() { }

    public TieredWithMinimumTieredWithMinimumConfigTier(
        TieredWithMinimumTieredWithMinimumConfigTier tieredWithMinimumTieredWithMinimumConfigTier
    )
        : base(tieredWithMinimumTieredWithMinimumConfigTier) { }

    public TieredWithMinimumTieredWithMinimumConfigTier(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    TieredWithMinimumTieredWithMinimumConfigTier(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredWithMinimumTieredWithMinimumConfigTierFromRaw.FromRawUnchecked"/>
    public static TieredWithMinimumTieredWithMinimumConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredWithMinimumTieredWithMinimumConfigTierFromRaw
    : IFromRawJson<TieredWithMinimumTieredWithMinimumConfigTier>
{
    /// <inheritdoc/>
    public TieredWithMinimumTieredWithMinimumConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => TieredWithMinimumTieredWithMinimumConfigTier.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(JsonModelConverter<GroupedTiered, GroupedTieredFromRaw>))]
public sealed record class GroupedTiered : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, GroupedTieredBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedTieredBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, GroupedTieredCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedTieredCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<GroupedTieredCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<GroupedTieredCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required GroupedTieredConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<GroupedTieredConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    /// <summary>
    /// Configuration for grouped_tiered pricing
    /// </summary>
    public required GroupedTieredGroupedTieredConfig GroupedTieredConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<GroupedTieredGroupedTieredConfig>(
                this.RawData,
                "grouped_tiered_config"
            );
        }
        init { JsonModel.Set(this._rawData, "grouped_tiered_config", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, GroupedTieredPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedTieredPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.GroupedTieredConfig.Validate();
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"grouped_tiered\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedTiered()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"grouped_tiered\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedTiered(GroupedTiered groupedTiered)
        : base(groupedTiered) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedTiered(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"grouped_tiered\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    GroupedTiered(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedTieredFromRaw.FromRawUnchecked"/>
    public static GroupedTiered FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedTieredFromRaw : IFromRawJson<GroupedTiered>
{
    /// <inheritdoc/>
    public GroupedTiered FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        GroupedTiered.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(GroupedTieredBillingModeConverter))]
public enum GroupedTieredBillingMode
{
    InAdvance,
    InArrear,
}

sealed class GroupedTieredBillingModeConverter : JsonConverter<GroupedTieredBillingMode>
{
    public override GroupedTieredBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => GroupedTieredBillingMode.InAdvance,
            "in_arrear" => GroupedTieredBillingMode.InArrear,
            _ => (GroupedTieredBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedTieredBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedTieredBillingMode.InAdvance => "in_advance",
                GroupedTieredBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(GroupedTieredCadenceConverter))]
public enum GroupedTieredCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class GroupedTieredCadenceConverter : JsonConverter<GroupedTieredCadence>
{
    public override GroupedTieredCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => GroupedTieredCadence.OneTime,
            "monthly" => GroupedTieredCadence.Monthly,
            "quarterly" => GroupedTieredCadence.Quarterly,
            "semi_annual" => GroupedTieredCadence.SemiAnnual,
            "annual" => GroupedTieredCadence.Annual,
            "custom" => GroupedTieredCadence.Custom,
            _ => (GroupedTieredCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedTieredCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedTieredCadence.OneTime => "one_time",
                GroupedTieredCadence.Monthly => "monthly",
                GroupedTieredCadence.Quarterly => "quarterly",
                GroupedTieredCadence.SemiAnnual => "semi_annual",
                GroupedTieredCadence.Annual => "annual",
                GroupedTieredCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        GroupedTieredCompositePriceFilter,
        GroupedTieredCompositePriceFilterFromRaw
    >)
)]
public sealed record class GroupedTieredCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, GroupedTieredCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, GroupedTieredCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, GroupedTieredCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, GroupedTieredCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public GroupedTieredCompositePriceFilter() { }

    public GroupedTieredCompositePriceFilter(
        GroupedTieredCompositePriceFilter groupedTieredCompositePriceFilter
    )
        : base(groupedTieredCompositePriceFilter) { }

    public GroupedTieredCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedTieredCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedTieredCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static GroupedTieredCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedTieredCompositePriceFilterFromRaw : IFromRawJson<GroupedTieredCompositePriceFilter>
{
    /// <inheritdoc/>
    public GroupedTieredCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedTieredCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(GroupedTieredCompositePriceFilterFieldConverter))]
public enum GroupedTieredCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class GroupedTieredCompositePriceFilterFieldConverter
    : JsonConverter<GroupedTieredCompositePriceFilterField>
{
    public override GroupedTieredCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => GroupedTieredCompositePriceFilterField.PriceID,
            "item_id" => GroupedTieredCompositePriceFilterField.ItemID,
            "price_type" => GroupedTieredCompositePriceFilterField.PriceType,
            "currency" => GroupedTieredCompositePriceFilterField.Currency,
            "pricing_unit_id" => GroupedTieredCompositePriceFilterField.PricingUnitID,
            _ => (GroupedTieredCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedTieredCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedTieredCompositePriceFilterField.PriceID => "price_id",
                GroupedTieredCompositePriceFilterField.ItemID => "item_id",
                GroupedTieredCompositePriceFilterField.PriceType => "price_type",
                GroupedTieredCompositePriceFilterField.Currency => "currency",
                GroupedTieredCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(GroupedTieredCompositePriceFilterOperatorConverter))]
public enum GroupedTieredCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class GroupedTieredCompositePriceFilterOperatorConverter
    : JsonConverter<GroupedTieredCompositePriceFilterOperator>
{
    public override GroupedTieredCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => GroupedTieredCompositePriceFilterOperator.Includes,
            "excludes" => GroupedTieredCompositePriceFilterOperator.Excludes,
            _ => (GroupedTieredCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedTieredCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedTieredCompositePriceFilterOperator.Includes => "includes",
                GroupedTieredCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(GroupedTieredConversionRateConfigConverter))]
public record class GroupedTieredConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public GroupedTieredConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public GroupedTieredConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public GroupedTieredConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of GroupedTieredConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of GroupedTieredConversionRateConfig"
            ),
        };
    }

    public static implicit operator GroupedTieredConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator GroupedTieredConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of GroupedTieredConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(GroupedTieredConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class GroupedTieredConversionRateConfigConverter
    : JsonConverter<GroupedTieredConversionRateConfig>
{
    public override GroupedTieredConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new GroupedTieredConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedTieredConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

/// <summary>
/// Configuration for grouped_tiered pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        GroupedTieredGroupedTieredConfig,
        GroupedTieredGroupedTieredConfigFromRaw
    >)
)]
public sealed record class GroupedTieredGroupedTieredConfig : JsonModel
{
    /// <summary>
    /// The billable metric property used to group before tiering
    /// </summary>
    public required string GroupingKey
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "grouping_key"); }
        init { JsonModel.Set(this._rawData, "grouping_key", value); }
    }

    /// <summary>
    /// Apply tiered pricing to each segment generated after grouping with the provided key
    /// </summary>
    public required IReadOnlyList<GroupedTieredGroupedTieredConfigTier> Tiers
    {
        get
        {
            return JsonModel.GetNotNullClass<List<GroupedTieredGroupedTieredConfigTier>>(
                this.RawData,
                "tiers"
            );
        }
        init { JsonModel.Set(this._rawData, "tiers", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.GroupingKey;
        foreach (var item in this.Tiers)
        {
            item.Validate();
        }
    }

    public GroupedTieredGroupedTieredConfig() { }

    public GroupedTieredGroupedTieredConfig(
        GroupedTieredGroupedTieredConfig groupedTieredGroupedTieredConfig
    )
        : base(groupedTieredGroupedTieredConfig) { }

    public GroupedTieredGroupedTieredConfig(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedTieredGroupedTieredConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedTieredGroupedTieredConfigFromRaw.FromRawUnchecked"/>
    public static GroupedTieredGroupedTieredConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedTieredGroupedTieredConfigFromRaw : IFromRawJson<GroupedTieredGroupedTieredConfig>
{
    /// <inheritdoc/>
    public GroupedTieredGroupedTieredConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedTieredGroupedTieredConfig.FromRawUnchecked(rawData);
}

/// <summary>
/// Configuration for a single tier
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        GroupedTieredGroupedTieredConfigTier,
        GroupedTieredGroupedTieredConfigTierFromRaw
    >)
)]
public sealed record class GroupedTieredGroupedTieredConfigTier : JsonModel
{
    /// <summary>
    /// Tier lower bound
    /// </summary>
    public required string TierLowerBound
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "tier_lower_bound"); }
        init { JsonModel.Set(this._rawData, "tier_lower_bound", value); }
    }

    /// <summary>
    /// Per unit amount
    /// </summary>
    public required string UnitAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_amount"); }
        init { JsonModel.Set(this._rawData, "unit_amount", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.TierLowerBound;
        _ = this.UnitAmount;
    }

    public GroupedTieredGroupedTieredConfigTier() { }

    public GroupedTieredGroupedTieredConfigTier(
        GroupedTieredGroupedTieredConfigTier groupedTieredGroupedTieredConfigTier
    )
        : base(groupedTieredGroupedTieredConfigTier) { }

    public GroupedTieredGroupedTieredConfigTier(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedTieredGroupedTieredConfigTier(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedTieredGroupedTieredConfigTierFromRaw.FromRawUnchecked"/>
    public static GroupedTieredGroupedTieredConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedTieredGroupedTieredConfigTierFromRaw
    : IFromRawJson<GroupedTieredGroupedTieredConfigTier>
{
    /// <inheritdoc/>
    public GroupedTieredGroupedTieredConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedTieredGroupedTieredConfigTier.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(GroupedTieredPriceTypeConverter))]
public enum GroupedTieredPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class GroupedTieredPriceTypeConverter : JsonConverter<GroupedTieredPriceType>
{
    public override GroupedTieredPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => GroupedTieredPriceType.UsagePrice,
            "fixed_price" => GroupedTieredPriceType.FixedPrice,
            "composite_price" => GroupedTieredPriceType.CompositePrice,
            _ => (GroupedTieredPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedTieredPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedTieredPriceType.UsagePrice => "usage_price",
                GroupedTieredPriceType.FixedPrice => "fixed_price",
                GroupedTieredPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<TieredPackageWithMinimum, TieredPackageWithMinimumFromRaw>)
)]
public sealed record class TieredPackageWithMinimum : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, TieredPackageWithMinimumBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredPackageWithMinimumBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, TieredPackageWithMinimumCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredPackageWithMinimumCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<TieredPackageWithMinimumCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<TieredPackageWithMinimumCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required TieredPackageWithMinimumConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<TieredPackageWithMinimumConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, TieredPackageWithMinimumPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredPackageWithMinimumPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    /// <summary>
    /// Configuration for tiered_package_with_minimum pricing
    /// </summary>
    public required TieredPackageWithMinimumTieredPackageWithMinimumConfig TieredPackageWithMinimumConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<TieredPackageWithMinimumTieredPackageWithMinimumConfig>(
                this.RawData,
                "tiered_package_with_minimum_config"
            );
        }
        init { JsonModel.Set(this._rawData, "tiered_package_with_minimum_config", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"tiered_package_with_minimum\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.TieredPackageWithMinimumConfig.Validate();
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public TieredPackageWithMinimum()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"tiered_package_with_minimum\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public TieredPackageWithMinimum(TieredPackageWithMinimum tieredPackageWithMinimum)
        : base(tieredPackageWithMinimum) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public TieredPackageWithMinimum(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"tiered_package_with_minimum\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    TieredPackageWithMinimum(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredPackageWithMinimumFromRaw.FromRawUnchecked"/>
    public static TieredPackageWithMinimum FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredPackageWithMinimumFromRaw : IFromRawJson<TieredPackageWithMinimum>
{
    /// <inheritdoc/>
    public TieredPackageWithMinimum FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => TieredPackageWithMinimum.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(TieredPackageWithMinimumBillingModeConverter))]
public enum TieredPackageWithMinimumBillingMode
{
    InAdvance,
    InArrear,
}

sealed class TieredPackageWithMinimumBillingModeConverter
    : JsonConverter<TieredPackageWithMinimumBillingMode>
{
    public override TieredPackageWithMinimumBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => TieredPackageWithMinimumBillingMode.InAdvance,
            "in_arrear" => TieredPackageWithMinimumBillingMode.InArrear,
            _ => (TieredPackageWithMinimumBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredPackageWithMinimumBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredPackageWithMinimumBillingMode.InAdvance => "in_advance",
                TieredPackageWithMinimumBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(TieredPackageWithMinimumCadenceConverter))]
public enum TieredPackageWithMinimumCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class TieredPackageWithMinimumCadenceConverter
    : JsonConverter<TieredPackageWithMinimumCadence>
{
    public override TieredPackageWithMinimumCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => TieredPackageWithMinimumCadence.OneTime,
            "monthly" => TieredPackageWithMinimumCadence.Monthly,
            "quarterly" => TieredPackageWithMinimumCadence.Quarterly,
            "semi_annual" => TieredPackageWithMinimumCadence.SemiAnnual,
            "annual" => TieredPackageWithMinimumCadence.Annual,
            "custom" => TieredPackageWithMinimumCadence.Custom,
            _ => (TieredPackageWithMinimumCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredPackageWithMinimumCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredPackageWithMinimumCadence.OneTime => "one_time",
                TieredPackageWithMinimumCadence.Monthly => "monthly",
                TieredPackageWithMinimumCadence.Quarterly => "quarterly",
                TieredPackageWithMinimumCadence.SemiAnnual => "semi_annual",
                TieredPackageWithMinimumCadence.Annual => "annual",
                TieredPackageWithMinimumCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        TieredPackageWithMinimumCompositePriceFilter,
        TieredPackageWithMinimumCompositePriceFilterFromRaw
    >)
)]
public sealed record class TieredPackageWithMinimumCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, TieredPackageWithMinimumCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, TieredPackageWithMinimumCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, TieredPackageWithMinimumCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, TieredPackageWithMinimumCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public TieredPackageWithMinimumCompositePriceFilter() { }

    public TieredPackageWithMinimumCompositePriceFilter(
        TieredPackageWithMinimumCompositePriceFilter tieredPackageWithMinimumCompositePriceFilter
    )
        : base(tieredPackageWithMinimumCompositePriceFilter) { }

    public TieredPackageWithMinimumCompositePriceFilter(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    TieredPackageWithMinimumCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredPackageWithMinimumCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static TieredPackageWithMinimumCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredPackageWithMinimumCompositePriceFilterFromRaw
    : IFromRawJson<TieredPackageWithMinimumCompositePriceFilter>
{
    /// <inheritdoc/>
    public TieredPackageWithMinimumCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => TieredPackageWithMinimumCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(TieredPackageWithMinimumCompositePriceFilterFieldConverter))]
public enum TieredPackageWithMinimumCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class TieredPackageWithMinimumCompositePriceFilterFieldConverter
    : JsonConverter<TieredPackageWithMinimumCompositePriceFilterField>
{
    public override TieredPackageWithMinimumCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => TieredPackageWithMinimumCompositePriceFilterField.PriceID,
            "item_id" => TieredPackageWithMinimumCompositePriceFilterField.ItemID,
            "price_type" => TieredPackageWithMinimumCompositePriceFilterField.PriceType,
            "currency" => TieredPackageWithMinimumCompositePriceFilterField.Currency,
            "pricing_unit_id" => TieredPackageWithMinimumCompositePriceFilterField.PricingUnitID,
            _ => (TieredPackageWithMinimumCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredPackageWithMinimumCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredPackageWithMinimumCompositePriceFilterField.PriceID => "price_id",
                TieredPackageWithMinimumCompositePriceFilterField.ItemID => "item_id",
                TieredPackageWithMinimumCompositePriceFilterField.PriceType => "price_type",
                TieredPackageWithMinimumCompositePriceFilterField.Currency => "currency",
                TieredPackageWithMinimumCompositePriceFilterField.PricingUnitID =>
                    "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(TieredPackageWithMinimumCompositePriceFilterOperatorConverter))]
public enum TieredPackageWithMinimumCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class TieredPackageWithMinimumCompositePriceFilterOperatorConverter
    : JsonConverter<TieredPackageWithMinimumCompositePriceFilterOperator>
{
    public override TieredPackageWithMinimumCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => TieredPackageWithMinimumCompositePriceFilterOperator.Includes,
            "excludes" => TieredPackageWithMinimumCompositePriceFilterOperator.Excludes,
            _ => (TieredPackageWithMinimumCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredPackageWithMinimumCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredPackageWithMinimumCompositePriceFilterOperator.Includes => "includes",
                TieredPackageWithMinimumCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(TieredPackageWithMinimumConversionRateConfigConverter))]
public record class TieredPackageWithMinimumConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public TieredPackageWithMinimumConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public TieredPackageWithMinimumConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public TieredPackageWithMinimumConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of TieredPackageWithMinimumConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of TieredPackageWithMinimumConversionRateConfig"
            ),
        };
    }

    public static implicit operator TieredPackageWithMinimumConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator TieredPackageWithMinimumConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of TieredPackageWithMinimumConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(TieredPackageWithMinimumConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class TieredPackageWithMinimumConversionRateConfigConverter
    : JsonConverter<TieredPackageWithMinimumConversionRateConfig>
{
    public override TieredPackageWithMinimumConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new TieredPackageWithMinimumConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredPackageWithMinimumConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(TieredPackageWithMinimumPriceTypeConverter))]
public enum TieredPackageWithMinimumPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class TieredPackageWithMinimumPriceTypeConverter
    : JsonConverter<TieredPackageWithMinimumPriceType>
{
    public override TieredPackageWithMinimumPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => TieredPackageWithMinimumPriceType.UsagePrice,
            "fixed_price" => TieredPackageWithMinimumPriceType.FixedPrice,
            "composite_price" => TieredPackageWithMinimumPriceType.CompositePrice,
            _ => (TieredPackageWithMinimumPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredPackageWithMinimumPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredPackageWithMinimumPriceType.UsagePrice => "usage_price",
                TieredPackageWithMinimumPriceType.FixedPrice => "fixed_price",
                TieredPackageWithMinimumPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Configuration for tiered_package_with_minimum pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        TieredPackageWithMinimumTieredPackageWithMinimumConfig,
        TieredPackageWithMinimumTieredPackageWithMinimumConfigFromRaw
    >)
)]
public sealed record class TieredPackageWithMinimumTieredPackageWithMinimumConfig : JsonModel
{
    /// <summary>
    /// Package size
    /// </summary>
    public required double PackageSize
    {
        get { return JsonModel.GetNotNullStruct<double>(this.RawData, "package_size"); }
        init { JsonModel.Set(this._rawData, "package_size", value); }
    }

    /// <summary>
    /// Apply tiered pricing after rounding up the quantity to the package size.
    /// Tiers are defined using exclusive lower bounds.
    /// </summary>
    public required IReadOnlyList<TieredPackageWithMinimumTieredPackageWithMinimumConfigTier> Tiers
    {
        get
        {
            return JsonModel.GetNotNullClass<
                List<TieredPackageWithMinimumTieredPackageWithMinimumConfigTier>
            >(this.RawData, "tiers");
        }
        init { JsonModel.Set(this._rawData, "tiers", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.PackageSize;
        foreach (var item in this.Tiers)
        {
            item.Validate();
        }
    }

    public TieredPackageWithMinimumTieredPackageWithMinimumConfig() { }

    public TieredPackageWithMinimumTieredPackageWithMinimumConfig(
        TieredPackageWithMinimumTieredPackageWithMinimumConfig tieredPackageWithMinimumTieredPackageWithMinimumConfig
    )
        : base(tieredPackageWithMinimumTieredPackageWithMinimumConfig) { }

    public TieredPackageWithMinimumTieredPackageWithMinimumConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    TieredPackageWithMinimumTieredPackageWithMinimumConfig(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredPackageWithMinimumTieredPackageWithMinimumConfigFromRaw.FromRawUnchecked"/>
    public static TieredPackageWithMinimumTieredPackageWithMinimumConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredPackageWithMinimumTieredPackageWithMinimumConfigFromRaw
    : IFromRawJson<TieredPackageWithMinimumTieredPackageWithMinimumConfig>
{
    /// <inheritdoc/>
    public TieredPackageWithMinimumTieredPackageWithMinimumConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => TieredPackageWithMinimumTieredPackageWithMinimumConfig.FromRawUnchecked(rawData);
}

/// <summary>
/// Configuration for a single tier
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        TieredPackageWithMinimumTieredPackageWithMinimumConfigTier,
        TieredPackageWithMinimumTieredPackageWithMinimumConfigTierFromRaw
    >)
)]
public sealed record class TieredPackageWithMinimumTieredPackageWithMinimumConfigTier : JsonModel
{
    /// <summary>
    /// Minimum amount
    /// </summary>
    public required string MinimumAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// Price per package
    /// </summary>
    public required string PerUnit
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "per_unit"); }
        init { JsonModel.Set(this._rawData, "per_unit", value); }
    }

    /// <summary>
    /// Tier lower bound
    /// </summary>
    public required string TierLowerBound
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "tier_lower_bound"); }
        init { JsonModel.Set(this._rawData, "tier_lower_bound", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.MinimumAmount;
        _ = this.PerUnit;
        _ = this.TierLowerBound;
    }

    public TieredPackageWithMinimumTieredPackageWithMinimumConfigTier() { }

    public TieredPackageWithMinimumTieredPackageWithMinimumConfigTier(
        TieredPackageWithMinimumTieredPackageWithMinimumConfigTier tieredPackageWithMinimumTieredPackageWithMinimumConfigTier
    )
        : base(tieredPackageWithMinimumTieredPackageWithMinimumConfigTier) { }

    public TieredPackageWithMinimumTieredPackageWithMinimumConfigTier(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    TieredPackageWithMinimumTieredPackageWithMinimumConfigTier(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredPackageWithMinimumTieredPackageWithMinimumConfigTierFromRaw.FromRawUnchecked"/>
    public static TieredPackageWithMinimumTieredPackageWithMinimumConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredPackageWithMinimumTieredPackageWithMinimumConfigTierFromRaw
    : IFromRawJson<TieredPackageWithMinimumTieredPackageWithMinimumConfigTier>
{
    /// <inheritdoc/>
    public TieredPackageWithMinimumTieredPackageWithMinimumConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => TieredPackageWithMinimumTieredPackageWithMinimumConfigTier.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(JsonModelConverter<PackageWithAllocation, PackageWithAllocationFromRaw>))]
public sealed record class PackageWithAllocation : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, PackageWithAllocationBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PackageWithAllocationBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, PackageWithAllocationCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PackageWithAllocationCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<PackageWithAllocationCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<PackageWithAllocationCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required PackageWithAllocationConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<PackageWithAllocationConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    /// <summary>
    /// Configuration for package_with_allocation pricing
    /// </summary>
    public required PackageWithAllocationPackageWithAllocationConfig PackageWithAllocationConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<PackageWithAllocationPackageWithAllocationConfig>(
                this.RawData,
                "package_with_allocation_config"
            );
        }
        init { JsonModel.Set(this._rawData, "package_with_allocation_config", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, PackageWithAllocationPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PackageWithAllocationPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"package_with_allocation\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        this.PackageWithAllocationConfig.Validate();
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public PackageWithAllocation()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"package_with_allocation\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public PackageWithAllocation(PackageWithAllocation packageWithAllocation)
        : base(packageWithAllocation) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public PackageWithAllocation(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"package_with_allocation\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    PackageWithAllocation(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="PackageWithAllocationFromRaw.FromRawUnchecked"/>
    public static PackageWithAllocation FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class PackageWithAllocationFromRaw : IFromRawJson<PackageWithAllocation>
{
    /// <inheritdoc/>
    public PackageWithAllocation FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => PackageWithAllocation.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(PackageWithAllocationBillingModeConverter))]
public enum PackageWithAllocationBillingMode
{
    InAdvance,
    InArrear,
}

sealed class PackageWithAllocationBillingModeConverter
    : JsonConverter<PackageWithAllocationBillingMode>
{
    public override PackageWithAllocationBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => PackageWithAllocationBillingMode.InAdvance,
            "in_arrear" => PackageWithAllocationBillingMode.InArrear,
            _ => (PackageWithAllocationBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PackageWithAllocationBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PackageWithAllocationBillingMode.InAdvance => "in_advance",
                PackageWithAllocationBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(PackageWithAllocationCadenceConverter))]
public enum PackageWithAllocationCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class PackageWithAllocationCadenceConverter : JsonConverter<PackageWithAllocationCadence>
{
    public override PackageWithAllocationCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => PackageWithAllocationCadence.OneTime,
            "monthly" => PackageWithAllocationCadence.Monthly,
            "quarterly" => PackageWithAllocationCadence.Quarterly,
            "semi_annual" => PackageWithAllocationCadence.SemiAnnual,
            "annual" => PackageWithAllocationCadence.Annual,
            "custom" => PackageWithAllocationCadence.Custom,
            _ => (PackageWithAllocationCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PackageWithAllocationCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PackageWithAllocationCadence.OneTime => "one_time",
                PackageWithAllocationCadence.Monthly => "monthly",
                PackageWithAllocationCadence.Quarterly => "quarterly",
                PackageWithAllocationCadence.SemiAnnual => "semi_annual",
                PackageWithAllocationCadence.Annual => "annual",
                PackageWithAllocationCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        PackageWithAllocationCompositePriceFilter,
        PackageWithAllocationCompositePriceFilterFromRaw
    >)
)]
public sealed record class PackageWithAllocationCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, PackageWithAllocationCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, PackageWithAllocationCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, PackageWithAllocationCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, PackageWithAllocationCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public PackageWithAllocationCompositePriceFilter() { }

    public PackageWithAllocationCompositePriceFilter(
        PackageWithAllocationCompositePriceFilter packageWithAllocationCompositePriceFilter
    )
        : base(packageWithAllocationCompositePriceFilter) { }

    public PackageWithAllocationCompositePriceFilter(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    PackageWithAllocationCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="PackageWithAllocationCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static PackageWithAllocationCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class PackageWithAllocationCompositePriceFilterFromRaw
    : IFromRawJson<PackageWithAllocationCompositePriceFilter>
{
    /// <inheritdoc/>
    public PackageWithAllocationCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => PackageWithAllocationCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(PackageWithAllocationCompositePriceFilterFieldConverter))]
public enum PackageWithAllocationCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class PackageWithAllocationCompositePriceFilterFieldConverter
    : JsonConverter<PackageWithAllocationCompositePriceFilterField>
{
    public override PackageWithAllocationCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => PackageWithAllocationCompositePriceFilterField.PriceID,
            "item_id" => PackageWithAllocationCompositePriceFilterField.ItemID,
            "price_type" => PackageWithAllocationCompositePriceFilterField.PriceType,
            "currency" => PackageWithAllocationCompositePriceFilterField.Currency,
            "pricing_unit_id" => PackageWithAllocationCompositePriceFilterField.PricingUnitID,
            _ => (PackageWithAllocationCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PackageWithAllocationCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PackageWithAllocationCompositePriceFilterField.PriceID => "price_id",
                PackageWithAllocationCompositePriceFilterField.ItemID => "item_id",
                PackageWithAllocationCompositePriceFilterField.PriceType => "price_type",
                PackageWithAllocationCompositePriceFilterField.Currency => "currency",
                PackageWithAllocationCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(PackageWithAllocationCompositePriceFilterOperatorConverter))]
public enum PackageWithAllocationCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class PackageWithAllocationCompositePriceFilterOperatorConverter
    : JsonConverter<PackageWithAllocationCompositePriceFilterOperator>
{
    public override PackageWithAllocationCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => PackageWithAllocationCompositePriceFilterOperator.Includes,
            "excludes" => PackageWithAllocationCompositePriceFilterOperator.Excludes,
            _ => (PackageWithAllocationCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PackageWithAllocationCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PackageWithAllocationCompositePriceFilterOperator.Includes => "includes",
                PackageWithAllocationCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(PackageWithAllocationConversionRateConfigConverter))]
public record class PackageWithAllocationConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public PackageWithAllocationConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public PackageWithAllocationConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public PackageWithAllocationConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of PackageWithAllocationConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of PackageWithAllocationConversionRateConfig"
            ),
        };
    }

    public static implicit operator PackageWithAllocationConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator PackageWithAllocationConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of PackageWithAllocationConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(PackageWithAllocationConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class PackageWithAllocationConversionRateConfigConverter
    : JsonConverter<PackageWithAllocationConversionRateConfig>
{
    public override PackageWithAllocationConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new PackageWithAllocationConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        PackageWithAllocationConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

/// <summary>
/// Configuration for package_with_allocation pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        PackageWithAllocationPackageWithAllocationConfig,
        PackageWithAllocationPackageWithAllocationConfigFromRaw
    >)
)]
public sealed record class PackageWithAllocationPackageWithAllocationConfig : JsonModel
{
    /// <summary>
    /// Usage allocation
    /// </summary>
    public required string Allocation
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "allocation"); }
        init { JsonModel.Set(this._rawData, "allocation", value); }
    }

    /// <summary>
    /// Price per package
    /// </summary>
    public required string PackageAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "package_amount"); }
        init { JsonModel.Set(this._rawData, "package_amount", value); }
    }

    /// <summary>
    /// Package size
    /// </summary>
    public required string PackageSize
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "package_size"); }
        init { JsonModel.Set(this._rawData, "package_size", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.Allocation;
        _ = this.PackageAmount;
        _ = this.PackageSize;
    }

    public PackageWithAllocationPackageWithAllocationConfig() { }

    public PackageWithAllocationPackageWithAllocationConfig(
        PackageWithAllocationPackageWithAllocationConfig packageWithAllocationPackageWithAllocationConfig
    )
        : base(packageWithAllocationPackageWithAllocationConfig) { }

    public PackageWithAllocationPackageWithAllocationConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    PackageWithAllocationPackageWithAllocationConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="PackageWithAllocationPackageWithAllocationConfigFromRaw.FromRawUnchecked"/>
    public static PackageWithAllocationPackageWithAllocationConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class PackageWithAllocationPackageWithAllocationConfigFromRaw
    : IFromRawJson<PackageWithAllocationPackageWithAllocationConfig>
{
    /// <inheritdoc/>
    public PackageWithAllocationPackageWithAllocationConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => PackageWithAllocationPackageWithAllocationConfig.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(PackageWithAllocationPriceTypeConverter))]
public enum PackageWithAllocationPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class PackageWithAllocationPriceTypeConverter : JsonConverter<PackageWithAllocationPriceType>
{
    public override PackageWithAllocationPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => PackageWithAllocationPriceType.UsagePrice,
            "fixed_price" => PackageWithAllocationPriceType.FixedPrice,
            "composite_price" => PackageWithAllocationPriceType.CompositePrice,
            _ => (PackageWithAllocationPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PackageWithAllocationPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PackageWithAllocationPriceType.UsagePrice => "usage_price",
                PackageWithAllocationPriceType.FixedPrice => "fixed_price",
                PackageWithAllocationPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<UnitWithPercent, UnitWithPercentFromRaw>))]
public sealed record class UnitWithPercent : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, UnitWithPercentBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, UnitWithPercentBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, UnitWithPercentCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, UnitWithPercentCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<UnitWithPercentCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<UnitWithPercentCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required UnitWithPercentConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<UnitWithPercentConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, UnitWithPercentPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, UnitWithPercentPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    /// <summary>
    /// Configuration for unit_with_percent pricing
    /// </summary>
    public required UnitWithPercentUnitWithPercentConfig UnitWithPercentConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<UnitWithPercentUnitWithPercentConfig>(
                this.RawData,
                "unit_with_percent_config"
            );
        }
        init { JsonModel.Set(this._rawData, "unit_with_percent_config", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"unit_with_percent\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.UnitWithPercentConfig.Validate();
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public UnitWithPercent()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"unit_with_percent\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public UnitWithPercent(UnitWithPercent unitWithPercent)
        : base(unitWithPercent) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public UnitWithPercent(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"unit_with_percent\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    UnitWithPercent(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="UnitWithPercentFromRaw.FromRawUnchecked"/>
    public static UnitWithPercent FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class UnitWithPercentFromRaw : IFromRawJson<UnitWithPercent>
{
    /// <inheritdoc/>
    public UnitWithPercent FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        UnitWithPercent.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(UnitWithPercentBillingModeConverter))]
public enum UnitWithPercentBillingMode
{
    InAdvance,
    InArrear,
}

sealed class UnitWithPercentBillingModeConverter : JsonConverter<UnitWithPercentBillingMode>
{
    public override UnitWithPercentBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => UnitWithPercentBillingMode.InAdvance,
            "in_arrear" => UnitWithPercentBillingMode.InArrear,
            _ => (UnitWithPercentBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        UnitWithPercentBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                UnitWithPercentBillingMode.InAdvance => "in_advance",
                UnitWithPercentBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(UnitWithPercentCadenceConverter))]
public enum UnitWithPercentCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class UnitWithPercentCadenceConverter : JsonConverter<UnitWithPercentCadence>
{
    public override UnitWithPercentCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => UnitWithPercentCadence.OneTime,
            "monthly" => UnitWithPercentCadence.Monthly,
            "quarterly" => UnitWithPercentCadence.Quarterly,
            "semi_annual" => UnitWithPercentCadence.SemiAnnual,
            "annual" => UnitWithPercentCadence.Annual,
            "custom" => UnitWithPercentCadence.Custom,
            _ => (UnitWithPercentCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        UnitWithPercentCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                UnitWithPercentCadence.OneTime => "one_time",
                UnitWithPercentCadence.Monthly => "monthly",
                UnitWithPercentCadence.Quarterly => "quarterly",
                UnitWithPercentCadence.SemiAnnual => "semi_annual",
                UnitWithPercentCadence.Annual => "annual",
                UnitWithPercentCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        UnitWithPercentCompositePriceFilter,
        UnitWithPercentCompositePriceFilterFromRaw
    >)
)]
public sealed record class UnitWithPercentCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, UnitWithPercentCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, UnitWithPercentCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, UnitWithPercentCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, UnitWithPercentCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public UnitWithPercentCompositePriceFilter() { }

    public UnitWithPercentCompositePriceFilter(
        UnitWithPercentCompositePriceFilter unitWithPercentCompositePriceFilter
    )
        : base(unitWithPercentCompositePriceFilter) { }

    public UnitWithPercentCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    UnitWithPercentCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="UnitWithPercentCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static UnitWithPercentCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class UnitWithPercentCompositePriceFilterFromRaw : IFromRawJson<UnitWithPercentCompositePriceFilter>
{
    /// <inheritdoc/>
    public UnitWithPercentCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => UnitWithPercentCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(UnitWithPercentCompositePriceFilterFieldConverter))]
public enum UnitWithPercentCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class UnitWithPercentCompositePriceFilterFieldConverter
    : JsonConverter<UnitWithPercentCompositePriceFilterField>
{
    public override UnitWithPercentCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => UnitWithPercentCompositePriceFilterField.PriceID,
            "item_id" => UnitWithPercentCompositePriceFilterField.ItemID,
            "price_type" => UnitWithPercentCompositePriceFilterField.PriceType,
            "currency" => UnitWithPercentCompositePriceFilterField.Currency,
            "pricing_unit_id" => UnitWithPercentCompositePriceFilterField.PricingUnitID,
            _ => (UnitWithPercentCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        UnitWithPercentCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                UnitWithPercentCompositePriceFilterField.PriceID => "price_id",
                UnitWithPercentCompositePriceFilterField.ItemID => "item_id",
                UnitWithPercentCompositePriceFilterField.PriceType => "price_type",
                UnitWithPercentCompositePriceFilterField.Currency => "currency",
                UnitWithPercentCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(UnitWithPercentCompositePriceFilterOperatorConverter))]
public enum UnitWithPercentCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class UnitWithPercentCompositePriceFilterOperatorConverter
    : JsonConverter<UnitWithPercentCompositePriceFilterOperator>
{
    public override UnitWithPercentCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => UnitWithPercentCompositePriceFilterOperator.Includes,
            "excludes" => UnitWithPercentCompositePriceFilterOperator.Excludes,
            _ => (UnitWithPercentCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        UnitWithPercentCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                UnitWithPercentCompositePriceFilterOperator.Includes => "includes",
                UnitWithPercentCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(UnitWithPercentConversionRateConfigConverter))]
public record class UnitWithPercentConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public UnitWithPercentConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public UnitWithPercentConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public UnitWithPercentConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of UnitWithPercentConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of UnitWithPercentConversionRateConfig"
            ),
        };
    }

    public static implicit operator UnitWithPercentConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator UnitWithPercentConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of UnitWithPercentConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(UnitWithPercentConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class UnitWithPercentConversionRateConfigConverter
    : JsonConverter<UnitWithPercentConversionRateConfig>
{
    public override UnitWithPercentConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new UnitWithPercentConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        UnitWithPercentConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(UnitWithPercentPriceTypeConverter))]
public enum UnitWithPercentPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class UnitWithPercentPriceTypeConverter : JsonConverter<UnitWithPercentPriceType>
{
    public override UnitWithPercentPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => UnitWithPercentPriceType.UsagePrice,
            "fixed_price" => UnitWithPercentPriceType.FixedPrice,
            "composite_price" => UnitWithPercentPriceType.CompositePrice,
            _ => (UnitWithPercentPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        UnitWithPercentPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                UnitWithPercentPriceType.UsagePrice => "usage_price",
                UnitWithPercentPriceType.FixedPrice => "fixed_price",
                UnitWithPercentPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Configuration for unit_with_percent pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        UnitWithPercentUnitWithPercentConfig,
        UnitWithPercentUnitWithPercentConfigFromRaw
    >)
)]
public sealed record class UnitWithPercentUnitWithPercentConfig : JsonModel
{
    /// <summary>
    /// What percent, out of 100, of the calculated total to charge
    /// </summary>
    public required string Percent
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "percent"); }
        init { JsonModel.Set(this._rawData, "percent", value); }
    }

    /// <summary>
    /// Rate per unit of usage
    /// </summary>
    public required string UnitAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_amount"); }
        init { JsonModel.Set(this._rawData, "unit_amount", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.Percent;
        _ = this.UnitAmount;
    }

    public UnitWithPercentUnitWithPercentConfig() { }

    public UnitWithPercentUnitWithPercentConfig(
        UnitWithPercentUnitWithPercentConfig unitWithPercentUnitWithPercentConfig
    )
        : base(unitWithPercentUnitWithPercentConfig) { }

    public UnitWithPercentUnitWithPercentConfig(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    UnitWithPercentUnitWithPercentConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="UnitWithPercentUnitWithPercentConfigFromRaw.FromRawUnchecked"/>
    public static UnitWithPercentUnitWithPercentConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class UnitWithPercentUnitWithPercentConfigFromRaw
    : IFromRawJson<UnitWithPercentUnitWithPercentConfig>
{
    /// <inheritdoc/>
    public UnitWithPercentUnitWithPercentConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => UnitWithPercentUnitWithPercentConfig.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(JsonModelConverter<MatrixWithAllocation, MatrixWithAllocationFromRaw>))]
public sealed record class MatrixWithAllocation : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, MatrixWithAllocationBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, MatrixWithAllocationBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, MatrixWithAllocationCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, MatrixWithAllocationCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<MatrixWithAllocationCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<MatrixWithAllocationCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required MatrixWithAllocationConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<MatrixWithAllocationConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    /// <summary>
    /// Configuration for matrix_with_allocation pricing
    /// </summary>
    public required MatrixWithAllocationConfig MatrixWithAllocationConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<MatrixWithAllocationConfig>(
                this.RawData,
                "matrix_with_allocation_config"
            );
        }
        init { JsonModel.Set(this._rawData, "matrix_with_allocation_config", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, MatrixWithAllocationPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, MatrixWithAllocationPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.MatrixWithAllocationConfig.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"matrix_with_allocation\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public MatrixWithAllocation()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"matrix_with_allocation\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public MatrixWithAllocation(MatrixWithAllocation matrixWithAllocation)
        : base(matrixWithAllocation) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public MatrixWithAllocation(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"matrix_with_allocation\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    MatrixWithAllocation(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="MatrixWithAllocationFromRaw.FromRawUnchecked"/>
    public static MatrixWithAllocation FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class MatrixWithAllocationFromRaw : IFromRawJson<MatrixWithAllocation>
{
    /// <inheritdoc/>
    public MatrixWithAllocation FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => MatrixWithAllocation.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(MatrixWithAllocationBillingModeConverter))]
public enum MatrixWithAllocationBillingMode
{
    InAdvance,
    InArrear,
}

sealed class MatrixWithAllocationBillingModeConverter
    : JsonConverter<MatrixWithAllocationBillingMode>
{
    public override MatrixWithAllocationBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => MatrixWithAllocationBillingMode.InAdvance,
            "in_arrear" => MatrixWithAllocationBillingMode.InArrear,
            _ => (MatrixWithAllocationBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixWithAllocationBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MatrixWithAllocationBillingMode.InAdvance => "in_advance",
                MatrixWithAllocationBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(MatrixWithAllocationCadenceConverter))]
public enum MatrixWithAllocationCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class MatrixWithAllocationCadenceConverter : JsonConverter<MatrixWithAllocationCadence>
{
    public override MatrixWithAllocationCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => MatrixWithAllocationCadence.OneTime,
            "monthly" => MatrixWithAllocationCadence.Monthly,
            "quarterly" => MatrixWithAllocationCadence.Quarterly,
            "semi_annual" => MatrixWithAllocationCadence.SemiAnnual,
            "annual" => MatrixWithAllocationCadence.Annual,
            "custom" => MatrixWithAllocationCadence.Custom,
            _ => (MatrixWithAllocationCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixWithAllocationCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MatrixWithAllocationCadence.OneTime => "one_time",
                MatrixWithAllocationCadence.Monthly => "monthly",
                MatrixWithAllocationCadence.Quarterly => "quarterly",
                MatrixWithAllocationCadence.SemiAnnual => "semi_annual",
                MatrixWithAllocationCadence.Annual => "annual",
                MatrixWithAllocationCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        MatrixWithAllocationCompositePriceFilter,
        MatrixWithAllocationCompositePriceFilterFromRaw
    >)
)]
public sealed record class MatrixWithAllocationCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, MatrixWithAllocationCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, MatrixWithAllocationCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, MatrixWithAllocationCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, MatrixWithAllocationCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public MatrixWithAllocationCompositePriceFilter() { }

    public MatrixWithAllocationCompositePriceFilter(
        MatrixWithAllocationCompositePriceFilter matrixWithAllocationCompositePriceFilter
    )
        : base(matrixWithAllocationCompositePriceFilter) { }

    public MatrixWithAllocationCompositePriceFilter(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    MatrixWithAllocationCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="MatrixWithAllocationCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static MatrixWithAllocationCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class MatrixWithAllocationCompositePriceFilterFromRaw
    : IFromRawJson<MatrixWithAllocationCompositePriceFilter>
{
    /// <inheritdoc/>
    public MatrixWithAllocationCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => MatrixWithAllocationCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(MatrixWithAllocationCompositePriceFilterFieldConverter))]
public enum MatrixWithAllocationCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class MatrixWithAllocationCompositePriceFilterFieldConverter
    : JsonConverter<MatrixWithAllocationCompositePriceFilterField>
{
    public override MatrixWithAllocationCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => MatrixWithAllocationCompositePriceFilterField.PriceID,
            "item_id" => MatrixWithAllocationCompositePriceFilterField.ItemID,
            "price_type" => MatrixWithAllocationCompositePriceFilterField.PriceType,
            "currency" => MatrixWithAllocationCompositePriceFilterField.Currency,
            "pricing_unit_id" => MatrixWithAllocationCompositePriceFilterField.PricingUnitID,
            _ => (MatrixWithAllocationCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixWithAllocationCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MatrixWithAllocationCompositePriceFilterField.PriceID => "price_id",
                MatrixWithAllocationCompositePriceFilterField.ItemID => "item_id",
                MatrixWithAllocationCompositePriceFilterField.PriceType => "price_type",
                MatrixWithAllocationCompositePriceFilterField.Currency => "currency",
                MatrixWithAllocationCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(MatrixWithAllocationCompositePriceFilterOperatorConverter))]
public enum MatrixWithAllocationCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class MatrixWithAllocationCompositePriceFilterOperatorConverter
    : JsonConverter<MatrixWithAllocationCompositePriceFilterOperator>
{
    public override MatrixWithAllocationCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => MatrixWithAllocationCompositePriceFilterOperator.Includes,
            "excludes" => MatrixWithAllocationCompositePriceFilterOperator.Excludes,
            _ => (MatrixWithAllocationCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixWithAllocationCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MatrixWithAllocationCompositePriceFilterOperator.Includes => "includes",
                MatrixWithAllocationCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(MatrixWithAllocationConversionRateConfigConverter))]
public record class MatrixWithAllocationConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public MatrixWithAllocationConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public MatrixWithAllocationConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public MatrixWithAllocationConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of MatrixWithAllocationConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of MatrixWithAllocationConversionRateConfig"
            ),
        };
    }

    public static implicit operator MatrixWithAllocationConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator MatrixWithAllocationConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of MatrixWithAllocationConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(MatrixWithAllocationConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class MatrixWithAllocationConversionRateConfigConverter
    : JsonConverter<MatrixWithAllocationConversionRateConfig>
{
    public override MatrixWithAllocationConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new MatrixWithAllocationConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixWithAllocationConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(MatrixWithAllocationPriceTypeConverter))]
public enum MatrixWithAllocationPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class MatrixWithAllocationPriceTypeConverter : JsonConverter<MatrixWithAllocationPriceType>
{
    public override MatrixWithAllocationPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => MatrixWithAllocationPriceType.UsagePrice,
            "fixed_price" => MatrixWithAllocationPriceType.FixedPrice,
            "composite_price" => MatrixWithAllocationPriceType.CompositePrice,
            _ => (MatrixWithAllocationPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixWithAllocationPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MatrixWithAllocationPriceType.UsagePrice => "usage_price",
                MatrixWithAllocationPriceType.FixedPrice => "fixed_price",
                MatrixWithAllocationPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<TieredWithProration, TieredWithProrationFromRaw>))]
public sealed record class TieredWithProration : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, TieredWithProrationBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredWithProrationBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, TieredWithProrationCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredWithProrationCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<TieredWithProrationCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<TieredWithProrationCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required TieredWithProrationConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<TieredWithProrationConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, TieredWithProrationPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, TieredWithProrationPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    /// <summary>
    /// Configuration for tiered_with_proration pricing
    /// </summary>
    public required TieredWithProrationTieredWithProrationConfig TieredWithProrationConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<TieredWithProrationTieredWithProrationConfig>(
                this.RawData,
                "tiered_with_proration_config"
            );
        }
        init { JsonModel.Set(this._rawData, "tiered_with_proration_config", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"tiered_with_proration\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.TieredWithProrationConfig.Validate();
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public TieredWithProration()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"tiered_with_proration\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public TieredWithProration(TieredWithProration tieredWithProration)
        : base(tieredWithProration) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public TieredWithProration(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"tiered_with_proration\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    TieredWithProration(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredWithProrationFromRaw.FromRawUnchecked"/>
    public static TieredWithProration FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredWithProrationFromRaw : IFromRawJson<TieredWithProration>
{
    /// <inheritdoc/>
    public TieredWithProration FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        TieredWithProration.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(TieredWithProrationBillingModeConverter))]
public enum TieredWithProrationBillingMode
{
    InAdvance,
    InArrear,
}

sealed class TieredWithProrationBillingModeConverter : JsonConverter<TieredWithProrationBillingMode>
{
    public override TieredWithProrationBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => TieredWithProrationBillingMode.InAdvance,
            "in_arrear" => TieredWithProrationBillingMode.InArrear,
            _ => (TieredWithProrationBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredWithProrationBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredWithProrationBillingMode.InAdvance => "in_advance",
                TieredWithProrationBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(TieredWithProrationCadenceConverter))]
public enum TieredWithProrationCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class TieredWithProrationCadenceConverter : JsonConverter<TieredWithProrationCadence>
{
    public override TieredWithProrationCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => TieredWithProrationCadence.OneTime,
            "monthly" => TieredWithProrationCadence.Monthly,
            "quarterly" => TieredWithProrationCadence.Quarterly,
            "semi_annual" => TieredWithProrationCadence.SemiAnnual,
            "annual" => TieredWithProrationCadence.Annual,
            "custom" => TieredWithProrationCadence.Custom,
            _ => (TieredWithProrationCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredWithProrationCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredWithProrationCadence.OneTime => "one_time",
                TieredWithProrationCadence.Monthly => "monthly",
                TieredWithProrationCadence.Quarterly => "quarterly",
                TieredWithProrationCadence.SemiAnnual => "semi_annual",
                TieredWithProrationCadence.Annual => "annual",
                TieredWithProrationCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        TieredWithProrationCompositePriceFilter,
        TieredWithProrationCompositePriceFilterFromRaw
    >)
)]
public sealed record class TieredWithProrationCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, TieredWithProrationCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, TieredWithProrationCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, TieredWithProrationCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, TieredWithProrationCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public TieredWithProrationCompositePriceFilter() { }

    public TieredWithProrationCompositePriceFilter(
        TieredWithProrationCompositePriceFilter tieredWithProrationCompositePriceFilter
    )
        : base(tieredWithProrationCompositePriceFilter) { }

    public TieredWithProrationCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    TieredWithProrationCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredWithProrationCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static TieredWithProrationCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredWithProrationCompositePriceFilterFromRaw
    : IFromRawJson<TieredWithProrationCompositePriceFilter>
{
    /// <inheritdoc/>
    public TieredWithProrationCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => TieredWithProrationCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(TieredWithProrationCompositePriceFilterFieldConverter))]
public enum TieredWithProrationCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class TieredWithProrationCompositePriceFilterFieldConverter
    : JsonConverter<TieredWithProrationCompositePriceFilterField>
{
    public override TieredWithProrationCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => TieredWithProrationCompositePriceFilterField.PriceID,
            "item_id" => TieredWithProrationCompositePriceFilterField.ItemID,
            "price_type" => TieredWithProrationCompositePriceFilterField.PriceType,
            "currency" => TieredWithProrationCompositePriceFilterField.Currency,
            "pricing_unit_id" => TieredWithProrationCompositePriceFilterField.PricingUnitID,
            _ => (TieredWithProrationCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredWithProrationCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredWithProrationCompositePriceFilterField.PriceID => "price_id",
                TieredWithProrationCompositePriceFilterField.ItemID => "item_id",
                TieredWithProrationCompositePriceFilterField.PriceType => "price_type",
                TieredWithProrationCompositePriceFilterField.Currency => "currency",
                TieredWithProrationCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(TieredWithProrationCompositePriceFilterOperatorConverter))]
public enum TieredWithProrationCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class TieredWithProrationCompositePriceFilterOperatorConverter
    : JsonConverter<TieredWithProrationCompositePriceFilterOperator>
{
    public override TieredWithProrationCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => TieredWithProrationCompositePriceFilterOperator.Includes,
            "excludes" => TieredWithProrationCompositePriceFilterOperator.Excludes,
            _ => (TieredWithProrationCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredWithProrationCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredWithProrationCompositePriceFilterOperator.Includes => "includes",
                TieredWithProrationCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(TieredWithProrationConversionRateConfigConverter))]
public record class TieredWithProrationConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public TieredWithProrationConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public TieredWithProrationConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public TieredWithProrationConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of TieredWithProrationConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of TieredWithProrationConversionRateConfig"
            ),
        };
    }

    public static implicit operator TieredWithProrationConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator TieredWithProrationConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of TieredWithProrationConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(TieredWithProrationConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class TieredWithProrationConversionRateConfigConverter
    : JsonConverter<TieredWithProrationConversionRateConfig>
{
    public override TieredWithProrationConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new TieredWithProrationConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredWithProrationConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(TieredWithProrationPriceTypeConverter))]
public enum TieredWithProrationPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class TieredWithProrationPriceTypeConverter : JsonConverter<TieredWithProrationPriceType>
{
    public override TieredWithProrationPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => TieredWithProrationPriceType.UsagePrice,
            "fixed_price" => TieredWithProrationPriceType.FixedPrice,
            "composite_price" => TieredWithProrationPriceType.CompositePrice,
            _ => (TieredWithProrationPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        TieredWithProrationPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                TieredWithProrationPriceType.UsagePrice => "usage_price",
                TieredWithProrationPriceType.FixedPrice => "fixed_price",
                TieredWithProrationPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Configuration for tiered_with_proration pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        TieredWithProrationTieredWithProrationConfig,
        TieredWithProrationTieredWithProrationConfigFromRaw
    >)
)]
public sealed record class TieredWithProrationTieredWithProrationConfig : JsonModel
{
    /// <summary>
    /// Tiers for rating based on total usage quantities into the specified tier
    /// with proration
    /// </summary>
    public required IReadOnlyList<TieredWithProrationTieredWithProrationConfigTier> Tiers
    {
        get
        {
            return JsonModel.GetNotNullClass<
                List<TieredWithProrationTieredWithProrationConfigTier>
            >(this.RawData, "tiers");
        }
        init { JsonModel.Set(this._rawData, "tiers", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        foreach (var item in this.Tiers)
        {
            item.Validate();
        }
    }

    public TieredWithProrationTieredWithProrationConfig() { }

    public TieredWithProrationTieredWithProrationConfig(
        TieredWithProrationTieredWithProrationConfig tieredWithProrationTieredWithProrationConfig
    )
        : base(tieredWithProrationTieredWithProrationConfig) { }

    public TieredWithProrationTieredWithProrationConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    TieredWithProrationTieredWithProrationConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredWithProrationTieredWithProrationConfigFromRaw.FromRawUnchecked"/>
    public static TieredWithProrationTieredWithProrationConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }

    [SetsRequiredMembers]
    public TieredWithProrationTieredWithProrationConfig(
        List<TieredWithProrationTieredWithProrationConfigTier> tiers
    )
        : this()
    {
        this.Tiers = tiers;
    }
}

class TieredWithProrationTieredWithProrationConfigFromRaw
    : IFromRawJson<TieredWithProrationTieredWithProrationConfig>
{
    /// <inheritdoc/>
    public TieredWithProrationTieredWithProrationConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => TieredWithProrationTieredWithProrationConfig.FromRawUnchecked(rawData);
}

/// <summary>
/// Configuration for a single tiered with proration tier
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        TieredWithProrationTieredWithProrationConfigTier,
        TieredWithProrationTieredWithProrationConfigTierFromRaw
    >)
)]
public sealed record class TieredWithProrationTieredWithProrationConfigTier : JsonModel
{
    /// <summary>
    /// Inclusive tier starting value
    /// </summary>
    public required string TierLowerBound
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "tier_lower_bound"); }
        init { JsonModel.Set(this._rawData, "tier_lower_bound", value); }
    }

    /// <summary>
    /// Amount per unit
    /// </summary>
    public required string UnitAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_amount"); }
        init { JsonModel.Set(this._rawData, "unit_amount", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.TierLowerBound;
        _ = this.UnitAmount;
    }

    public TieredWithProrationTieredWithProrationConfigTier() { }

    public TieredWithProrationTieredWithProrationConfigTier(
        TieredWithProrationTieredWithProrationConfigTier tieredWithProrationTieredWithProrationConfigTier
    )
        : base(tieredWithProrationTieredWithProrationConfigTier) { }

    public TieredWithProrationTieredWithProrationConfigTier(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    TieredWithProrationTieredWithProrationConfigTier(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="TieredWithProrationTieredWithProrationConfigTierFromRaw.FromRawUnchecked"/>
    public static TieredWithProrationTieredWithProrationConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class TieredWithProrationTieredWithProrationConfigTierFromRaw
    : IFromRawJson<TieredWithProrationTieredWithProrationConfigTier>
{
    /// <inheritdoc/>
    public TieredWithProrationTieredWithProrationConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => TieredWithProrationTieredWithProrationConfigTier.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(JsonModelConverter<UnitWithProration, UnitWithProrationFromRaw>))]
public sealed record class UnitWithProration : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, UnitWithProrationBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, UnitWithProrationBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, UnitWithProrationCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, UnitWithProrationCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<UnitWithProrationCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<UnitWithProrationCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required UnitWithProrationConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<UnitWithProrationConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, UnitWithProrationPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, UnitWithProrationPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    /// <summary>
    /// Configuration for unit_with_proration pricing
    /// </summary>
    public required UnitWithProrationUnitWithProrationConfig UnitWithProrationConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<UnitWithProrationUnitWithProrationConfig>(
                this.RawData,
                "unit_with_proration_config"
            );
        }
        init { JsonModel.Set(this._rawData, "unit_with_proration_config", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"unit_with_proration\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.UnitWithProrationConfig.Validate();
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public UnitWithProration()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"unit_with_proration\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public UnitWithProration(UnitWithProration unitWithProration)
        : base(unitWithProration) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public UnitWithProration(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"unit_with_proration\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    UnitWithProration(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="UnitWithProrationFromRaw.FromRawUnchecked"/>
    public static UnitWithProration FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class UnitWithProrationFromRaw : IFromRawJson<UnitWithProration>
{
    /// <inheritdoc/>
    public UnitWithProration FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        UnitWithProration.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(UnitWithProrationBillingModeConverter))]
public enum UnitWithProrationBillingMode
{
    InAdvance,
    InArrear,
}

sealed class UnitWithProrationBillingModeConverter : JsonConverter<UnitWithProrationBillingMode>
{
    public override UnitWithProrationBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => UnitWithProrationBillingMode.InAdvance,
            "in_arrear" => UnitWithProrationBillingMode.InArrear,
            _ => (UnitWithProrationBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        UnitWithProrationBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                UnitWithProrationBillingMode.InAdvance => "in_advance",
                UnitWithProrationBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(UnitWithProrationCadenceConverter))]
public enum UnitWithProrationCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class UnitWithProrationCadenceConverter : JsonConverter<UnitWithProrationCadence>
{
    public override UnitWithProrationCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => UnitWithProrationCadence.OneTime,
            "monthly" => UnitWithProrationCadence.Monthly,
            "quarterly" => UnitWithProrationCadence.Quarterly,
            "semi_annual" => UnitWithProrationCadence.SemiAnnual,
            "annual" => UnitWithProrationCadence.Annual,
            "custom" => UnitWithProrationCadence.Custom,
            _ => (UnitWithProrationCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        UnitWithProrationCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                UnitWithProrationCadence.OneTime => "one_time",
                UnitWithProrationCadence.Monthly => "monthly",
                UnitWithProrationCadence.Quarterly => "quarterly",
                UnitWithProrationCadence.SemiAnnual => "semi_annual",
                UnitWithProrationCadence.Annual => "annual",
                UnitWithProrationCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        UnitWithProrationCompositePriceFilter,
        UnitWithProrationCompositePriceFilterFromRaw
    >)
)]
public sealed record class UnitWithProrationCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, UnitWithProrationCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, UnitWithProrationCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, UnitWithProrationCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, UnitWithProrationCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public UnitWithProrationCompositePriceFilter() { }

    public UnitWithProrationCompositePriceFilter(
        UnitWithProrationCompositePriceFilter unitWithProrationCompositePriceFilter
    )
        : base(unitWithProrationCompositePriceFilter) { }

    public UnitWithProrationCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    UnitWithProrationCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="UnitWithProrationCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static UnitWithProrationCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class UnitWithProrationCompositePriceFilterFromRaw
    : IFromRawJson<UnitWithProrationCompositePriceFilter>
{
    /// <inheritdoc/>
    public UnitWithProrationCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => UnitWithProrationCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(UnitWithProrationCompositePriceFilterFieldConverter))]
public enum UnitWithProrationCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class UnitWithProrationCompositePriceFilterFieldConverter
    : JsonConverter<UnitWithProrationCompositePriceFilterField>
{
    public override UnitWithProrationCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => UnitWithProrationCompositePriceFilterField.PriceID,
            "item_id" => UnitWithProrationCompositePriceFilterField.ItemID,
            "price_type" => UnitWithProrationCompositePriceFilterField.PriceType,
            "currency" => UnitWithProrationCompositePriceFilterField.Currency,
            "pricing_unit_id" => UnitWithProrationCompositePriceFilterField.PricingUnitID,
            _ => (UnitWithProrationCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        UnitWithProrationCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                UnitWithProrationCompositePriceFilterField.PriceID => "price_id",
                UnitWithProrationCompositePriceFilterField.ItemID => "item_id",
                UnitWithProrationCompositePriceFilterField.PriceType => "price_type",
                UnitWithProrationCompositePriceFilterField.Currency => "currency",
                UnitWithProrationCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(UnitWithProrationCompositePriceFilterOperatorConverter))]
public enum UnitWithProrationCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class UnitWithProrationCompositePriceFilterOperatorConverter
    : JsonConverter<UnitWithProrationCompositePriceFilterOperator>
{
    public override UnitWithProrationCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => UnitWithProrationCompositePriceFilterOperator.Includes,
            "excludes" => UnitWithProrationCompositePriceFilterOperator.Excludes,
            _ => (UnitWithProrationCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        UnitWithProrationCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                UnitWithProrationCompositePriceFilterOperator.Includes => "includes",
                UnitWithProrationCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(UnitWithProrationConversionRateConfigConverter))]
public record class UnitWithProrationConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public UnitWithProrationConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public UnitWithProrationConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public UnitWithProrationConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of UnitWithProrationConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of UnitWithProrationConversionRateConfig"
            ),
        };
    }

    public static implicit operator UnitWithProrationConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator UnitWithProrationConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of UnitWithProrationConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(UnitWithProrationConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class UnitWithProrationConversionRateConfigConverter
    : JsonConverter<UnitWithProrationConversionRateConfig>
{
    public override UnitWithProrationConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new UnitWithProrationConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        UnitWithProrationConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(UnitWithProrationPriceTypeConverter))]
public enum UnitWithProrationPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class UnitWithProrationPriceTypeConverter : JsonConverter<UnitWithProrationPriceType>
{
    public override UnitWithProrationPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => UnitWithProrationPriceType.UsagePrice,
            "fixed_price" => UnitWithProrationPriceType.FixedPrice,
            "composite_price" => UnitWithProrationPriceType.CompositePrice,
            _ => (UnitWithProrationPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        UnitWithProrationPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                UnitWithProrationPriceType.UsagePrice => "usage_price",
                UnitWithProrationPriceType.FixedPrice => "fixed_price",
                UnitWithProrationPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Configuration for unit_with_proration pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        UnitWithProrationUnitWithProrationConfig,
        UnitWithProrationUnitWithProrationConfigFromRaw
    >)
)]
public sealed record class UnitWithProrationUnitWithProrationConfig : JsonModel
{
    /// <summary>
    /// Rate per unit of usage
    /// </summary>
    public required string UnitAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_amount"); }
        init { JsonModel.Set(this._rawData, "unit_amount", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.UnitAmount;
    }

    public UnitWithProrationUnitWithProrationConfig() { }

    public UnitWithProrationUnitWithProrationConfig(
        UnitWithProrationUnitWithProrationConfig unitWithProrationUnitWithProrationConfig
    )
        : base(unitWithProrationUnitWithProrationConfig) { }

    public UnitWithProrationUnitWithProrationConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    UnitWithProrationUnitWithProrationConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="UnitWithProrationUnitWithProrationConfigFromRaw.FromRawUnchecked"/>
    public static UnitWithProrationUnitWithProrationConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }

    [SetsRequiredMembers]
    public UnitWithProrationUnitWithProrationConfig(string unitAmount)
        : this()
    {
        this.UnitAmount = unitAmount;
    }
}

class UnitWithProrationUnitWithProrationConfigFromRaw
    : IFromRawJson<UnitWithProrationUnitWithProrationConfig>
{
    /// <inheritdoc/>
    public UnitWithProrationUnitWithProrationConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => UnitWithProrationUnitWithProrationConfig.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(JsonModelConverter<GroupedAllocation, GroupedAllocationFromRaw>))]
public sealed record class GroupedAllocation : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, GroupedAllocationBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedAllocationBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, GroupedAllocationCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedAllocationCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<GroupedAllocationCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<GroupedAllocationCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required GroupedAllocationConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<GroupedAllocationConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    /// <summary>
    /// Configuration for grouped_allocation pricing
    /// </summary>
    public required GroupedAllocationGroupedAllocationConfig GroupedAllocationConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<GroupedAllocationGroupedAllocationConfig>(
                this.RawData,
                "grouped_allocation_config"
            );
        }
        init { JsonModel.Set(this._rawData, "grouped_allocation_config", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, GroupedAllocationPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedAllocationPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.GroupedAllocationConfig.Validate();
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"grouped_allocation\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedAllocation()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"grouped_allocation\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedAllocation(GroupedAllocation groupedAllocation)
        : base(groupedAllocation) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedAllocation(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"grouped_allocation\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    GroupedAllocation(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedAllocationFromRaw.FromRawUnchecked"/>
    public static GroupedAllocation FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedAllocationFromRaw : IFromRawJson<GroupedAllocation>
{
    /// <inheritdoc/>
    public GroupedAllocation FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        GroupedAllocation.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(GroupedAllocationBillingModeConverter))]
public enum GroupedAllocationBillingMode
{
    InAdvance,
    InArrear,
}

sealed class GroupedAllocationBillingModeConverter : JsonConverter<GroupedAllocationBillingMode>
{
    public override GroupedAllocationBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => GroupedAllocationBillingMode.InAdvance,
            "in_arrear" => GroupedAllocationBillingMode.InArrear,
            _ => (GroupedAllocationBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedAllocationBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedAllocationBillingMode.InAdvance => "in_advance",
                GroupedAllocationBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(GroupedAllocationCadenceConverter))]
public enum GroupedAllocationCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class GroupedAllocationCadenceConverter : JsonConverter<GroupedAllocationCadence>
{
    public override GroupedAllocationCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => GroupedAllocationCadence.OneTime,
            "monthly" => GroupedAllocationCadence.Monthly,
            "quarterly" => GroupedAllocationCadence.Quarterly,
            "semi_annual" => GroupedAllocationCadence.SemiAnnual,
            "annual" => GroupedAllocationCadence.Annual,
            "custom" => GroupedAllocationCadence.Custom,
            _ => (GroupedAllocationCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedAllocationCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedAllocationCadence.OneTime => "one_time",
                GroupedAllocationCadence.Monthly => "monthly",
                GroupedAllocationCadence.Quarterly => "quarterly",
                GroupedAllocationCadence.SemiAnnual => "semi_annual",
                GroupedAllocationCadence.Annual => "annual",
                GroupedAllocationCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        GroupedAllocationCompositePriceFilter,
        GroupedAllocationCompositePriceFilterFromRaw
    >)
)]
public sealed record class GroupedAllocationCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, GroupedAllocationCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, GroupedAllocationCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, GroupedAllocationCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, GroupedAllocationCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public GroupedAllocationCompositePriceFilter() { }

    public GroupedAllocationCompositePriceFilter(
        GroupedAllocationCompositePriceFilter groupedAllocationCompositePriceFilter
    )
        : base(groupedAllocationCompositePriceFilter) { }

    public GroupedAllocationCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedAllocationCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedAllocationCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static GroupedAllocationCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedAllocationCompositePriceFilterFromRaw
    : IFromRawJson<GroupedAllocationCompositePriceFilter>
{
    /// <inheritdoc/>
    public GroupedAllocationCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedAllocationCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(GroupedAllocationCompositePriceFilterFieldConverter))]
public enum GroupedAllocationCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class GroupedAllocationCompositePriceFilterFieldConverter
    : JsonConverter<GroupedAllocationCompositePriceFilterField>
{
    public override GroupedAllocationCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => GroupedAllocationCompositePriceFilterField.PriceID,
            "item_id" => GroupedAllocationCompositePriceFilterField.ItemID,
            "price_type" => GroupedAllocationCompositePriceFilterField.PriceType,
            "currency" => GroupedAllocationCompositePriceFilterField.Currency,
            "pricing_unit_id" => GroupedAllocationCompositePriceFilterField.PricingUnitID,
            _ => (GroupedAllocationCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedAllocationCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedAllocationCompositePriceFilterField.PriceID => "price_id",
                GroupedAllocationCompositePriceFilterField.ItemID => "item_id",
                GroupedAllocationCompositePriceFilterField.PriceType => "price_type",
                GroupedAllocationCompositePriceFilterField.Currency => "currency",
                GroupedAllocationCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(GroupedAllocationCompositePriceFilterOperatorConverter))]
public enum GroupedAllocationCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class GroupedAllocationCompositePriceFilterOperatorConverter
    : JsonConverter<GroupedAllocationCompositePriceFilterOperator>
{
    public override GroupedAllocationCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => GroupedAllocationCompositePriceFilterOperator.Includes,
            "excludes" => GroupedAllocationCompositePriceFilterOperator.Excludes,
            _ => (GroupedAllocationCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedAllocationCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedAllocationCompositePriceFilterOperator.Includes => "includes",
                GroupedAllocationCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(GroupedAllocationConversionRateConfigConverter))]
public record class GroupedAllocationConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public GroupedAllocationConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public GroupedAllocationConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public GroupedAllocationConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of GroupedAllocationConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of GroupedAllocationConversionRateConfig"
            ),
        };
    }

    public static implicit operator GroupedAllocationConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator GroupedAllocationConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of GroupedAllocationConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(GroupedAllocationConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class GroupedAllocationConversionRateConfigConverter
    : JsonConverter<GroupedAllocationConversionRateConfig>
{
    public override GroupedAllocationConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new GroupedAllocationConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedAllocationConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

/// <summary>
/// Configuration for grouped_allocation pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        GroupedAllocationGroupedAllocationConfig,
        GroupedAllocationGroupedAllocationConfigFromRaw
    >)
)]
public sealed record class GroupedAllocationGroupedAllocationConfig : JsonModel
{
    /// <summary>
    /// Usage allocation per group
    /// </summary>
    public required string Allocation
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "allocation"); }
        init { JsonModel.Set(this._rawData, "allocation", value); }
    }

    /// <summary>
    /// How to determine the groups that should each be allocated some quantity
    /// </summary>
    public required string GroupingKey
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "grouping_key"); }
        init { JsonModel.Set(this._rawData, "grouping_key", value); }
    }

    /// <summary>
    /// Unit rate for post-allocation
    /// </summary>
    public required string OverageUnitRate
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "overage_unit_rate"); }
        init { JsonModel.Set(this._rawData, "overage_unit_rate", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.Allocation;
        _ = this.GroupingKey;
        _ = this.OverageUnitRate;
    }

    public GroupedAllocationGroupedAllocationConfig() { }

    public GroupedAllocationGroupedAllocationConfig(
        GroupedAllocationGroupedAllocationConfig groupedAllocationGroupedAllocationConfig
    )
        : base(groupedAllocationGroupedAllocationConfig) { }

    public GroupedAllocationGroupedAllocationConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedAllocationGroupedAllocationConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedAllocationGroupedAllocationConfigFromRaw.FromRawUnchecked"/>
    public static GroupedAllocationGroupedAllocationConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedAllocationGroupedAllocationConfigFromRaw
    : IFromRawJson<GroupedAllocationGroupedAllocationConfig>
{
    /// <inheritdoc/>
    public GroupedAllocationGroupedAllocationConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedAllocationGroupedAllocationConfig.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(GroupedAllocationPriceTypeConverter))]
public enum GroupedAllocationPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class GroupedAllocationPriceTypeConverter : JsonConverter<GroupedAllocationPriceType>
{
    public override GroupedAllocationPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => GroupedAllocationPriceType.UsagePrice,
            "fixed_price" => GroupedAllocationPriceType.FixedPrice,
            "composite_price" => GroupedAllocationPriceType.CompositePrice,
            _ => (GroupedAllocationPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedAllocationPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedAllocationPriceType.UsagePrice => "usage_price",
                GroupedAllocationPriceType.FixedPrice => "fixed_price",
                GroupedAllocationPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<BulkWithProration, BulkWithProrationFromRaw>))]
public sealed record class BulkWithProration : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, BulkWithProrationBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, BulkWithProrationBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    /// <summary>
    /// Configuration for bulk_with_proration pricing
    /// </summary>
    public required BulkWithProrationBulkWithProrationConfig BulkWithProrationConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<BulkWithProrationBulkWithProrationConfig>(
                this.RawData,
                "bulk_with_proration_config"
            );
        }
        init { JsonModel.Set(this._rawData, "bulk_with_proration_config", value); }
    }

    public required ApiEnum<string, BulkWithProrationCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, BulkWithProrationCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<BulkWithProrationCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<BulkWithProrationCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required BulkWithProrationConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<BulkWithProrationConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, BulkWithProrationPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, BulkWithProrationPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.BulkWithProrationConfig.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"bulk_with_proration\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public BulkWithProration()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"bulk_with_proration\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public BulkWithProration(BulkWithProration bulkWithProration)
        : base(bulkWithProration) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public BulkWithProration(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"bulk_with_proration\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    BulkWithProration(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="BulkWithProrationFromRaw.FromRawUnchecked"/>
    public static BulkWithProration FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class BulkWithProrationFromRaw : IFromRawJson<BulkWithProration>
{
    /// <inheritdoc/>
    public BulkWithProration FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        BulkWithProration.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(BulkWithProrationBillingModeConverter))]
public enum BulkWithProrationBillingMode
{
    InAdvance,
    InArrear,
}

sealed class BulkWithProrationBillingModeConverter : JsonConverter<BulkWithProrationBillingMode>
{
    public override BulkWithProrationBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => BulkWithProrationBillingMode.InAdvance,
            "in_arrear" => BulkWithProrationBillingMode.InArrear,
            _ => (BulkWithProrationBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkWithProrationBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BulkWithProrationBillingMode.InAdvance => "in_advance",
                BulkWithProrationBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Configuration for bulk_with_proration pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        BulkWithProrationBulkWithProrationConfig,
        BulkWithProrationBulkWithProrationConfigFromRaw
    >)
)]
public sealed record class BulkWithProrationBulkWithProrationConfig : JsonModel
{
    /// <summary>
    /// Bulk tiers for rating based on total usage volume
    /// </summary>
    public required IReadOnlyList<BulkWithProrationBulkWithProrationConfigTier> Tiers
    {
        get
        {
            return JsonModel.GetNotNullClass<List<BulkWithProrationBulkWithProrationConfigTier>>(
                this.RawData,
                "tiers"
            );
        }
        init { JsonModel.Set(this._rawData, "tiers", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        foreach (var item in this.Tiers)
        {
            item.Validate();
        }
    }

    public BulkWithProrationBulkWithProrationConfig() { }

    public BulkWithProrationBulkWithProrationConfig(
        BulkWithProrationBulkWithProrationConfig bulkWithProrationBulkWithProrationConfig
    )
        : base(bulkWithProrationBulkWithProrationConfig) { }

    public BulkWithProrationBulkWithProrationConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    BulkWithProrationBulkWithProrationConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="BulkWithProrationBulkWithProrationConfigFromRaw.FromRawUnchecked"/>
    public static BulkWithProrationBulkWithProrationConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }

    [SetsRequiredMembers]
    public BulkWithProrationBulkWithProrationConfig(
        List<BulkWithProrationBulkWithProrationConfigTier> tiers
    )
        : this()
    {
        this.Tiers = tiers;
    }
}

class BulkWithProrationBulkWithProrationConfigFromRaw
    : IFromRawJson<BulkWithProrationBulkWithProrationConfig>
{
    /// <inheritdoc/>
    public BulkWithProrationBulkWithProrationConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => BulkWithProrationBulkWithProrationConfig.FromRawUnchecked(rawData);
}

/// <summary>
/// Configuration for a single bulk pricing tier with proration
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        BulkWithProrationBulkWithProrationConfigTier,
        BulkWithProrationBulkWithProrationConfigTierFromRaw
    >)
)]
public sealed record class BulkWithProrationBulkWithProrationConfigTier : JsonModel
{
    /// <summary>
    /// Cost per unit
    /// </summary>
    public required string UnitAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_amount"); }
        init { JsonModel.Set(this._rawData, "unit_amount", value); }
    }

    /// <summary>
    /// The lower bound for this tier
    /// </summary>
    public string? TierLowerBound
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "tier_lower_bound"); }
        init { JsonModel.Set(this._rawData, "tier_lower_bound", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.UnitAmount;
        _ = this.TierLowerBound;
    }

    public BulkWithProrationBulkWithProrationConfigTier() { }

    public BulkWithProrationBulkWithProrationConfigTier(
        BulkWithProrationBulkWithProrationConfigTier bulkWithProrationBulkWithProrationConfigTier
    )
        : base(bulkWithProrationBulkWithProrationConfigTier) { }

    public BulkWithProrationBulkWithProrationConfigTier(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    BulkWithProrationBulkWithProrationConfigTier(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="BulkWithProrationBulkWithProrationConfigTierFromRaw.FromRawUnchecked"/>
    public static BulkWithProrationBulkWithProrationConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }

    [SetsRequiredMembers]
    public BulkWithProrationBulkWithProrationConfigTier(string unitAmount)
        : this()
    {
        this.UnitAmount = unitAmount;
    }
}

class BulkWithProrationBulkWithProrationConfigTierFromRaw
    : IFromRawJson<BulkWithProrationBulkWithProrationConfigTier>
{
    /// <inheritdoc/>
    public BulkWithProrationBulkWithProrationConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => BulkWithProrationBulkWithProrationConfigTier.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(BulkWithProrationCadenceConverter))]
public enum BulkWithProrationCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class BulkWithProrationCadenceConverter : JsonConverter<BulkWithProrationCadence>
{
    public override BulkWithProrationCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => BulkWithProrationCadence.OneTime,
            "monthly" => BulkWithProrationCadence.Monthly,
            "quarterly" => BulkWithProrationCadence.Quarterly,
            "semi_annual" => BulkWithProrationCadence.SemiAnnual,
            "annual" => BulkWithProrationCadence.Annual,
            "custom" => BulkWithProrationCadence.Custom,
            _ => (BulkWithProrationCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkWithProrationCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BulkWithProrationCadence.OneTime => "one_time",
                BulkWithProrationCadence.Monthly => "monthly",
                BulkWithProrationCadence.Quarterly => "quarterly",
                BulkWithProrationCadence.SemiAnnual => "semi_annual",
                BulkWithProrationCadence.Annual => "annual",
                BulkWithProrationCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        BulkWithProrationCompositePriceFilter,
        BulkWithProrationCompositePriceFilterFromRaw
    >)
)]
public sealed record class BulkWithProrationCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, BulkWithProrationCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, BulkWithProrationCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, BulkWithProrationCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, BulkWithProrationCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public BulkWithProrationCompositePriceFilter() { }

    public BulkWithProrationCompositePriceFilter(
        BulkWithProrationCompositePriceFilter bulkWithProrationCompositePriceFilter
    )
        : base(bulkWithProrationCompositePriceFilter) { }

    public BulkWithProrationCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    BulkWithProrationCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="BulkWithProrationCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static BulkWithProrationCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class BulkWithProrationCompositePriceFilterFromRaw
    : IFromRawJson<BulkWithProrationCompositePriceFilter>
{
    /// <inheritdoc/>
    public BulkWithProrationCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => BulkWithProrationCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(BulkWithProrationCompositePriceFilterFieldConverter))]
public enum BulkWithProrationCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class BulkWithProrationCompositePriceFilterFieldConverter
    : JsonConverter<BulkWithProrationCompositePriceFilterField>
{
    public override BulkWithProrationCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => BulkWithProrationCompositePriceFilterField.PriceID,
            "item_id" => BulkWithProrationCompositePriceFilterField.ItemID,
            "price_type" => BulkWithProrationCompositePriceFilterField.PriceType,
            "currency" => BulkWithProrationCompositePriceFilterField.Currency,
            "pricing_unit_id" => BulkWithProrationCompositePriceFilterField.PricingUnitID,
            _ => (BulkWithProrationCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkWithProrationCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BulkWithProrationCompositePriceFilterField.PriceID => "price_id",
                BulkWithProrationCompositePriceFilterField.ItemID => "item_id",
                BulkWithProrationCompositePriceFilterField.PriceType => "price_type",
                BulkWithProrationCompositePriceFilterField.Currency => "currency",
                BulkWithProrationCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(BulkWithProrationCompositePriceFilterOperatorConverter))]
public enum BulkWithProrationCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class BulkWithProrationCompositePriceFilterOperatorConverter
    : JsonConverter<BulkWithProrationCompositePriceFilterOperator>
{
    public override BulkWithProrationCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => BulkWithProrationCompositePriceFilterOperator.Includes,
            "excludes" => BulkWithProrationCompositePriceFilterOperator.Excludes,
            _ => (BulkWithProrationCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkWithProrationCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BulkWithProrationCompositePriceFilterOperator.Includes => "includes",
                BulkWithProrationCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(BulkWithProrationConversionRateConfigConverter))]
public record class BulkWithProrationConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public BulkWithProrationConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public BulkWithProrationConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public BulkWithProrationConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of BulkWithProrationConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of BulkWithProrationConversionRateConfig"
            ),
        };
    }

    public static implicit operator BulkWithProrationConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator BulkWithProrationConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of BulkWithProrationConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(BulkWithProrationConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class BulkWithProrationConversionRateConfigConverter
    : JsonConverter<BulkWithProrationConversionRateConfig>
{
    public override BulkWithProrationConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new BulkWithProrationConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkWithProrationConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(BulkWithProrationPriceTypeConverter))]
public enum BulkWithProrationPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class BulkWithProrationPriceTypeConverter : JsonConverter<BulkWithProrationPriceType>
{
    public override BulkWithProrationPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => BulkWithProrationPriceType.UsagePrice,
            "fixed_price" => BulkWithProrationPriceType.FixedPrice,
            "composite_price" => BulkWithProrationPriceType.CompositePrice,
            _ => (BulkWithProrationPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        BulkWithProrationPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                BulkWithProrationPriceType.UsagePrice => "usage_price",
                BulkWithProrationPriceType.FixedPrice => "fixed_price",
                BulkWithProrationPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<GroupedWithProratedMinimum, GroupedWithProratedMinimumFromRaw>)
)]
public sealed record class GroupedWithProratedMinimum : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, GroupedWithProratedMinimumBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, GroupedWithProratedMinimumBillingMode>
            >(this.RawData, "billing_mode");
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, GroupedWithProratedMinimumCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedWithProratedMinimumCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<GroupedWithProratedMinimumCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<GroupedWithProratedMinimumCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required GroupedWithProratedMinimumConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<GroupedWithProratedMinimumConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    /// <summary>
    /// Configuration for grouped_with_prorated_minimum pricing
    /// </summary>
    public required GroupedWithProratedMinimumGroupedWithProratedMinimumConfig GroupedWithProratedMinimumConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<GroupedWithProratedMinimumGroupedWithProratedMinimumConfig>(
                this.RawData,
                "grouped_with_prorated_minimum_config"
            );
        }
        init { JsonModel.Set(this._rawData, "grouped_with_prorated_minimum_config", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, GroupedWithProratedMinimumPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedWithProratedMinimumPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.GroupedWithProratedMinimumConfig.Validate();
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"grouped_with_prorated_minimum\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedWithProratedMinimum()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>(
            "\"grouped_with_prorated_minimum\""
        );
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedWithProratedMinimum(GroupedWithProratedMinimum groupedWithProratedMinimum)
        : base(groupedWithProratedMinimum) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedWithProratedMinimum(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>(
            "\"grouped_with_prorated_minimum\""
        );
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    GroupedWithProratedMinimum(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedWithProratedMinimumFromRaw.FromRawUnchecked"/>
    public static GroupedWithProratedMinimum FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedWithProratedMinimumFromRaw : IFromRawJson<GroupedWithProratedMinimum>
{
    /// <inheritdoc/>
    public GroupedWithProratedMinimum FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedWithProratedMinimum.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(GroupedWithProratedMinimumBillingModeConverter))]
public enum GroupedWithProratedMinimumBillingMode
{
    InAdvance,
    InArrear,
}

sealed class GroupedWithProratedMinimumBillingModeConverter
    : JsonConverter<GroupedWithProratedMinimumBillingMode>
{
    public override GroupedWithProratedMinimumBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => GroupedWithProratedMinimumBillingMode.InAdvance,
            "in_arrear" => GroupedWithProratedMinimumBillingMode.InArrear,
            _ => (GroupedWithProratedMinimumBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithProratedMinimumBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedWithProratedMinimumBillingMode.InAdvance => "in_advance",
                GroupedWithProratedMinimumBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(GroupedWithProratedMinimumCadenceConverter))]
public enum GroupedWithProratedMinimumCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class GroupedWithProratedMinimumCadenceConverter
    : JsonConverter<GroupedWithProratedMinimumCadence>
{
    public override GroupedWithProratedMinimumCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => GroupedWithProratedMinimumCadence.OneTime,
            "monthly" => GroupedWithProratedMinimumCadence.Monthly,
            "quarterly" => GroupedWithProratedMinimumCadence.Quarterly,
            "semi_annual" => GroupedWithProratedMinimumCadence.SemiAnnual,
            "annual" => GroupedWithProratedMinimumCadence.Annual,
            "custom" => GroupedWithProratedMinimumCadence.Custom,
            _ => (GroupedWithProratedMinimumCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithProratedMinimumCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedWithProratedMinimumCadence.OneTime => "one_time",
                GroupedWithProratedMinimumCadence.Monthly => "monthly",
                GroupedWithProratedMinimumCadence.Quarterly => "quarterly",
                GroupedWithProratedMinimumCadence.SemiAnnual => "semi_annual",
                GroupedWithProratedMinimumCadence.Annual => "annual",
                GroupedWithProratedMinimumCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        GroupedWithProratedMinimumCompositePriceFilter,
        GroupedWithProratedMinimumCompositePriceFilterFromRaw
    >)
)]
public sealed record class GroupedWithProratedMinimumCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, GroupedWithProratedMinimumCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, GroupedWithProratedMinimumCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, GroupedWithProratedMinimumCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, GroupedWithProratedMinimumCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public GroupedWithProratedMinimumCompositePriceFilter() { }

    public GroupedWithProratedMinimumCompositePriceFilter(
        GroupedWithProratedMinimumCompositePriceFilter groupedWithProratedMinimumCompositePriceFilter
    )
        : base(groupedWithProratedMinimumCompositePriceFilter) { }

    public GroupedWithProratedMinimumCompositePriceFilter(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedWithProratedMinimumCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedWithProratedMinimumCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static GroupedWithProratedMinimumCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedWithProratedMinimumCompositePriceFilterFromRaw
    : IFromRawJson<GroupedWithProratedMinimumCompositePriceFilter>
{
    /// <inheritdoc/>
    public GroupedWithProratedMinimumCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedWithProratedMinimumCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(GroupedWithProratedMinimumCompositePriceFilterFieldConverter))]
public enum GroupedWithProratedMinimumCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class GroupedWithProratedMinimumCompositePriceFilterFieldConverter
    : JsonConverter<GroupedWithProratedMinimumCompositePriceFilterField>
{
    public override GroupedWithProratedMinimumCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => GroupedWithProratedMinimumCompositePriceFilterField.PriceID,
            "item_id" => GroupedWithProratedMinimumCompositePriceFilterField.ItemID,
            "price_type" => GroupedWithProratedMinimumCompositePriceFilterField.PriceType,
            "currency" => GroupedWithProratedMinimumCompositePriceFilterField.Currency,
            "pricing_unit_id" => GroupedWithProratedMinimumCompositePriceFilterField.PricingUnitID,
            _ => (GroupedWithProratedMinimumCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithProratedMinimumCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedWithProratedMinimumCompositePriceFilterField.PriceID => "price_id",
                GroupedWithProratedMinimumCompositePriceFilterField.ItemID => "item_id",
                GroupedWithProratedMinimumCompositePriceFilterField.PriceType => "price_type",
                GroupedWithProratedMinimumCompositePriceFilterField.Currency => "currency",
                GroupedWithProratedMinimumCompositePriceFilterField.PricingUnitID =>
                    "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(GroupedWithProratedMinimumCompositePriceFilterOperatorConverter))]
public enum GroupedWithProratedMinimumCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class GroupedWithProratedMinimumCompositePriceFilterOperatorConverter
    : JsonConverter<GroupedWithProratedMinimumCompositePriceFilterOperator>
{
    public override GroupedWithProratedMinimumCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => GroupedWithProratedMinimumCompositePriceFilterOperator.Includes,
            "excludes" => GroupedWithProratedMinimumCompositePriceFilterOperator.Excludes,
            _ => (GroupedWithProratedMinimumCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithProratedMinimumCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedWithProratedMinimumCompositePriceFilterOperator.Includes => "includes",
                GroupedWithProratedMinimumCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(GroupedWithProratedMinimumConversionRateConfigConverter))]
public record class GroupedWithProratedMinimumConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public GroupedWithProratedMinimumConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public GroupedWithProratedMinimumConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public GroupedWithProratedMinimumConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of GroupedWithProratedMinimumConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of GroupedWithProratedMinimumConversionRateConfig"
            ),
        };
    }

    public static implicit operator GroupedWithProratedMinimumConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator GroupedWithProratedMinimumConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of GroupedWithProratedMinimumConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(GroupedWithProratedMinimumConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class GroupedWithProratedMinimumConversionRateConfigConverter
    : JsonConverter<GroupedWithProratedMinimumConversionRateConfig>
{
    public override GroupedWithProratedMinimumConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new GroupedWithProratedMinimumConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithProratedMinimumConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

/// <summary>
/// Configuration for grouped_with_prorated_minimum pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        GroupedWithProratedMinimumGroupedWithProratedMinimumConfig,
        GroupedWithProratedMinimumGroupedWithProratedMinimumConfigFromRaw
    >)
)]
public sealed record class GroupedWithProratedMinimumGroupedWithProratedMinimumConfig : JsonModel
{
    /// <summary>
    /// How to determine the groups that should each have a minimum
    /// </summary>
    public required string GroupingKey
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "grouping_key"); }
        init { JsonModel.Set(this._rawData, "grouping_key", value); }
    }

    /// <summary>
    /// The minimum amount to charge per group
    /// </summary>
    public required string Minimum
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    /// <summary>
    /// The amount to charge per unit
    /// </summary>
    public required string UnitRate
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_rate"); }
        init { JsonModel.Set(this._rawData, "unit_rate", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.GroupingKey;
        _ = this.Minimum;
        _ = this.UnitRate;
    }

    public GroupedWithProratedMinimumGroupedWithProratedMinimumConfig() { }

    public GroupedWithProratedMinimumGroupedWithProratedMinimumConfig(
        GroupedWithProratedMinimumGroupedWithProratedMinimumConfig groupedWithProratedMinimumGroupedWithProratedMinimumConfig
    )
        : base(groupedWithProratedMinimumGroupedWithProratedMinimumConfig) { }

    public GroupedWithProratedMinimumGroupedWithProratedMinimumConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedWithProratedMinimumGroupedWithProratedMinimumConfig(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedWithProratedMinimumGroupedWithProratedMinimumConfigFromRaw.FromRawUnchecked"/>
    public static GroupedWithProratedMinimumGroupedWithProratedMinimumConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedWithProratedMinimumGroupedWithProratedMinimumConfigFromRaw
    : IFromRawJson<GroupedWithProratedMinimumGroupedWithProratedMinimumConfig>
{
    /// <inheritdoc/>
    public GroupedWithProratedMinimumGroupedWithProratedMinimumConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedWithProratedMinimumGroupedWithProratedMinimumConfig.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(GroupedWithProratedMinimumPriceTypeConverter))]
public enum GroupedWithProratedMinimumPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class GroupedWithProratedMinimumPriceTypeConverter
    : JsonConverter<GroupedWithProratedMinimumPriceType>
{
    public override GroupedWithProratedMinimumPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => GroupedWithProratedMinimumPriceType.UsagePrice,
            "fixed_price" => GroupedWithProratedMinimumPriceType.FixedPrice,
            "composite_price" => GroupedWithProratedMinimumPriceType.CompositePrice,
            _ => (GroupedWithProratedMinimumPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithProratedMinimumPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedWithProratedMinimumPriceType.UsagePrice => "usage_price",
                GroupedWithProratedMinimumPriceType.FixedPrice => "fixed_price",
                GroupedWithProratedMinimumPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<GroupedWithMeteredMinimum, GroupedWithMeteredMinimumFromRaw>)
)]
public sealed record class GroupedWithMeteredMinimum : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, GroupedWithMeteredMinimumBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedWithMeteredMinimumBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, GroupedWithMeteredMinimumCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedWithMeteredMinimumCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<GroupedWithMeteredMinimumCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<GroupedWithMeteredMinimumCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required GroupedWithMeteredMinimumConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<GroupedWithMeteredMinimumConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    /// <summary>
    /// Configuration for grouped_with_metered_minimum pricing
    /// </summary>
    public required GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfig GroupedWithMeteredMinimumConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfig>(
                this.RawData,
                "grouped_with_metered_minimum_config"
            );
        }
        init { JsonModel.Set(this._rawData, "grouped_with_metered_minimum_config", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, GroupedWithMeteredMinimumPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedWithMeteredMinimumPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.GroupedWithMeteredMinimumConfig.Validate();
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"grouped_with_metered_minimum\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedWithMeteredMinimum()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>(
            "\"grouped_with_metered_minimum\""
        );
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedWithMeteredMinimum(GroupedWithMeteredMinimum groupedWithMeteredMinimum)
        : base(groupedWithMeteredMinimum) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedWithMeteredMinimum(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>(
            "\"grouped_with_metered_minimum\""
        );
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    GroupedWithMeteredMinimum(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedWithMeteredMinimumFromRaw.FromRawUnchecked"/>
    public static GroupedWithMeteredMinimum FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedWithMeteredMinimumFromRaw : IFromRawJson<GroupedWithMeteredMinimum>
{
    /// <inheritdoc/>
    public GroupedWithMeteredMinimum FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedWithMeteredMinimum.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(GroupedWithMeteredMinimumBillingModeConverter))]
public enum GroupedWithMeteredMinimumBillingMode
{
    InAdvance,
    InArrear,
}

sealed class GroupedWithMeteredMinimumBillingModeConverter
    : JsonConverter<GroupedWithMeteredMinimumBillingMode>
{
    public override GroupedWithMeteredMinimumBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => GroupedWithMeteredMinimumBillingMode.InAdvance,
            "in_arrear" => GroupedWithMeteredMinimumBillingMode.InArrear,
            _ => (GroupedWithMeteredMinimumBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithMeteredMinimumBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedWithMeteredMinimumBillingMode.InAdvance => "in_advance",
                GroupedWithMeteredMinimumBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(GroupedWithMeteredMinimumCadenceConverter))]
public enum GroupedWithMeteredMinimumCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class GroupedWithMeteredMinimumCadenceConverter
    : JsonConverter<GroupedWithMeteredMinimumCadence>
{
    public override GroupedWithMeteredMinimumCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => GroupedWithMeteredMinimumCadence.OneTime,
            "monthly" => GroupedWithMeteredMinimumCadence.Monthly,
            "quarterly" => GroupedWithMeteredMinimumCadence.Quarterly,
            "semi_annual" => GroupedWithMeteredMinimumCadence.SemiAnnual,
            "annual" => GroupedWithMeteredMinimumCadence.Annual,
            "custom" => GroupedWithMeteredMinimumCadence.Custom,
            _ => (GroupedWithMeteredMinimumCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithMeteredMinimumCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedWithMeteredMinimumCadence.OneTime => "one_time",
                GroupedWithMeteredMinimumCadence.Monthly => "monthly",
                GroupedWithMeteredMinimumCadence.Quarterly => "quarterly",
                GroupedWithMeteredMinimumCadence.SemiAnnual => "semi_annual",
                GroupedWithMeteredMinimumCadence.Annual => "annual",
                GroupedWithMeteredMinimumCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        GroupedWithMeteredMinimumCompositePriceFilter,
        GroupedWithMeteredMinimumCompositePriceFilterFromRaw
    >)
)]
public sealed record class GroupedWithMeteredMinimumCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, GroupedWithMeteredMinimumCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, GroupedWithMeteredMinimumCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, GroupedWithMeteredMinimumCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, GroupedWithMeteredMinimumCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public GroupedWithMeteredMinimumCompositePriceFilter() { }

    public GroupedWithMeteredMinimumCompositePriceFilter(
        GroupedWithMeteredMinimumCompositePriceFilter groupedWithMeteredMinimumCompositePriceFilter
    )
        : base(groupedWithMeteredMinimumCompositePriceFilter) { }

    public GroupedWithMeteredMinimumCompositePriceFilter(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedWithMeteredMinimumCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedWithMeteredMinimumCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static GroupedWithMeteredMinimumCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedWithMeteredMinimumCompositePriceFilterFromRaw
    : IFromRawJson<GroupedWithMeteredMinimumCompositePriceFilter>
{
    /// <inheritdoc/>
    public GroupedWithMeteredMinimumCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedWithMeteredMinimumCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(GroupedWithMeteredMinimumCompositePriceFilterFieldConverter))]
public enum GroupedWithMeteredMinimumCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class GroupedWithMeteredMinimumCompositePriceFilterFieldConverter
    : JsonConverter<GroupedWithMeteredMinimumCompositePriceFilterField>
{
    public override GroupedWithMeteredMinimumCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => GroupedWithMeteredMinimumCompositePriceFilterField.PriceID,
            "item_id" => GroupedWithMeteredMinimumCompositePriceFilterField.ItemID,
            "price_type" => GroupedWithMeteredMinimumCompositePriceFilterField.PriceType,
            "currency" => GroupedWithMeteredMinimumCompositePriceFilterField.Currency,
            "pricing_unit_id" => GroupedWithMeteredMinimumCompositePriceFilterField.PricingUnitID,
            _ => (GroupedWithMeteredMinimumCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithMeteredMinimumCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedWithMeteredMinimumCompositePriceFilterField.PriceID => "price_id",
                GroupedWithMeteredMinimumCompositePriceFilterField.ItemID => "item_id",
                GroupedWithMeteredMinimumCompositePriceFilterField.PriceType => "price_type",
                GroupedWithMeteredMinimumCompositePriceFilterField.Currency => "currency",
                GroupedWithMeteredMinimumCompositePriceFilterField.PricingUnitID =>
                    "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(GroupedWithMeteredMinimumCompositePriceFilterOperatorConverter))]
public enum GroupedWithMeteredMinimumCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class GroupedWithMeteredMinimumCompositePriceFilterOperatorConverter
    : JsonConverter<GroupedWithMeteredMinimumCompositePriceFilterOperator>
{
    public override GroupedWithMeteredMinimumCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => GroupedWithMeteredMinimumCompositePriceFilterOperator.Includes,
            "excludes" => GroupedWithMeteredMinimumCompositePriceFilterOperator.Excludes,
            _ => (GroupedWithMeteredMinimumCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithMeteredMinimumCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedWithMeteredMinimumCompositePriceFilterOperator.Includes => "includes",
                GroupedWithMeteredMinimumCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(GroupedWithMeteredMinimumConversionRateConfigConverter))]
public record class GroupedWithMeteredMinimumConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public GroupedWithMeteredMinimumConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public GroupedWithMeteredMinimumConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public GroupedWithMeteredMinimumConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of GroupedWithMeteredMinimumConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of GroupedWithMeteredMinimumConversionRateConfig"
            ),
        };
    }

    public static implicit operator GroupedWithMeteredMinimumConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator GroupedWithMeteredMinimumConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of GroupedWithMeteredMinimumConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(GroupedWithMeteredMinimumConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class GroupedWithMeteredMinimumConversionRateConfigConverter
    : JsonConverter<GroupedWithMeteredMinimumConversionRateConfig>
{
    public override GroupedWithMeteredMinimumConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new GroupedWithMeteredMinimumConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithMeteredMinimumConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

/// <summary>
/// Configuration for grouped_with_metered_minimum pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfig,
        GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigFromRaw
    >)
)]
public sealed record class GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfig : JsonModel
{
    /// <summary>
    /// Used to partition the usage into groups. The minimum amount is applied to
    /// each group.
    /// </summary>
    public required string GroupingKey
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "grouping_key"); }
        init { JsonModel.Set(this._rawData, "grouping_key", value); }
    }

    /// <summary>
    /// The minimum amount to charge per group per unit
    /// </summary>
    public required string MinimumUnitAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "minimum_unit_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_unit_amount", value); }
    }

    /// <summary>
    /// Used to determine the unit rate
    /// </summary>
    public required string PricingKey
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "pricing_key"); }
        init { JsonModel.Set(this._rawData, "pricing_key", value); }
    }

    /// <summary>
    /// Scale the unit rates by the scaling factor.
    /// </summary>
    public required IReadOnlyList<GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactor> ScalingFactors
    {
        get
        {
            return JsonModel.GetNotNullClass<
                List<GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactor>
            >(this.RawData, "scaling_factors");
        }
        init { JsonModel.Set(this._rawData, "scaling_factors", value); }
    }

    /// <summary>
    /// Used to determine the unit rate scaling factor
    /// </summary>
    public required string ScalingKey
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "scaling_key"); }
        init { JsonModel.Set(this._rawData, "scaling_key", value); }
    }

    /// <summary>
    /// Apply per unit pricing to each pricing value. The minimum amount is applied
    /// any unmatched usage.
    /// </summary>
    public required IReadOnlyList<GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmount> UnitAmounts
    {
        get
        {
            return JsonModel.GetNotNullClass<
                List<GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmount>
            >(this.RawData, "unit_amounts");
        }
        init { JsonModel.Set(this._rawData, "unit_amounts", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.GroupingKey;
        _ = this.MinimumUnitAmount;
        _ = this.PricingKey;
        foreach (var item in this.ScalingFactors)
        {
            item.Validate();
        }
        _ = this.ScalingKey;
        foreach (var item in this.UnitAmounts)
        {
            item.Validate();
        }
    }

    public GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfig() { }

    public GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfig(
        GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfig groupedWithMeteredMinimumGroupedWithMeteredMinimumConfig
    )
        : base(groupedWithMeteredMinimumGroupedWithMeteredMinimumConfig) { }

    public GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfig(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigFromRaw.FromRawUnchecked"/>
    public static GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigFromRaw
    : IFromRawJson<GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfig>
{
    /// <inheritdoc/>
    public GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfig.FromRawUnchecked(rawData);
}

/// <summary>
/// Configuration for a scaling factor
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactor,
        GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactorFromRaw
    >)
)]
public sealed record class GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactor
    : JsonModel
{
    /// <summary>
    /// Scaling factor
    /// </summary>
    public required string ScalingFactor
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "scaling_factor"); }
        init { JsonModel.Set(this._rawData, "scaling_factor", value); }
    }

    /// <summary>
    /// Scaling value
    /// </summary>
    public required string ScalingValue
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "scaling_value"); }
        init { JsonModel.Set(this._rawData, "scaling_value", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ScalingFactor;
        _ = this.ScalingValue;
    }

    public GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactor() { }

    public GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactor(
        GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactor groupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactor
    )
        : base(groupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactor) { }

    public GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactor(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactor(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactorFromRaw.FromRawUnchecked"/>
    public static GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactor FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactorFromRaw
    : IFromRawJson<GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactor>
{
    /// <inheritdoc/>
    public GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactor FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) =>
        GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigScalingFactor.FromRawUnchecked(
            rawData
        );
}

/// <summary>
/// Configuration for a unit amount
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmount,
        GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmountFromRaw
    >)
)]
public sealed record class GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmount
    : JsonModel
{
    /// <summary>
    /// Pricing value
    /// </summary>
    public required string PricingValue
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "pricing_value"); }
        init { JsonModel.Set(this._rawData, "pricing_value", value); }
    }

    /// <summary>
    /// Per unit amount
    /// </summary>
    public required string UnitAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_amount"); }
        init { JsonModel.Set(this._rawData, "unit_amount", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.PricingValue;
        _ = this.UnitAmount;
    }

    public GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmount() { }

    public GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmount(
        GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmount groupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmount
    )
        : base(groupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmount) { }

    public GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmount(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmount(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmountFromRaw.FromRawUnchecked"/>
    public static GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmount FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmountFromRaw
    : IFromRawJson<GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmount>
{
    /// <inheritdoc/>
    public GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmount FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) =>
        GroupedWithMeteredMinimumGroupedWithMeteredMinimumConfigUnitAmount.FromRawUnchecked(
            rawData
        );
}

[JsonConverter(typeof(GroupedWithMeteredMinimumPriceTypeConverter))]
public enum GroupedWithMeteredMinimumPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class GroupedWithMeteredMinimumPriceTypeConverter
    : JsonConverter<GroupedWithMeteredMinimumPriceType>
{
    public override GroupedWithMeteredMinimumPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => GroupedWithMeteredMinimumPriceType.UsagePrice,
            "fixed_price" => GroupedWithMeteredMinimumPriceType.FixedPrice,
            "composite_price" => GroupedWithMeteredMinimumPriceType.CompositePrice,
            _ => (GroupedWithMeteredMinimumPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithMeteredMinimumPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedWithMeteredMinimumPriceType.UsagePrice => "usage_price",
                GroupedWithMeteredMinimumPriceType.FixedPrice => "fixed_price",
                GroupedWithMeteredMinimumPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<GroupedWithMinMaxThresholds, GroupedWithMinMaxThresholdsFromRaw>)
)]
public sealed record class GroupedWithMinMaxThresholds : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, GroupedWithMinMaxThresholdsBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, GroupedWithMinMaxThresholdsBillingMode>
            >(this.RawData, "billing_mode");
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, GroupedWithMinMaxThresholdsCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedWithMinMaxThresholdsCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<GroupedWithMinMaxThresholdsCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<
                List<GroupedWithMinMaxThresholdsCompositePriceFilter>
            >(this.RawData, "composite_price_filters");
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required GroupedWithMinMaxThresholdsConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<GroupedWithMinMaxThresholdsConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    /// <summary>
    /// Configuration for grouped_with_min_max_thresholds pricing
    /// </summary>
    public required GroupedWithMinMaxThresholdsConfig GroupedWithMinMaxThresholdsConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<GroupedWithMinMaxThresholdsConfig>(
                this.RawData,
                "grouped_with_min_max_thresholds_config"
            );
        }
        init { JsonModel.Set(this._rawData, "grouped_with_min_max_thresholds_config", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, GroupedWithMinMaxThresholdsPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedWithMinMaxThresholdsPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.GroupedWithMinMaxThresholdsConfig.Validate();
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"grouped_with_min_max_thresholds\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedWithMinMaxThresholds()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>(
            "\"grouped_with_min_max_thresholds\""
        );
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedWithMinMaxThresholds(GroupedWithMinMaxThresholds groupedWithMinMaxThresholds)
        : base(groupedWithMinMaxThresholds) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedWithMinMaxThresholds(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>(
            "\"grouped_with_min_max_thresholds\""
        );
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    GroupedWithMinMaxThresholds(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedWithMinMaxThresholdsFromRaw.FromRawUnchecked"/>
    public static GroupedWithMinMaxThresholds FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedWithMinMaxThresholdsFromRaw : IFromRawJson<GroupedWithMinMaxThresholds>
{
    /// <inheritdoc/>
    public GroupedWithMinMaxThresholds FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedWithMinMaxThresholds.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(GroupedWithMinMaxThresholdsBillingModeConverter))]
public enum GroupedWithMinMaxThresholdsBillingMode
{
    InAdvance,
    InArrear,
}

sealed class GroupedWithMinMaxThresholdsBillingModeConverter
    : JsonConverter<GroupedWithMinMaxThresholdsBillingMode>
{
    public override GroupedWithMinMaxThresholdsBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => GroupedWithMinMaxThresholdsBillingMode.InAdvance,
            "in_arrear" => GroupedWithMinMaxThresholdsBillingMode.InArrear,
            _ => (GroupedWithMinMaxThresholdsBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithMinMaxThresholdsBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedWithMinMaxThresholdsBillingMode.InAdvance => "in_advance",
                GroupedWithMinMaxThresholdsBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(GroupedWithMinMaxThresholdsCadenceConverter))]
public enum GroupedWithMinMaxThresholdsCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class GroupedWithMinMaxThresholdsCadenceConverter
    : JsonConverter<GroupedWithMinMaxThresholdsCadence>
{
    public override GroupedWithMinMaxThresholdsCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => GroupedWithMinMaxThresholdsCadence.OneTime,
            "monthly" => GroupedWithMinMaxThresholdsCadence.Monthly,
            "quarterly" => GroupedWithMinMaxThresholdsCadence.Quarterly,
            "semi_annual" => GroupedWithMinMaxThresholdsCadence.SemiAnnual,
            "annual" => GroupedWithMinMaxThresholdsCadence.Annual,
            "custom" => GroupedWithMinMaxThresholdsCadence.Custom,
            _ => (GroupedWithMinMaxThresholdsCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithMinMaxThresholdsCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedWithMinMaxThresholdsCadence.OneTime => "one_time",
                GroupedWithMinMaxThresholdsCadence.Monthly => "monthly",
                GroupedWithMinMaxThresholdsCadence.Quarterly => "quarterly",
                GroupedWithMinMaxThresholdsCadence.SemiAnnual => "semi_annual",
                GroupedWithMinMaxThresholdsCadence.Annual => "annual",
                GroupedWithMinMaxThresholdsCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        GroupedWithMinMaxThresholdsCompositePriceFilter,
        GroupedWithMinMaxThresholdsCompositePriceFilterFromRaw
    >)
)]
public sealed record class GroupedWithMinMaxThresholdsCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, GroupedWithMinMaxThresholdsCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, GroupedWithMinMaxThresholdsCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<
        string,
        GroupedWithMinMaxThresholdsCompositePriceFilterOperator
    > Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, GroupedWithMinMaxThresholdsCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public GroupedWithMinMaxThresholdsCompositePriceFilter() { }

    public GroupedWithMinMaxThresholdsCompositePriceFilter(
        GroupedWithMinMaxThresholdsCompositePriceFilter groupedWithMinMaxThresholdsCompositePriceFilter
    )
        : base(groupedWithMinMaxThresholdsCompositePriceFilter) { }

    public GroupedWithMinMaxThresholdsCompositePriceFilter(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedWithMinMaxThresholdsCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedWithMinMaxThresholdsCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static GroupedWithMinMaxThresholdsCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedWithMinMaxThresholdsCompositePriceFilterFromRaw
    : IFromRawJson<GroupedWithMinMaxThresholdsCompositePriceFilter>
{
    /// <inheritdoc/>
    public GroupedWithMinMaxThresholdsCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedWithMinMaxThresholdsCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(GroupedWithMinMaxThresholdsCompositePriceFilterFieldConverter))]
public enum GroupedWithMinMaxThresholdsCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class GroupedWithMinMaxThresholdsCompositePriceFilterFieldConverter
    : JsonConverter<GroupedWithMinMaxThresholdsCompositePriceFilterField>
{
    public override GroupedWithMinMaxThresholdsCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => GroupedWithMinMaxThresholdsCompositePriceFilterField.PriceID,
            "item_id" => GroupedWithMinMaxThresholdsCompositePriceFilterField.ItemID,
            "price_type" => GroupedWithMinMaxThresholdsCompositePriceFilterField.PriceType,
            "currency" => GroupedWithMinMaxThresholdsCompositePriceFilterField.Currency,
            "pricing_unit_id" => GroupedWithMinMaxThresholdsCompositePriceFilterField.PricingUnitID,
            _ => (GroupedWithMinMaxThresholdsCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithMinMaxThresholdsCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedWithMinMaxThresholdsCompositePriceFilterField.PriceID => "price_id",
                GroupedWithMinMaxThresholdsCompositePriceFilterField.ItemID => "item_id",
                GroupedWithMinMaxThresholdsCompositePriceFilterField.PriceType => "price_type",
                GroupedWithMinMaxThresholdsCompositePriceFilterField.Currency => "currency",
                GroupedWithMinMaxThresholdsCompositePriceFilterField.PricingUnitID =>
                    "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(GroupedWithMinMaxThresholdsCompositePriceFilterOperatorConverter))]
public enum GroupedWithMinMaxThresholdsCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class GroupedWithMinMaxThresholdsCompositePriceFilterOperatorConverter
    : JsonConverter<GroupedWithMinMaxThresholdsCompositePriceFilterOperator>
{
    public override GroupedWithMinMaxThresholdsCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => GroupedWithMinMaxThresholdsCompositePriceFilterOperator.Includes,
            "excludes" => GroupedWithMinMaxThresholdsCompositePriceFilterOperator.Excludes,
            _ => (GroupedWithMinMaxThresholdsCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithMinMaxThresholdsCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedWithMinMaxThresholdsCompositePriceFilterOperator.Includes => "includes",
                GroupedWithMinMaxThresholdsCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(GroupedWithMinMaxThresholdsConversionRateConfigConverter))]
public record class GroupedWithMinMaxThresholdsConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public GroupedWithMinMaxThresholdsConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public GroupedWithMinMaxThresholdsConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public GroupedWithMinMaxThresholdsConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of GroupedWithMinMaxThresholdsConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of GroupedWithMinMaxThresholdsConversionRateConfig"
            ),
        };
    }

    public static implicit operator GroupedWithMinMaxThresholdsConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator GroupedWithMinMaxThresholdsConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of GroupedWithMinMaxThresholdsConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(GroupedWithMinMaxThresholdsConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class GroupedWithMinMaxThresholdsConversionRateConfigConverter
    : JsonConverter<GroupedWithMinMaxThresholdsConversionRateConfig>
{
    public override GroupedWithMinMaxThresholdsConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new GroupedWithMinMaxThresholdsConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithMinMaxThresholdsConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

/// <summary>
/// Configuration for grouped_with_min_max_thresholds pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        GroupedWithMinMaxThresholdsConfig,
        GroupedWithMinMaxThresholdsConfigFromRaw
    >)
)]
public sealed record class GroupedWithMinMaxThresholdsConfig : JsonModel
{
    /// <summary>
    /// The event property used to group before applying thresholds
    /// </summary>
    public required string GroupingKey
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "grouping_key"); }
        init { JsonModel.Set(this._rawData, "grouping_key", value); }
    }

    /// <summary>
    /// The maximum amount to charge each group
    /// </summary>
    public required string MaximumCharge
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "maximum_charge"); }
        init { JsonModel.Set(this._rawData, "maximum_charge", value); }
    }

    /// <summary>
    /// The minimum amount to charge each group, regardless of usage
    /// </summary>
    public required string MinimumCharge
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "minimum_charge"); }
        init { JsonModel.Set(this._rawData, "minimum_charge", value); }
    }

    /// <summary>
    /// The base price charged per group
    /// </summary>
    public required string PerUnitRate
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "per_unit_rate"); }
        init { JsonModel.Set(this._rawData, "per_unit_rate", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.GroupingKey;
        _ = this.MaximumCharge;
        _ = this.MinimumCharge;
        _ = this.PerUnitRate;
    }

    public GroupedWithMinMaxThresholdsConfig() { }

    public GroupedWithMinMaxThresholdsConfig(
        GroupedWithMinMaxThresholdsConfig groupedWithMinMaxThresholdsConfig
    )
        : base(groupedWithMinMaxThresholdsConfig) { }

    public GroupedWithMinMaxThresholdsConfig(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedWithMinMaxThresholdsConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedWithMinMaxThresholdsConfigFromRaw.FromRawUnchecked"/>
    public static GroupedWithMinMaxThresholdsConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedWithMinMaxThresholdsConfigFromRaw : IFromRawJson<GroupedWithMinMaxThresholdsConfig>
{
    /// <inheritdoc/>
    public GroupedWithMinMaxThresholdsConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedWithMinMaxThresholdsConfig.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(GroupedWithMinMaxThresholdsPriceTypeConverter))]
public enum GroupedWithMinMaxThresholdsPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class GroupedWithMinMaxThresholdsPriceTypeConverter
    : JsonConverter<GroupedWithMinMaxThresholdsPriceType>
{
    public override GroupedWithMinMaxThresholdsPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => GroupedWithMinMaxThresholdsPriceType.UsagePrice,
            "fixed_price" => GroupedWithMinMaxThresholdsPriceType.FixedPrice,
            "composite_price" => GroupedWithMinMaxThresholdsPriceType.CompositePrice,
            _ => (GroupedWithMinMaxThresholdsPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedWithMinMaxThresholdsPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedWithMinMaxThresholdsPriceType.UsagePrice => "usage_price",
                GroupedWithMinMaxThresholdsPriceType.FixedPrice => "fixed_price",
                GroupedWithMinMaxThresholdsPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<MatrixWithDisplayName, MatrixWithDisplayNameFromRaw>))]
public sealed record class MatrixWithDisplayName : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, MatrixWithDisplayNameBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, MatrixWithDisplayNameBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, MatrixWithDisplayNameCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, MatrixWithDisplayNameCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<MatrixWithDisplayNameCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<MatrixWithDisplayNameCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required MatrixWithDisplayNameConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<MatrixWithDisplayNameConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    /// <summary>
    /// Configuration for matrix_with_display_name pricing
    /// </summary>
    public required MatrixWithDisplayNameMatrixWithDisplayNameConfig MatrixWithDisplayNameConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<MatrixWithDisplayNameMatrixWithDisplayNameConfig>(
                this.RawData,
                "matrix_with_display_name_config"
            );
        }
        init { JsonModel.Set(this._rawData, "matrix_with_display_name_config", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, MatrixWithDisplayNamePriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, MatrixWithDisplayNamePriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.MatrixWithDisplayNameConfig.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"matrix_with_display_name\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public MatrixWithDisplayName()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"matrix_with_display_name\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public MatrixWithDisplayName(MatrixWithDisplayName matrixWithDisplayName)
        : base(matrixWithDisplayName) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public MatrixWithDisplayName(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"matrix_with_display_name\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    MatrixWithDisplayName(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="MatrixWithDisplayNameFromRaw.FromRawUnchecked"/>
    public static MatrixWithDisplayName FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class MatrixWithDisplayNameFromRaw : IFromRawJson<MatrixWithDisplayName>
{
    /// <inheritdoc/>
    public MatrixWithDisplayName FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => MatrixWithDisplayName.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(MatrixWithDisplayNameBillingModeConverter))]
public enum MatrixWithDisplayNameBillingMode
{
    InAdvance,
    InArrear,
}

sealed class MatrixWithDisplayNameBillingModeConverter
    : JsonConverter<MatrixWithDisplayNameBillingMode>
{
    public override MatrixWithDisplayNameBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => MatrixWithDisplayNameBillingMode.InAdvance,
            "in_arrear" => MatrixWithDisplayNameBillingMode.InArrear,
            _ => (MatrixWithDisplayNameBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixWithDisplayNameBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MatrixWithDisplayNameBillingMode.InAdvance => "in_advance",
                MatrixWithDisplayNameBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(MatrixWithDisplayNameCadenceConverter))]
public enum MatrixWithDisplayNameCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class MatrixWithDisplayNameCadenceConverter : JsonConverter<MatrixWithDisplayNameCadence>
{
    public override MatrixWithDisplayNameCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => MatrixWithDisplayNameCadence.OneTime,
            "monthly" => MatrixWithDisplayNameCadence.Monthly,
            "quarterly" => MatrixWithDisplayNameCadence.Quarterly,
            "semi_annual" => MatrixWithDisplayNameCadence.SemiAnnual,
            "annual" => MatrixWithDisplayNameCadence.Annual,
            "custom" => MatrixWithDisplayNameCadence.Custom,
            _ => (MatrixWithDisplayNameCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixWithDisplayNameCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MatrixWithDisplayNameCadence.OneTime => "one_time",
                MatrixWithDisplayNameCadence.Monthly => "monthly",
                MatrixWithDisplayNameCadence.Quarterly => "quarterly",
                MatrixWithDisplayNameCadence.SemiAnnual => "semi_annual",
                MatrixWithDisplayNameCadence.Annual => "annual",
                MatrixWithDisplayNameCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        MatrixWithDisplayNameCompositePriceFilter,
        MatrixWithDisplayNameCompositePriceFilterFromRaw
    >)
)]
public sealed record class MatrixWithDisplayNameCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, MatrixWithDisplayNameCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, MatrixWithDisplayNameCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, MatrixWithDisplayNameCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, MatrixWithDisplayNameCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public MatrixWithDisplayNameCompositePriceFilter() { }

    public MatrixWithDisplayNameCompositePriceFilter(
        MatrixWithDisplayNameCompositePriceFilter matrixWithDisplayNameCompositePriceFilter
    )
        : base(matrixWithDisplayNameCompositePriceFilter) { }

    public MatrixWithDisplayNameCompositePriceFilter(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    MatrixWithDisplayNameCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="MatrixWithDisplayNameCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static MatrixWithDisplayNameCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class MatrixWithDisplayNameCompositePriceFilterFromRaw
    : IFromRawJson<MatrixWithDisplayNameCompositePriceFilter>
{
    /// <inheritdoc/>
    public MatrixWithDisplayNameCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => MatrixWithDisplayNameCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(MatrixWithDisplayNameCompositePriceFilterFieldConverter))]
public enum MatrixWithDisplayNameCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class MatrixWithDisplayNameCompositePriceFilterFieldConverter
    : JsonConverter<MatrixWithDisplayNameCompositePriceFilterField>
{
    public override MatrixWithDisplayNameCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => MatrixWithDisplayNameCompositePriceFilterField.PriceID,
            "item_id" => MatrixWithDisplayNameCompositePriceFilterField.ItemID,
            "price_type" => MatrixWithDisplayNameCompositePriceFilterField.PriceType,
            "currency" => MatrixWithDisplayNameCompositePriceFilterField.Currency,
            "pricing_unit_id" => MatrixWithDisplayNameCompositePriceFilterField.PricingUnitID,
            _ => (MatrixWithDisplayNameCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixWithDisplayNameCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MatrixWithDisplayNameCompositePriceFilterField.PriceID => "price_id",
                MatrixWithDisplayNameCompositePriceFilterField.ItemID => "item_id",
                MatrixWithDisplayNameCompositePriceFilterField.PriceType => "price_type",
                MatrixWithDisplayNameCompositePriceFilterField.Currency => "currency",
                MatrixWithDisplayNameCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(MatrixWithDisplayNameCompositePriceFilterOperatorConverter))]
public enum MatrixWithDisplayNameCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class MatrixWithDisplayNameCompositePriceFilterOperatorConverter
    : JsonConverter<MatrixWithDisplayNameCompositePriceFilterOperator>
{
    public override MatrixWithDisplayNameCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => MatrixWithDisplayNameCompositePriceFilterOperator.Includes,
            "excludes" => MatrixWithDisplayNameCompositePriceFilterOperator.Excludes,
            _ => (MatrixWithDisplayNameCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixWithDisplayNameCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MatrixWithDisplayNameCompositePriceFilterOperator.Includes => "includes",
                MatrixWithDisplayNameCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(MatrixWithDisplayNameConversionRateConfigConverter))]
public record class MatrixWithDisplayNameConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public MatrixWithDisplayNameConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public MatrixWithDisplayNameConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public MatrixWithDisplayNameConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of MatrixWithDisplayNameConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of MatrixWithDisplayNameConversionRateConfig"
            ),
        };
    }

    public static implicit operator MatrixWithDisplayNameConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator MatrixWithDisplayNameConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of MatrixWithDisplayNameConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(MatrixWithDisplayNameConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class MatrixWithDisplayNameConversionRateConfigConverter
    : JsonConverter<MatrixWithDisplayNameConversionRateConfig>
{
    public override MatrixWithDisplayNameConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new MatrixWithDisplayNameConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixWithDisplayNameConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

/// <summary>
/// Configuration for matrix_with_display_name pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        MatrixWithDisplayNameMatrixWithDisplayNameConfig,
        MatrixWithDisplayNameMatrixWithDisplayNameConfigFromRaw
    >)
)]
public sealed record class MatrixWithDisplayNameMatrixWithDisplayNameConfig : JsonModel
{
    /// <summary>
    /// Used to determine the unit rate
    /// </summary>
    public required string Dimension
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "dimension"); }
        init { JsonModel.Set(this._rawData, "dimension", value); }
    }

    /// <summary>
    /// Apply per unit pricing to each dimension value
    /// </summary>
    public required IReadOnlyList<MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmount> UnitAmounts
    {
        get
        {
            return JsonModel.GetNotNullClass<
                List<MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmount>
            >(this.RawData, "unit_amounts");
        }
        init { JsonModel.Set(this._rawData, "unit_amounts", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.Dimension;
        foreach (var item in this.UnitAmounts)
        {
            item.Validate();
        }
    }

    public MatrixWithDisplayNameMatrixWithDisplayNameConfig() { }

    public MatrixWithDisplayNameMatrixWithDisplayNameConfig(
        MatrixWithDisplayNameMatrixWithDisplayNameConfig matrixWithDisplayNameMatrixWithDisplayNameConfig
    )
        : base(matrixWithDisplayNameMatrixWithDisplayNameConfig) { }

    public MatrixWithDisplayNameMatrixWithDisplayNameConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    MatrixWithDisplayNameMatrixWithDisplayNameConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="MatrixWithDisplayNameMatrixWithDisplayNameConfigFromRaw.FromRawUnchecked"/>
    public static MatrixWithDisplayNameMatrixWithDisplayNameConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class MatrixWithDisplayNameMatrixWithDisplayNameConfigFromRaw
    : IFromRawJson<MatrixWithDisplayNameMatrixWithDisplayNameConfig>
{
    /// <inheritdoc/>
    public MatrixWithDisplayNameMatrixWithDisplayNameConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => MatrixWithDisplayNameMatrixWithDisplayNameConfig.FromRawUnchecked(rawData);
}

/// <summary>
/// Configuration for a unit amount item
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmount,
        MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmountFromRaw
    >)
)]
public sealed record class MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmount : JsonModel
{
    /// <summary>
    /// The dimension value
    /// </summary>
    public required string DimensionValue
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "dimension_value"); }
        init { JsonModel.Set(this._rawData, "dimension_value", value); }
    }

    /// <summary>
    /// Display name for this dimension value
    /// </summary>
    public required string DisplayName
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "display_name"); }
        init { JsonModel.Set(this._rawData, "display_name", value); }
    }

    /// <summary>
    /// Per unit amount
    /// </summary>
    public required string UnitAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_amount"); }
        init { JsonModel.Set(this._rawData, "unit_amount", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.DimensionValue;
        _ = this.DisplayName;
        _ = this.UnitAmount;
    }

    public MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmount() { }

    public MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmount(
        MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmount matrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmount
    )
        : base(matrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmount) { }

    public MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmount(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmount(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmountFromRaw.FromRawUnchecked"/>
    public static MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmount FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmountFromRaw
    : IFromRawJson<MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmount>
{
    /// <inheritdoc/>
    public MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmount FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => MatrixWithDisplayNameMatrixWithDisplayNameConfigUnitAmount.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(MatrixWithDisplayNamePriceTypeConverter))]
public enum MatrixWithDisplayNamePriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class MatrixWithDisplayNamePriceTypeConverter : JsonConverter<MatrixWithDisplayNamePriceType>
{
    public override MatrixWithDisplayNamePriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => MatrixWithDisplayNamePriceType.UsagePrice,
            "fixed_price" => MatrixWithDisplayNamePriceType.FixedPrice,
            "composite_price" => MatrixWithDisplayNamePriceType.CompositePrice,
            _ => (MatrixWithDisplayNamePriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MatrixWithDisplayNamePriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MatrixWithDisplayNamePriceType.UsagePrice => "usage_price",
                MatrixWithDisplayNamePriceType.FixedPrice => "fixed_price",
                MatrixWithDisplayNamePriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<GroupedTieredPackage, GroupedTieredPackageFromRaw>))]
public sealed record class GroupedTieredPackage : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, GroupedTieredPackageBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedTieredPackageBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, GroupedTieredPackageCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedTieredPackageCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<GroupedTieredPackageCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<GroupedTieredPackageCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required GroupedTieredPackageConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<GroupedTieredPackageConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    /// <summary>
    /// Configuration for grouped_tiered_package pricing
    /// </summary>
    public required GroupedTieredPackageGroupedTieredPackageConfig GroupedTieredPackageConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<GroupedTieredPackageGroupedTieredPackageConfig>(
                this.RawData,
                "grouped_tiered_package_config"
            );
        }
        init { JsonModel.Set(this._rawData, "grouped_tiered_package_config", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, GroupedTieredPackagePriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, GroupedTieredPackagePriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.GroupedTieredPackageConfig.Validate();
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"grouped_tiered_package\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedTieredPackage()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"grouped_tiered_package\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedTieredPackage(GroupedTieredPackage groupedTieredPackage)
        : base(groupedTieredPackage) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public GroupedTieredPackage(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"grouped_tiered_package\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    GroupedTieredPackage(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedTieredPackageFromRaw.FromRawUnchecked"/>
    public static GroupedTieredPackage FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedTieredPackageFromRaw : IFromRawJson<GroupedTieredPackage>
{
    /// <inheritdoc/>
    public GroupedTieredPackage FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedTieredPackage.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(GroupedTieredPackageBillingModeConverter))]
public enum GroupedTieredPackageBillingMode
{
    InAdvance,
    InArrear,
}

sealed class GroupedTieredPackageBillingModeConverter
    : JsonConverter<GroupedTieredPackageBillingMode>
{
    public override GroupedTieredPackageBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => GroupedTieredPackageBillingMode.InAdvance,
            "in_arrear" => GroupedTieredPackageBillingMode.InArrear,
            _ => (GroupedTieredPackageBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedTieredPackageBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedTieredPackageBillingMode.InAdvance => "in_advance",
                GroupedTieredPackageBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(GroupedTieredPackageCadenceConverter))]
public enum GroupedTieredPackageCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class GroupedTieredPackageCadenceConverter : JsonConverter<GroupedTieredPackageCadence>
{
    public override GroupedTieredPackageCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => GroupedTieredPackageCadence.OneTime,
            "monthly" => GroupedTieredPackageCadence.Monthly,
            "quarterly" => GroupedTieredPackageCadence.Quarterly,
            "semi_annual" => GroupedTieredPackageCadence.SemiAnnual,
            "annual" => GroupedTieredPackageCadence.Annual,
            "custom" => GroupedTieredPackageCadence.Custom,
            _ => (GroupedTieredPackageCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedTieredPackageCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedTieredPackageCadence.OneTime => "one_time",
                GroupedTieredPackageCadence.Monthly => "monthly",
                GroupedTieredPackageCadence.Quarterly => "quarterly",
                GroupedTieredPackageCadence.SemiAnnual => "semi_annual",
                GroupedTieredPackageCadence.Annual => "annual",
                GroupedTieredPackageCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        GroupedTieredPackageCompositePriceFilter,
        GroupedTieredPackageCompositePriceFilterFromRaw
    >)
)]
public sealed record class GroupedTieredPackageCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, GroupedTieredPackageCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, GroupedTieredPackageCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, GroupedTieredPackageCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, GroupedTieredPackageCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public GroupedTieredPackageCompositePriceFilter() { }

    public GroupedTieredPackageCompositePriceFilter(
        GroupedTieredPackageCompositePriceFilter groupedTieredPackageCompositePriceFilter
    )
        : base(groupedTieredPackageCompositePriceFilter) { }

    public GroupedTieredPackageCompositePriceFilter(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedTieredPackageCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedTieredPackageCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static GroupedTieredPackageCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedTieredPackageCompositePriceFilterFromRaw
    : IFromRawJson<GroupedTieredPackageCompositePriceFilter>
{
    /// <inheritdoc/>
    public GroupedTieredPackageCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedTieredPackageCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(GroupedTieredPackageCompositePriceFilterFieldConverter))]
public enum GroupedTieredPackageCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class GroupedTieredPackageCompositePriceFilterFieldConverter
    : JsonConverter<GroupedTieredPackageCompositePriceFilterField>
{
    public override GroupedTieredPackageCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => GroupedTieredPackageCompositePriceFilterField.PriceID,
            "item_id" => GroupedTieredPackageCompositePriceFilterField.ItemID,
            "price_type" => GroupedTieredPackageCompositePriceFilterField.PriceType,
            "currency" => GroupedTieredPackageCompositePriceFilterField.Currency,
            "pricing_unit_id" => GroupedTieredPackageCompositePriceFilterField.PricingUnitID,
            _ => (GroupedTieredPackageCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedTieredPackageCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedTieredPackageCompositePriceFilterField.PriceID => "price_id",
                GroupedTieredPackageCompositePriceFilterField.ItemID => "item_id",
                GroupedTieredPackageCompositePriceFilterField.PriceType => "price_type",
                GroupedTieredPackageCompositePriceFilterField.Currency => "currency",
                GroupedTieredPackageCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(GroupedTieredPackageCompositePriceFilterOperatorConverter))]
public enum GroupedTieredPackageCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class GroupedTieredPackageCompositePriceFilterOperatorConverter
    : JsonConverter<GroupedTieredPackageCompositePriceFilterOperator>
{
    public override GroupedTieredPackageCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => GroupedTieredPackageCompositePriceFilterOperator.Includes,
            "excludes" => GroupedTieredPackageCompositePriceFilterOperator.Excludes,
            _ => (GroupedTieredPackageCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedTieredPackageCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedTieredPackageCompositePriceFilterOperator.Includes => "includes",
                GroupedTieredPackageCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(GroupedTieredPackageConversionRateConfigConverter))]
public record class GroupedTieredPackageConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public GroupedTieredPackageConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public GroupedTieredPackageConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public GroupedTieredPackageConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of GroupedTieredPackageConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of GroupedTieredPackageConversionRateConfig"
            ),
        };
    }

    public static implicit operator GroupedTieredPackageConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator GroupedTieredPackageConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of GroupedTieredPackageConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(GroupedTieredPackageConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class GroupedTieredPackageConversionRateConfigConverter
    : JsonConverter<GroupedTieredPackageConversionRateConfig>
{
    public override GroupedTieredPackageConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new GroupedTieredPackageConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedTieredPackageConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

/// <summary>
/// Configuration for grouped_tiered_package pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        GroupedTieredPackageGroupedTieredPackageConfig,
        GroupedTieredPackageGroupedTieredPackageConfigFromRaw
    >)
)]
public sealed record class GroupedTieredPackageGroupedTieredPackageConfig : JsonModel
{
    /// <summary>
    /// The event property used to group before tiering
    /// </summary>
    public required string GroupingKey
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "grouping_key"); }
        init { JsonModel.Set(this._rawData, "grouping_key", value); }
    }

    /// <summary>
    /// Package size
    /// </summary>
    public required string PackageSize
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "package_size"); }
        init { JsonModel.Set(this._rawData, "package_size", value); }
    }

    /// <summary>
    /// Apply tiered pricing after rounding up the quantity to the package size.
    /// Tiers are defined using exclusive lower bounds.
    /// </summary>
    public required IReadOnlyList<GroupedTieredPackageGroupedTieredPackageConfigTier> Tiers
    {
        get
        {
            return JsonModel.GetNotNullClass<
                List<GroupedTieredPackageGroupedTieredPackageConfigTier>
            >(this.RawData, "tiers");
        }
        init { JsonModel.Set(this._rawData, "tiers", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.GroupingKey;
        _ = this.PackageSize;
        foreach (var item in this.Tiers)
        {
            item.Validate();
        }
    }

    public GroupedTieredPackageGroupedTieredPackageConfig() { }

    public GroupedTieredPackageGroupedTieredPackageConfig(
        GroupedTieredPackageGroupedTieredPackageConfig groupedTieredPackageGroupedTieredPackageConfig
    )
        : base(groupedTieredPackageGroupedTieredPackageConfig) { }

    public GroupedTieredPackageGroupedTieredPackageConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedTieredPackageGroupedTieredPackageConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedTieredPackageGroupedTieredPackageConfigFromRaw.FromRawUnchecked"/>
    public static GroupedTieredPackageGroupedTieredPackageConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedTieredPackageGroupedTieredPackageConfigFromRaw
    : IFromRawJson<GroupedTieredPackageGroupedTieredPackageConfig>
{
    /// <inheritdoc/>
    public GroupedTieredPackageGroupedTieredPackageConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedTieredPackageGroupedTieredPackageConfig.FromRawUnchecked(rawData);
}

/// <summary>
/// Configuration for a single tier
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        GroupedTieredPackageGroupedTieredPackageConfigTier,
        GroupedTieredPackageGroupedTieredPackageConfigTierFromRaw
    >)
)]
public sealed record class GroupedTieredPackageGroupedTieredPackageConfigTier : JsonModel
{
    /// <summary>
    /// Price per package
    /// </summary>
    public required string PerUnit
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "per_unit"); }
        init { JsonModel.Set(this._rawData, "per_unit", value); }
    }

    /// <summary>
    /// Tier lower bound
    /// </summary>
    public required string TierLowerBound
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "tier_lower_bound"); }
        init { JsonModel.Set(this._rawData, "tier_lower_bound", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.PerUnit;
        _ = this.TierLowerBound;
    }

    public GroupedTieredPackageGroupedTieredPackageConfigTier() { }

    public GroupedTieredPackageGroupedTieredPackageConfigTier(
        GroupedTieredPackageGroupedTieredPackageConfigTier groupedTieredPackageGroupedTieredPackageConfigTier
    )
        : base(groupedTieredPackageGroupedTieredPackageConfigTier) { }

    public GroupedTieredPackageGroupedTieredPackageConfigTier(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    GroupedTieredPackageGroupedTieredPackageConfigTier(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="GroupedTieredPackageGroupedTieredPackageConfigTierFromRaw.FromRawUnchecked"/>
    public static GroupedTieredPackageGroupedTieredPackageConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class GroupedTieredPackageGroupedTieredPackageConfigTierFromRaw
    : IFromRawJson<GroupedTieredPackageGroupedTieredPackageConfigTier>
{
    /// <inheritdoc/>
    public GroupedTieredPackageGroupedTieredPackageConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => GroupedTieredPackageGroupedTieredPackageConfigTier.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(GroupedTieredPackagePriceTypeConverter))]
public enum GroupedTieredPackagePriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class GroupedTieredPackagePriceTypeConverter : JsonConverter<GroupedTieredPackagePriceType>
{
    public override GroupedTieredPackagePriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => GroupedTieredPackagePriceType.UsagePrice,
            "fixed_price" => GroupedTieredPackagePriceType.FixedPrice,
            "composite_price" => GroupedTieredPackagePriceType.CompositePrice,
            _ => (GroupedTieredPackagePriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        GroupedTieredPackagePriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                GroupedTieredPackagePriceType.UsagePrice => "usage_price",
                GroupedTieredPackagePriceType.FixedPrice => "fixed_price",
                GroupedTieredPackagePriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<MaxGroupTieredPackage, MaxGroupTieredPackageFromRaw>))]
public sealed record class MaxGroupTieredPackage : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, MaxGroupTieredPackageBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, MaxGroupTieredPackageBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, MaxGroupTieredPackageCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, MaxGroupTieredPackageCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<MaxGroupTieredPackageCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<MaxGroupTieredPackageCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required MaxGroupTieredPackageConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<MaxGroupTieredPackageConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    /// <summary>
    /// Configuration for max_group_tiered_package pricing
    /// </summary>
    public required MaxGroupTieredPackageMaxGroupTieredPackageConfig MaxGroupTieredPackageConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<MaxGroupTieredPackageMaxGroupTieredPackageConfig>(
                this.RawData,
                "max_group_tiered_package_config"
            );
        }
        init { JsonModel.Set(this._rawData, "max_group_tiered_package_config", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, MaxGroupTieredPackagePriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, MaxGroupTieredPackagePriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.MaxGroupTieredPackageConfig.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"max_group_tiered_package\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public MaxGroupTieredPackage()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"max_group_tiered_package\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public MaxGroupTieredPackage(MaxGroupTieredPackage maxGroupTieredPackage)
        : base(maxGroupTieredPackage) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public MaxGroupTieredPackage(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"max_group_tiered_package\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    MaxGroupTieredPackage(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="MaxGroupTieredPackageFromRaw.FromRawUnchecked"/>
    public static MaxGroupTieredPackage FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class MaxGroupTieredPackageFromRaw : IFromRawJson<MaxGroupTieredPackage>
{
    /// <inheritdoc/>
    public MaxGroupTieredPackage FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => MaxGroupTieredPackage.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(MaxGroupTieredPackageBillingModeConverter))]
public enum MaxGroupTieredPackageBillingMode
{
    InAdvance,
    InArrear,
}

sealed class MaxGroupTieredPackageBillingModeConverter
    : JsonConverter<MaxGroupTieredPackageBillingMode>
{
    public override MaxGroupTieredPackageBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => MaxGroupTieredPackageBillingMode.InAdvance,
            "in_arrear" => MaxGroupTieredPackageBillingMode.InArrear,
            _ => (MaxGroupTieredPackageBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MaxGroupTieredPackageBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MaxGroupTieredPackageBillingMode.InAdvance => "in_advance",
                MaxGroupTieredPackageBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(MaxGroupTieredPackageCadenceConverter))]
public enum MaxGroupTieredPackageCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class MaxGroupTieredPackageCadenceConverter : JsonConverter<MaxGroupTieredPackageCadence>
{
    public override MaxGroupTieredPackageCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => MaxGroupTieredPackageCadence.OneTime,
            "monthly" => MaxGroupTieredPackageCadence.Monthly,
            "quarterly" => MaxGroupTieredPackageCadence.Quarterly,
            "semi_annual" => MaxGroupTieredPackageCadence.SemiAnnual,
            "annual" => MaxGroupTieredPackageCadence.Annual,
            "custom" => MaxGroupTieredPackageCadence.Custom,
            _ => (MaxGroupTieredPackageCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MaxGroupTieredPackageCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MaxGroupTieredPackageCadence.OneTime => "one_time",
                MaxGroupTieredPackageCadence.Monthly => "monthly",
                MaxGroupTieredPackageCadence.Quarterly => "quarterly",
                MaxGroupTieredPackageCadence.SemiAnnual => "semi_annual",
                MaxGroupTieredPackageCadence.Annual => "annual",
                MaxGroupTieredPackageCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        MaxGroupTieredPackageCompositePriceFilter,
        MaxGroupTieredPackageCompositePriceFilterFromRaw
    >)
)]
public sealed record class MaxGroupTieredPackageCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, MaxGroupTieredPackageCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, MaxGroupTieredPackageCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, MaxGroupTieredPackageCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, MaxGroupTieredPackageCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public MaxGroupTieredPackageCompositePriceFilter() { }

    public MaxGroupTieredPackageCompositePriceFilter(
        MaxGroupTieredPackageCompositePriceFilter maxGroupTieredPackageCompositePriceFilter
    )
        : base(maxGroupTieredPackageCompositePriceFilter) { }

    public MaxGroupTieredPackageCompositePriceFilter(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    MaxGroupTieredPackageCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="MaxGroupTieredPackageCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static MaxGroupTieredPackageCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class MaxGroupTieredPackageCompositePriceFilterFromRaw
    : IFromRawJson<MaxGroupTieredPackageCompositePriceFilter>
{
    /// <inheritdoc/>
    public MaxGroupTieredPackageCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => MaxGroupTieredPackageCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(MaxGroupTieredPackageCompositePriceFilterFieldConverter))]
public enum MaxGroupTieredPackageCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class MaxGroupTieredPackageCompositePriceFilterFieldConverter
    : JsonConverter<MaxGroupTieredPackageCompositePriceFilterField>
{
    public override MaxGroupTieredPackageCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => MaxGroupTieredPackageCompositePriceFilterField.PriceID,
            "item_id" => MaxGroupTieredPackageCompositePriceFilterField.ItemID,
            "price_type" => MaxGroupTieredPackageCompositePriceFilterField.PriceType,
            "currency" => MaxGroupTieredPackageCompositePriceFilterField.Currency,
            "pricing_unit_id" => MaxGroupTieredPackageCompositePriceFilterField.PricingUnitID,
            _ => (MaxGroupTieredPackageCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MaxGroupTieredPackageCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MaxGroupTieredPackageCompositePriceFilterField.PriceID => "price_id",
                MaxGroupTieredPackageCompositePriceFilterField.ItemID => "item_id",
                MaxGroupTieredPackageCompositePriceFilterField.PriceType => "price_type",
                MaxGroupTieredPackageCompositePriceFilterField.Currency => "currency",
                MaxGroupTieredPackageCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(MaxGroupTieredPackageCompositePriceFilterOperatorConverter))]
public enum MaxGroupTieredPackageCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class MaxGroupTieredPackageCompositePriceFilterOperatorConverter
    : JsonConverter<MaxGroupTieredPackageCompositePriceFilterOperator>
{
    public override MaxGroupTieredPackageCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => MaxGroupTieredPackageCompositePriceFilterOperator.Includes,
            "excludes" => MaxGroupTieredPackageCompositePriceFilterOperator.Excludes,
            _ => (MaxGroupTieredPackageCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MaxGroupTieredPackageCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MaxGroupTieredPackageCompositePriceFilterOperator.Includes => "includes",
                MaxGroupTieredPackageCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(MaxGroupTieredPackageConversionRateConfigConverter))]
public record class MaxGroupTieredPackageConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public MaxGroupTieredPackageConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public MaxGroupTieredPackageConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public MaxGroupTieredPackageConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of MaxGroupTieredPackageConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of MaxGroupTieredPackageConversionRateConfig"
            ),
        };
    }

    public static implicit operator MaxGroupTieredPackageConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator MaxGroupTieredPackageConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of MaxGroupTieredPackageConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(MaxGroupTieredPackageConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class MaxGroupTieredPackageConversionRateConfigConverter
    : JsonConverter<MaxGroupTieredPackageConversionRateConfig>
{
    public override MaxGroupTieredPackageConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new MaxGroupTieredPackageConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        MaxGroupTieredPackageConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

/// <summary>
/// Configuration for max_group_tiered_package pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        MaxGroupTieredPackageMaxGroupTieredPackageConfig,
        MaxGroupTieredPackageMaxGroupTieredPackageConfigFromRaw
    >)
)]
public sealed record class MaxGroupTieredPackageMaxGroupTieredPackageConfig : JsonModel
{
    /// <summary>
    /// The event property used to group before tiering the group with the highest value
    /// </summary>
    public required string GroupingKey
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "grouping_key"); }
        init { JsonModel.Set(this._rawData, "grouping_key", value); }
    }

    /// <summary>
    /// Package size
    /// </summary>
    public required string PackageSize
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "package_size"); }
        init { JsonModel.Set(this._rawData, "package_size", value); }
    }

    /// <summary>
    /// Apply tiered pricing to the largest group after grouping with the provided key.
    /// </summary>
    public required IReadOnlyList<MaxGroupTieredPackageMaxGroupTieredPackageConfigTier> Tiers
    {
        get
        {
            return JsonModel.GetNotNullClass<
                List<MaxGroupTieredPackageMaxGroupTieredPackageConfigTier>
            >(this.RawData, "tiers");
        }
        init { JsonModel.Set(this._rawData, "tiers", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.GroupingKey;
        _ = this.PackageSize;
        foreach (var item in this.Tiers)
        {
            item.Validate();
        }
    }

    public MaxGroupTieredPackageMaxGroupTieredPackageConfig() { }

    public MaxGroupTieredPackageMaxGroupTieredPackageConfig(
        MaxGroupTieredPackageMaxGroupTieredPackageConfig maxGroupTieredPackageMaxGroupTieredPackageConfig
    )
        : base(maxGroupTieredPackageMaxGroupTieredPackageConfig) { }

    public MaxGroupTieredPackageMaxGroupTieredPackageConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    MaxGroupTieredPackageMaxGroupTieredPackageConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="MaxGroupTieredPackageMaxGroupTieredPackageConfigFromRaw.FromRawUnchecked"/>
    public static MaxGroupTieredPackageMaxGroupTieredPackageConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class MaxGroupTieredPackageMaxGroupTieredPackageConfigFromRaw
    : IFromRawJson<MaxGroupTieredPackageMaxGroupTieredPackageConfig>
{
    /// <inheritdoc/>
    public MaxGroupTieredPackageMaxGroupTieredPackageConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => MaxGroupTieredPackageMaxGroupTieredPackageConfig.FromRawUnchecked(rawData);
}

/// <summary>
/// Configuration for a single tier
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        MaxGroupTieredPackageMaxGroupTieredPackageConfigTier,
        MaxGroupTieredPackageMaxGroupTieredPackageConfigTierFromRaw
    >)
)]
public sealed record class MaxGroupTieredPackageMaxGroupTieredPackageConfigTier : JsonModel
{
    /// <summary>
    /// Tier lower bound
    /// </summary>
    public required string TierLowerBound
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "tier_lower_bound"); }
        init { JsonModel.Set(this._rawData, "tier_lower_bound", value); }
    }

    /// <summary>
    /// Per unit amount
    /// </summary>
    public required string UnitAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_amount"); }
        init { JsonModel.Set(this._rawData, "unit_amount", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.TierLowerBound;
        _ = this.UnitAmount;
    }

    public MaxGroupTieredPackageMaxGroupTieredPackageConfigTier() { }

    public MaxGroupTieredPackageMaxGroupTieredPackageConfigTier(
        MaxGroupTieredPackageMaxGroupTieredPackageConfigTier maxGroupTieredPackageMaxGroupTieredPackageConfigTier
    )
        : base(maxGroupTieredPackageMaxGroupTieredPackageConfigTier) { }

    public MaxGroupTieredPackageMaxGroupTieredPackageConfigTier(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    MaxGroupTieredPackageMaxGroupTieredPackageConfigTier(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="MaxGroupTieredPackageMaxGroupTieredPackageConfigTierFromRaw.FromRawUnchecked"/>
    public static MaxGroupTieredPackageMaxGroupTieredPackageConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class MaxGroupTieredPackageMaxGroupTieredPackageConfigTierFromRaw
    : IFromRawJson<MaxGroupTieredPackageMaxGroupTieredPackageConfigTier>
{
    /// <inheritdoc/>
    public MaxGroupTieredPackageMaxGroupTieredPackageConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => MaxGroupTieredPackageMaxGroupTieredPackageConfigTier.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(MaxGroupTieredPackagePriceTypeConverter))]
public enum MaxGroupTieredPackagePriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class MaxGroupTieredPackagePriceTypeConverter : JsonConverter<MaxGroupTieredPackagePriceType>
{
    public override MaxGroupTieredPackagePriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => MaxGroupTieredPackagePriceType.UsagePrice,
            "fixed_price" => MaxGroupTieredPackagePriceType.FixedPrice,
            "composite_price" => MaxGroupTieredPackagePriceType.CompositePrice,
            _ => (MaxGroupTieredPackagePriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        MaxGroupTieredPackagePriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                MaxGroupTieredPackagePriceType.UsagePrice => "usage_price",
                MaxGroupTieredPackagePriceType.FixedPrice => "fixed_price",
                MaxGroupTieredPackagePriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<ScalableMatrixWithUnitPricing, ScalableMatrixWithUnitPricingFromRaw>)
)]
public sealed record class ScalableMatrixWithUnitPricing : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, ScalableMatrixWithUnitPricingBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, ScalableMatrixWithUnitPricingBillingMode>
            >(this.RawData, "billing_mode");
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, ScalableMatrixWithUnitPricingCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, ScalableMatrixWithUnitPricingCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<ScalableMatrixWithUnitPricingCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<
                List<ScalableMatrixWithUnitPricingCompositePriceFilter>
            >(this.RawData, "composite_price_filters");
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required ScalableMatrixWithUnitPricingConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<ScalableMatrixWithUnitPricingConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, ScalableMatrixWithUnitPricingPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, ScalableMatrixWithUnitPricingPriceType>
            >(this.RawData, "price_type");
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    /// <summary>
    /// Configuration for scalable_matrix_with_unit_pricing pricing
    /// </summary>
    public required ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfig ScalableMatrixWithUnitPricingConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfig>(
                this.RawData,
                "scalable_matrix_with_unit_pricing_config"
            );
        }
        init { JsonModel.Set(this._rawData, "scalable_matrix_with_unit_pricing_config", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"scalable_matrix_with_unit_pricing\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.ScalableMatrixWithUnitPricingConfig.Validate();
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public ScalableMatrixWithUnitPricing()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>(
            "\"scalable_matrix_with_unit_pricing\""
        );
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public ScalableMatrixWithUnitPricing(
        ScalableMatrixWithUnitPricing scalableMatrixWithUnitPricing
    )
        : base(scalableMatrixWithUnitPricing) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public ScalableMatrixWithUnitPricing(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>(
            "\"scalable_matrix_with_unit_pricing\""
        );
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    ScalableMatrixWithUnitPricing(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="ScalableMatrixWithUnitPricingFromRaw.FromRawUnchecked"/>
    public static ScalableMatrixWithUnitPricing FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class ScalableMatrixWithUnitPricingFromRaw : IFromRawJson<ScalableMatrixWithUnitPricing>
{
    /// <inheritdoc/>
    public ScalableMatrixWithUnitPricing FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => ScalableMatrixWithUnitPricing.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(ScalableMatrixWithUnitPricingBillingModeConverter))]
public enum ScalableMatrixWithUnitPricingBillingMode
{
    InAdvance,
    InArrear,
}

sealed class ScalableMatrixWithUnitPricingBillingModeConverter
    : JsonConverter<ScalableMatrixWithUnitPricingBillingMode>
{
    public override ScalableMatrixWithUnitPricingBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => ScalableMatrixWithUnitPricingBillingMode.InAdvance,
            "in_arrear" => ScalableMatrixWithUnitPricingBillingMode.InArrear,
            _ => (ScalableMatrixWithUnitPricingBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        ScalableMatrixWithUnitPricingBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                ScalableMatrixWithUnitPricingBillingMode.InAdvance => "in_advance",
                ScalableMatrixWithUnitPricingBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(ScalableMatrixWithUnitPricingCadenceConverter))]
public enum ScalableMatrixWithUnitPricingCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class ScalableMatrixWithUnitPricingCadenceConverter
    : JsonConverter<ScalableMatrixWithUnitPricingCadence>
{
    public override ScalableMatrixWithUnitPricingCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => ScalableMatrixWithUnitPricingCadence.OneTime,
            "monthly" => ScalableMatrixWithUnitPricingCadence.Monthly,
            "quarterly" => ScalableMatrixWithUnitPricingCadence.Quarterly,
            "semi_annual" => ScalableMatrixWithUnitPricingCadence.SemiAnnual,
            "annual" => ScalableMatrixWithUnitPricingCadence.Annual,
            "custom" => ScalableMatrixWithUnitPricingCadence.Custom,
            _ => (ScalableMatrixWithUnitPricingCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        ScalableMatrixWithUnitPricingCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                ScalableMatrixWithUnitPricingCadence.OneTime => "one_time",
                ScalableMatrixWithUnitPricingCadence.Monthly => "monthly",
                ScalableMatrixWithUnitPricingCadence.Quarterly => "quarterly",
                ScalableMatrixWithUnitPricingCadence.SemiAnnual => "semi_annual",
                ScalableMatrixWithUnitPricingCadence.Annual => "annual",
                ScalableMatrixWithUnitPricingCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        ScalableMatrixWithUnitPricingCompositePriceFilter,
        ScalableMatrixWithUnitPricingCompositePriceFilterFromRaw
    >)
)]
public sealed record class ScalableMatrixWithUnitPricingCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, ScalableMatrixWithUnitPricingCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, ScalableMatrixWithUnitPricingCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<
        string,
        ScalableMatrixWithUnitPricingCompositePriceFilterOperator
    > Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, ScalableMatrixWithUnitPricingCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public ScalableMatrixWithUnitPricingCompositePriceFilter() { }

    public ScalableMatrixWithUnitPricingCompositePriceFilter(
        ScalableMatrixWithUnitPricingCompositePriceFilter scalableMatrixWithUnitPricingCompositePriceFilter
    )
        : base(scalableMatrixWithUnitPricingCompositePriceFilter) { }

    public ScalableMatrixWithUnitPricingCompositePriceFilter(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    ScalableMatrixWithUnitPricingCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="ScalableMatrixWithUnitPricingCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static ScalableMatrixWithUnitPricingCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class ScalableMatrixWithUnitPricingCompositePriceFilterFromRaw
    : IFromRawJson<ScalableMatrixWithUnitPricingCompositePriceFilter>
{
    /// <inheritdoc/>
    public ScalableMatrixWithUnitPricingCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => ScalableMatrixWithUnitPricingCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(ScalableMatrixWithUnitPricingCompositePriceFilterFieldConverter))]
public enum ScalableMatrixWithUnitPricingCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class ScalableMatrixWithUnitPricingCompositePriceFilterFieldConverter
    : JsonConverter<ScalableMatrixWithUnitPricingCompositePriceFilterField>
{
    public override ScalableMatrixWithUnitPricingCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => ScalableMatrixWithUnitPricingCompositePriceFilterField.PriceID,
            "item_id" => ScalableMatrixWithUnitPricingCompositePriceFilterField.ItemID,
            "price_type" => ScalableMatrixWithUnitPricingCompositePriceFilterField.PriceType,
            "currency" => ScalableMatrixWithUnitPricingCompositePriceFilterField.Currency,
            "pricing_unit_id" =>
                ScalableMatrixWithUnitPricingCompositePriceFilterField.PricingUnitID,
            _ => (ScalableMatrixWithUnitPricingCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        ScalableMatrixWithUnitPricingCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                ScalableMatrixWithUnitPricingCompositePriceFilterField.PriceID => "price_id",
                ScalableMatrixWithUnitPricingCompositePriceFilterField.ItemID => "item_id",
                ScalableMatrixWithUnitPricingCompositePriceFilterField.PriceType => "price_type",
                ScalableMatrixWithUnitPricingCompositePriceFilterField.Currency => "currency",
                ScalableMatrixWithUnitPricingCompositePriceFilterField.PricingUnitID =>
                    "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(ScalableMatrixWithUnitPricingCompositePriceFilterOperatorConverter))]
public enum ScalableMatrixWithUnitPricingCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class ScalableMatrixWithUnitPricingCompositePriceFilterOperatorConverter
    : JsonConverter<ScalableMatrixWithUnitPricingCompositePriceFilterOperator>
{
    public override ScalableMatrixWithUnitPricingCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => ScalableMatrixWithUnitPricingCompositePriceFilterOperator.Includes,
            "excludes" => ScalableMatrixWithUnitPricingCompositePriceFilterOperator.Excludes,
            _ => (ScalableMatrixWithUnitPricingCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        ScalableMatrixWithUnitPricingCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                ScalableMatrixWithUnitPricingCompositePriceFilterOperator.Includes => "includes",
                ScalableMatrixWithUnitPricingCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(ScalableMatrixWithUnitPricingConversionRateConfigConverter))]
public record class ScalableMatrixWithUnitPricingConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public ScalableMatrixWithUnitPricingConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public ScalableMatrixWithUnitPricingConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public ScalableMatrixWithUnitPricingConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of ScalableMatrixWithUnitPricingConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of ScalableMatrixWithUnitPricingConversionRateConfig"
            ),
        };
    }

    public static implicit operator ScalableMatrixWithUnitPricingConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator ScalableMatrixWithUnitPricingConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of ScalableMatrixWithUnitPricingConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(ScalableMatrixWithUnitPricingConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class ScalableMatrixWithUnitPricingConversionRateConfigConverter
    : JsonConverter<ScalableMatrixWithUnitPricingConversionRateConfig>
{
    public override ScalableMatrixWithUnitPricingConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new ScalableMatrixWithUnitPricingConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        ScalableMatrixWithUnitPricingConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(ScalableMatrixWithUnitPricingPriceTypeConverter))]
public enum ScalableMatrixWithUnitPricingPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class ScalableMatrixWithUnitPricingPriceTypeConverter
    : JsonConverter<ScalableMatrixWithUnitPricingPriceType>
{
    public override ScalableMatrixWithUnitPricingPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => ScalableMatrixWithUnitPricingPriceType.UsagePrice,
            "fixed_price" => ScalableMatrixWithUnitPricingPriceType.FixedPrice,
            "composite_price" => ScalableMatrixWithUnitPricingPriceType.CompositePrice,
            _ => (ScalableMatrixWithUnitPricingPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        ScalableMatrixWithUnitPricingPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                ScalableMatrixWithUnitPricingPriceType.UsagePrice => "usage_price",
                ScalableMatrixWithUnitPricingPriceType.FixedPrice => "fixed_price",
                ScalableMatrixWithUnitPricingPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Configuration for scalable_matrix_with_unit_pricing pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfig,
        ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigFromRaw
    >)
)]
public sealed record class ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfig
    : JsonModel
{
    /// <summary>
    /// Used to determine the unit rate
    /// </summary>
    public required string FirstDimension
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "first_dimension"); }
        init { JsonModel.Set(this._rawData, "first_dimension", value); }
    }

    /// <summary>
    /// Apply a scaling factor to each dimension
    /// </summary>
    public required IReadOnlyList<ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactor> MatrixScalingFactors
    {
        get
        {
            return JsonModel.GetNotNullClass<
                List<ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactor>
            >(this.RawData, "matrix_scaling_factors");
        }
        init { JsonModel.Set(this._rawData, "matrix_scaling_factors", value); }
    }

    /// <summary>
    /// The final unit price to rate against the output of the matrix
    /// </summary>
    public required string UnitPrice
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_price"); }
        init { JsonModel.Set(this._rawData, "unit_price", value); }
    }

    /// <summary>
    /// If true, the unit price will be prorated to the billing period
    /// </summary>
    public bool? Prorate
    {
        get { return JsonModel.GetNullableStruct<bool>(this.RawData, "prorate"); }
        init { JsonModel.Set(this._rawData, "prorate", value); }
    }

    /// <summary>
    /// Used to determine the unit rate (optional)
    /// </summary>
    public string? SecondDimension
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "second_dimension"); }
        init { JsonModel.Set(this._rawData, "second_dimension", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.FirstDimension;
        foreach (var item in this.MatrixScalingFactors)
        {
            item.Validate();
        }
        _ = this.UnitPrice;
        _ = this.Prorate;
        _ = this.SecondDimension;
    }

    public ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfig() { }

    public ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfig(
        ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfig scalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfig
    )
        : base(scalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfig) { }

    public ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfig(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigFromRaw.FromRawUnchecked"/>
    public static ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigFromRaw
    : IFromRawJson<ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfig>
{
    /// <inheritdoc/>
    public ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfig.FromRawUnchecked(rawData);
}

/// <summary>
/// Configuration for a single matrix scaling factor
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactor,
        ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactorFromRaw
    >)
)]
public sealed record class ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactor
    : JsonModel
{
    /// <summary>
    /// First dimension value
    /// </summary>
    public required string FirstDimensionValue
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "first_dimension_value"); }
        init { JsonModel.Set(this._rawData, "first_dimension_value", value); }
    }

    /// <summary>
    /// Scaling factor
    /// </summary>
    public required string ScalingFactor
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "scaling_factor"); }
        init { JsonModel.Set(this._rawData, "scaling_factor", value); }
    }

    /// <summary>
    /// Second dimension value (optional)
    /// </summary>
    public string? SecondDimensionValue
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "second_dimension_value"); }
        init { JsonModel.Set(this._rawData, "second_dimension_value", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.FirstDimensionValue;
        _ = this.ScalingFactor;
        _ = this.SecondDimensionValue;
    }

    public ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactor() { }

    public ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactor(
        ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactor scalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactor
    )
        : base(scalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactor)
    { }

    public ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactor(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactor(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactorFromRaw.FromRawUnchecked"/>
    public static ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactor FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactorFromRaw
    : IFromRawJson<ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactor>
{
    /// <inheritdoc/>
    public ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactor FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) =>
        ScalableMatrixWithUnitPricingScalableMatrixWithUnitPricingConfigMatrixScalingFactor.FromRawUnchecked(
            rawData
        );
}

[JsonConverter(
    typeof(JsonModelConverter<
        ScalableMatrixWithTieredPricing,
        ScalableMatrixWithTieredPricingFromRaw
    >)
)]
public sealed record class ScalableMatrixWithTieredPricing : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, ScalableMatrixWithTieredPricingBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, ScalableMatrixWithTieredPricingBillingMode>
            >(this.RawData, "billing_mode");
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, ScalableMatrixWithTieredPricingCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, ScalableMatrixWithTieredPricingCadence>
            >(this.RawData, "cadence");
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<ScalableMatrixWithTieredPricingCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<
                List<ScalableMatrixWithTieredPricingCompositePriceFilter>
            >(this.RawData, "composite_price_filters");
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required ScalableMatrixWithTieredPricingConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<ScalableMatrixWithTieredPricingConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, ScalableMatrixWithTieredPricingPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, ScalableMatrixWithTieredPricingPriceType>
            >(this.RawData, "price_type");
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    /// <summary>
    /// Configuration for scalable_matrix_with_tiered_pricing pricing
    /// </summary>
    public required ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfig ScalableMatrixWithTieredPricingConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfig>(
                this.RawData,
                "scalable_matrix_with_tiered_pricing_config"
            );
        }
        init { JsonModel.Set(this._rawData, "scalable_matrix_with_tiered_pricing_config", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"scalable_matrix_with_tiered_pricing\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.ScalableMatrixWithTieredPricingConfig.Validate();
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public ScalableMatrixWithTieredPricing()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>(
            "\"scalable_matrix_with_tiered_pricing\""
        );
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public ScalableMatrixWithTieredPricing(
        ScalableMatrixWithTieredPricing scalableMatrixWithTieredPricing
    )
        : base(scalableMatrixWithTieredPricing) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public ScalableMatrixWithTieredPricing(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>(
            "\"scalable_matrix_with_tiered_pricing\""
        );
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    ScalableMatrixWithTieredPricing(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="ScalableMatrixWithTieredPricingFromRaw.FromRawUnchecked"/>
    public static ScalableMatrixWithTieredPricing FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class ScalableMatrixWithTieredPricingFromRaw : IFromRawJson<ScalableMatrixWithTieredPricing>
{
    /// <inheritdoc/>
    public ScalableMatrixWithTieredPricing FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => ScalableMatrixWithTieredPricing.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(ScalableMatrixWithTieredPricingBillingModeConverter))]
public enum ScalableMatrixWithTieredPricingBillingMode
{
    InAdvance,
    InArrear,
}

sealed class ScalableMatrixWithTieredPricingBillingModeConverter
    : JsonConverter<ScalableMatrixWithTieredPricingBillingMode>
{
    public override ScalableMatrixWithTieredPricingBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => ScalableMatrixWithTieredPricingBillingMode.InAdvance,
            "in_arrear" => ScalableMatrixWithTieredPricingBillingMode.InArrear,
            _ => (ScalableMatrixWithTieredPricingBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        ScalableMatrixWithTieredPricingBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                ScalableMatrixWithTieredPricingBillingMode.InAdvance => "in_advance",
                ScalableMatrixWithTieredPricingBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(ScalableMatrixWithTieredPricingCadenceConverter))]
public enum ScalableMatrixWithTieredPricingCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class ScalableMatrixWithTieredPricingCadenceConverter
    : JsonConverter<ScalableMatrixWithTieredPricingCadence>
{
    public override ScalableMatrixWithTieredPricingCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => ScalableMatrixWithTieredPricingCadence.OneTime,
            "monthly" => ScalableMatrixWithTieredPricingCadence.Monthly,
            "quarterly" => ScalableMatrixWithTieredPricingCadence.Quarterly,
            "semi_annual" => ScalableMatrixWithTieredPricingCadence.SemiAnnual,
            "annual" => ScalableMatrixWithTieredPricingCadence.Annual,
            "custom" => ScalableMatrixWithTieredPricingCadence.Custom,
            _ => (ScalableMatrixWithTieredPricingCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        ScalableMatrixWithTieredPricingCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                ScalableMatrixWithTieredPricingCadence.OneTime => "one_time",
                ScalableMatrixWithTieredPricingCadence.Monthly => "monthly",
                ScalableMatrixWithTieredPricingCadence.Quarterly => "quarterly",
                ScalableMatrixWithTieredPricingCadence.SemiAnnual => "semi_annual",
                ScalableMatrixWithTieredPricingCadence.Annual => "annual",
                ScalableMatrixWithTieredPricingCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        ScalableMatrixWithTieredPricingCompositePriceFilter,
        ScalableMatrixWithTieredPricingCompositePriceFilterFromRaw
    >)
)]
public sealed record class ScalableMatrixWithTieredPricingCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, ScalableMatrixWithTieredPricingCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, ScalableMatrixWithTieredPricingCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<
        string,
        ScalableMatrixWithTieredPricingCompositePriceFilterOperator
    > Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, ScalableMatrixWithTieredPricingCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public ScalableMatrixWithTieredPricingCompositePriceFilter() { }

    public ScalableMatrixWithTieredPricingCompositePriceFilter(
        ScalableMatrixWithTieredPricingCompositePriceFilter scalableMatrixWithTieredPricingCompositePriceFilter
    )
        : base(scalableMatrixWithTieredPricingCompositePriceFilter) { }

    public ScalableMatrixWithTieredPricingCompositePriceFilter(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    ScalableMatrixWithTieredPricingCompositePriceFilter(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="ScalableMatrixWithTieredPricingCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static ScalableMatrixWithTieredPricingCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class ScalableMatrixWithTieredPricingCompositePriceFilterFromRaw
    : IFromRawJson<ScalableMatrixWithTieredPricingCompositePriceFilter>
{
    /// <inheritdoc/>
    public ScalableMatrixWithTieredPricingCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => ScalableMatrixWithTieredPricingCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(ScalableMatrixWithTieredPricingCompositePriceFilterFieldConverter))]
public enum ScalableMatrixWithTieredPricingCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class ScalableMatrixWithTieredPricingCompositePriceFilterFieldConverter
    : JsonConverter<ScalableMatrixWithTieredPricingCompositePriceFilterField>
{
    public override ScalableMatrixWithTieredPricingCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => ScalableMatrixWithTieredPricingCompositePriceFilterField.PriceID,
            "item_id" => ScalableMatrixWithTieredPricingCompositePriceFilterField.ItemID,
            "price_type" => ScalableMatrixWithTieredPricingCompositePriceFilterField.PriceType,
            "currency" => ScalableMatrixWithTieredPricingCompositePriceFilterField.Currency,
            "pricing_unit_id" =>
                ScalableMatrixWithTieredPricingCompositePriceFilterField.PricingUnitID,
            _ => (ScalableMatrixWithTieredPricingCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        ScalableMatrixWithTieredPricingCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                ScalableMatrixWithTieredPricingCompositePriceFilterField.PriceID => "price_id",
                ScalableMatrixWithTieredPricingCompositePriceFilterField.ItemID => "item_id",
                ScalableMatrixWithTieredPricingCompositePriceFilterField.PriceType => "price_type",
                ScalableMatrixWithTieredPricingCompositePriceFilterField.Currency => "currency",
                ScalableMatrixWithTieredPricingCompositePriceFilterField.PricingUnitID =>
                    "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(ScalableMatrixWithTieredPricingCompositePriceFilterOperatorConverter))]
public enum ScalableMatrixWithTieredPricingCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class ScalableMatrixWithTieredPricingCompositePriceFilterOperatorConverter
    : JsonConverter<ScalableMatrixWithTieredPricingCompositePriceFilterOperator>
{
    public override ScalableMatrixWithTieredPricingCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => ScalableMatrixWithTieredPricingCompositePriceFilterOperator.Includes,
            "excludes" => ScalableMatrixWithTieredPricingCompositePriceFilterOperator.Excludes,
            _ => (ScalableMatrixWithTieredPricingCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        ScalableMatrixWithTieredPricingCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                ScalableMatrixWithTieredPricingCompositePriceFilterOperator.Includes => "includes",
                ScalableMatrixWithTieredPricingCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(ScalableMatrixWithTieredPricingConversionRateConfigConverter))]
public record class ScalableMatrixWithTieredPricingConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public ScalableMatrixWithTieredPricingConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public ScalableMatrixWithTieredPricingConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public ScalableMatrixWithTieredPricingConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of ScalableMatrixWithTieredPricingConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of ScalableMatrixWithTieredPricingConversionRateConfig"
            ),
        };
    }

    public static implicit operator ScalableMatrixWithTieredPricingConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator ScalableMatrixWithTieredPricingConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of ScalableMatrixWithTieredPricingConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(ScalableMatrixWithTieredPricingConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class ScalableMatrixWithTieredPricingConversionRateConfigConverter
    : JsonConverter<ScalableMatrixWithTieredPricingConversionRateConfig>
{
    public override ScalableMatrixWithTieredPricingConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new ScalableMatrixWithTieredPricingConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        ScalableMatrixWithTieredPricingConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

[JsonConverter(typeof(ScalableMatrixWithTieredPricingPriceTypeConverter))]
public enum ScalableMatrixWithTieredPricingPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class ScalableMatrixWithTieredPricingPriceTypeConverter
    : JsonConverter<ScalableMatrixWithTieredPricingPriceType>
{
    public override ScalableMatrixWithTieredPricingPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => ScalableMatrixWithTieredPricingPriceType.UsagePrice,
            "fixed_price" => ScalableMatrixWithTieredPricingPriceType.FixedPrice,
            "composite_price" => ScalableMatrixWithTieredPricingPriceType.CompositePrice,
            _ => (ScalableMatrixWithTieredPricingPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        ScalableMatrixWithTieredPricingPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                ScalableMatrixWithTieredPricingPriceType.UsagePrice => "usage_price",
                ScalableMatrixWithTieredPricingPriceType.FixedPrice => "fixed_price",
                ScalableMatrixWithTieredPricingPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Configuration for scalable_matrix_with_tiered_pricing pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfig,
        ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigFromRaw
    >)
)]
public sealed record class ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfig
    : JsonModel
{
    /// <summary>
    /// Used for the scalable matrix first dimension
    /// </summary>
    public required string FirstDimension
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "first_dimension"); }
        init { JsonModel.Set(this._rawData, "first_dimension", value); }
    }

    /// <summary>
    /// Apply a scaling factor to each dimension
    /// </summary>
    public required IReadOnlyList<ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactor> MatrixScalingFactors
    {
        get
        {
            return JsonModel.GetNotNullClass<
                List<ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactor>
            >(this.RawData, "matrix_scaling_factors");
        }
        init { JsonModel.Set(this._rawData, "matrix_scaling_factors", value); }
    }

    /// <summary>
    /// Tier pricing structure
    /// </summary>
    public required IReadOnlyList<ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTier> Tiers
    {
        get
        {
            return JsonModel.GetNotNullClass<
                List<ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTier>
            >(this.RawData, "tiers");
        }
        init { JsonModel.Set(this._rawData, "tiers", value); }
    }

    /// <summary>
    /// Used for the scalable matrix second dimension (optional)
    /// </summary>
    public string? SecondDimension
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "second_dimension"); }
        init { JsonModel.Set(this._rawData, "second_dimension", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.FirstDimension;
        foreach (var item in this.MatrixScalingFactors)
        {
            item.Validate();
        }
        foreach (var item in this.Tiers)
        {
            item.Validate();
        }
        _ = this.SecondDimension;
    }

    public ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfig() { }

    public ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfig(
        ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfig scalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfig
    )
        : base(scalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfig) { }

    public ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfig(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigFromRaw.FromRawUnchecked"/>
    public static ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigFromRaw
    : IFromRawJson<ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfig>
{
    /// <inheritdoc/>
    public ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) =>
        ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfig.FromRawUnchecked(
            rawData
        );
}

/// <summary>
/// Configuration for a single matrix scaling factor
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactor,
        ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactorFromRaw
    >)
)]
public sealed record class ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactor
    : JsonModel
{
    /// <summary>
    /// First dimension value
    /// </summary>
    public required string FirstDimensionValue
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "first_dimension_value"); }
        init { JsonModel.Set(this._rawData, "first_dimension_value", value); }
    }

    /// <summary>
    /// Scaling factor
    /// </summary>
    public required string ScalingFactor
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "scaling_factor"); }
        init { JsonModel.Set(this._rawData, "scaling_factor", value); }
    }

    /// <summary>
    /// Second dimension value (optional)
    /// </summary>
    public string? SecondDimensionValue
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "second_dimension_value"); }
        init { JsonModel.Set(this._rawData, "second_dimension_value", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.FirstDimensionValue;
        _ = this.ScalingFactor;
        _ = this.SecondDimensionValue;
    }

    public ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactor()
    { }

    public ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactor(
        ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactor scalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactor
    )
        : base(
            scalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactor
        ) { }

    public ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactor(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactor(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactorFromRaw.FromRawUnchecked"/>
    public static ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactor FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactorFromRaw
    : IFromRawJson<ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactor>
{
    /// <inheritdoc/>
    public ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactor FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) =>
        ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigMatrixScalingFactor.FromRawUnchecked(
            rawData
        );
}

/// <summary>
/// Configuration for a single tier entry with business logic
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTier,
        ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTierFromRaw
    >)
)]
public sealed record class ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTier
    : JsonModel
{
    /// <summary>
    /// Tier lower bound
    /// </summary>
    public required string TierLowerBound
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "tier_lower_bound"); }
        init { JsonModel.Set(this._rawData, "tier_lower_bound", value); }
    }

    /// <summary>
    /// Per unit amount
    /// </summary>
    public required string UnitAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_amount"); }
        init { JsonModel.Set(this._rawData, "unit_amount", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.TierLowerBound;
        _ = this.UnitAmount;
    }

    public ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTier() { }

    public ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTier(
        ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTier scalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTier
    )
        : base(scalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTier) { }

    public ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTier(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTier(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTierFromRaw.FromRawUnchecked"/>
    public static ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTierFromRaw
    : IFromRawJson<ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTier>
{
    /// <inheritdoc/>
    public ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTier FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) =>
        ScalableMatrixWithTieredPricingScalableMatrixWithTieredPricingConfigTier.FromRawUnchecked(
            rawData
        );
}

[JsonConverter(typeof(JsonModelConverter<CumulativeGroupedBulk, CumulativeGroupedBulkFromRaw>))]
public sealed record class CumulativeGroupedBulk : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, CumulativeGroupedBulkBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, CumulativeGroupedBulkBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, CumulativeGroupedBulkCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, CumulativeGroupedBulkCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<CumulativeGroupedBulkCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<CumulativeGroupedBulkCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required CumulativeGroupedBulkConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<CumulativeGroupedBulkConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    /// <summary>
    /// Configuration for cumulative_grouped_bulk pricing
    /// </summary>
    public required CumulativeGroupedBulkCumulativeGroupedBulkConfig CumulativeGroupedBulkConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<CumulativeGroupedBulkCumulativeGroupedBulkConfig>(
                this.RawData,
                "cumulative_grouped_bulk_config"
            );
        }
        init { JsonModel.Set(this._rawData, "cumulative_grouped_bulk_config", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, CumulativeGroupedBulkPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, CumulativeGroupedBulkPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        this.CumulativeGroupedBulkConfig.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"cumulative_grouped_bulk\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public CumulativeGroupedBulk()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"cumulative_grouped_bulk\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public CumulativeGroupedBulk(CumulativeGroupedBulk cumulativeGroupedBulk)
        : base(cumulativeGroupedBulk) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public CumulativeGroupedBulk(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"cumulative_grouped_bulk\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    CumulativeGroupedBulk(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="CumulativeGroupedBulkFromRaw.FromRawUnchecked"/>
    public static CumulativeGroupedBulk FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class CumulativeGroupedBulkFromRaw : IFromRawJson<CumulativeGroupedBulk>
{
    /// <inheritdoc/>
    public CumulativeGroupedBulk FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => CumulativeGroupedBulk.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(CumulativeGroupedBulkBillingModeConverter))]
public enum CumulativeGroupedBulkBillingMode
{
    InAdvance,
    InArrear,
}

sealed class CumulativeGroupedBulkBillingModeConverter
    : JsonConverter<CumulativeGroupedBulkBillingMode>
{
    public override CumulativeGroupedBulkBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => CumulativeGroupedBulkBillingMode.InAdvance,
            "in_arrear" => CumulativeGroupedBulkBillingMode.InArrear,
            _ => (CumulativeGroupedBulkBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        CumulativeGroupedBulkBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                CumulativeGroupedBulkBillingMode.InAdvance => "in_advance",
                CumulativeGroupedBulkBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(CumulativeGroupedBulkCadenceConverter))]
public enum CumulativeGroupedBulkCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class CumulativeGroupedBulkCadenceConverter : JsonConverter<CumulativeGroupedBulkCadence>
{
    public override CumulativeGroupedBulkCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => CumulativeGroupedBulkCadence.OneTime,
            "monthly" => CumulativeGroupedBulkCadence.Monthly,
            "quarterly" => CumulativeGroupedBulkCadence.Quarterly,
            "semi_annual" => CumulativeGroupedBulkCadence.SemiAnnual,
            "annual" => CumulativeGroupedBulkCadence.Annual,
            "custom" => CumulativeGroupedBulkCadence.Custom,
            _ => (CumulativeGroupedBulkCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        CumulativeGroupedBulkCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                CumulativeGroupedBulkCadence.OneTime => "one_time",
                CumulativeGroupedBulkCadence.Monthly => "monthly",
                CumulativeGroupedBulkCadence.Quarterly => "quarterly",
                CumulativeGroupedBulkCadence.SemiAnnual => "semi_annual",
                CumulativeGroupedBulkCadence.Annual => "annual",
                CumulativeGroupedBulkCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        CumulativeGroupedBulkCompositePriceFilter,
        CumulativeGroupedBulkCompositePriceFilterFromRaw
    >)
)]
public sealed record class CumulativeGroupedBulkCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, CumulativeGroupedBulkCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, CumulativeGroupedBulkCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, CumulativeGroupedBulkCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, CumulativeGroupedBulkCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public CumulativeGroupedBulkCompositePriceFilter() { }

    public CumulativeGroupedBulkCompositePriceFilter(
        CumulativeGroupedBulkCompositePriceFilter cumulativeGroupedBulkCompositePriceFilter
    )
        : base(cumulativeGroupedBulkCompositePriceFilter) { }

    public CumulativeGroupedBulkCompositePriceFilter(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    CumulativeGroupedBulkCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="CumulativeGroupedBulkCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static CumulativeGroupedBulkCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class CumulativeGroupedBulkCompositePriceFilterFromRaw
    : IFromRawJson<CumulativeGroupedBulkCompositePriceFilter>
{
    /// <inheritdoc/>
    public CumulativeGroupedBulkCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => CumulativeGroupedBulkCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(CumulativeGroupedBulkCompositePriceFilterFieldConverter))]
public enum CumulativeGroupedBulkCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class CumulativeGroupedBulkCompositePriceFilterFieldConverter
    : JsonConverter<CumulativeGroupedBulkCompositePriceFilterField>
{
    public override CumulativeGroupedBulkCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => CumulativeGroupedBulkCompositePriceFilterField.PriceID,
            "item_id" => CumulativeGroupedBulkCompositePriceFilterField.ItemID,
            "price_type" => CumulativeGroupedBulkCompositePriceFilterField.PriceType,
            "currency" => CumulativeGroupedBulkCompositePriceFilterField.Currency,
            "pricing_unit_id" => CumulativeGroupedBulkCompositePriceFilterField.PricingUnitID,
            _ => (CumulativeGroupedBulkCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        CumulativeGroupedBulkCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                CumulativeGroupedBulkCompositePriceFilterField.PriceID => "price_id",
                CumulativeGroupedBulkCompositePriceFilterField.ItemID => "item_id",
                CumulativeGroupedBulkCompositePriceFilterField.PriceType => "price_type",
                CumulativeGroupedBulkCompositePriceFilterField.Currency => "currency",
                CumulativeGroupedBulkCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(CumulativeGroupedBulkCompositePriceFilterOperatorConverter))]
public enum CumulativeGroupedBulkCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class CumulativeGroupedBulkCompositePriceFilterOperatorConverter
    : JsonConverter<CumulativeGroupedBulkCompositePriceFilterOperator>
{
    public override CumulativeGroupedBulkCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => CumulativeGroupedBulkCompositePriceFilterOperator.Includes,
            "excludes" => CumulativeGroupedBulkCompositePriceFilterOperator.Excludes,
            _ => (CumulativeGroupedBulkCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        CumulativeGroupedBulkCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                CumulativeGroupedBulkCompositePriceFilterOperator.Includes => "includes",
                CumulativeGroupedBulkCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(CumulativeGroupedBulkConversionRateConfigConverter))]
public record class CumulativeGroupedBulkConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public CumulativeGroupedBulkConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public CumulativeGroupedBulkConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public CumulativeGroupedBulkConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of CumulativeGroupedBulkConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of CumulativeGroupedBulkConversionRateConfig"
            ),
        };
    }

    public static implicit operator CumulativeGroupedBulkConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator CumulativeGroupedBulkConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of CumulativeGroupedBulkConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(CumulativeGroupedBulkConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class CumulativeGroupedBulkConversionRateConfigConverter
    : JsonConverter<CumulativeGroupedBulkConversionRateConfig>
{
    public override CumulativeGroupedBulkConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new CumulativeGroupedBulkConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        CumulativeGroupedBulkConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

/// <summary>
/// Configuration for cumulative_grouped_bulk pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        CumulativeGroupedBulkCumulativeGroupedBulkConfig,
        CumulativeGroupedBulkCumulativeGroupedBulkConfigFromRaw
    >)
)]
public sealed record class CumulativeGroupedBulkCumulativeGroupedBulkConfig : JsonModel
{
    /// <summary>
    /// Each tier lower bound must have the same group of values.
    /// </summary>
    public required IReadOnlyList<CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValue> DimensionValues
    {
        get
        {
            return JsonModel.GetNotNullClass<
                List<CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValue>
            >(this.RawData, "dimension_values");
        }
        init { JsonModel.Set(this._rawData, "dimension_values", value); }
    }

    /// <summary>
    /// Grouping key name
    /// </summary>
    public required string Group
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "group"); }
        init { JsonModel.Set(this._rawData, "group", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        foreach (var item in this.DimensionValues)
        {
            item.Validate();
        }
        _ = this.Group;
    }

    public CumulativeGroupedBulkCumulativeGroupedBulkConfig() { }

    public CumulativeGroupedBulkCumulativeGroupedBulkConfig(
        CumulativeGroupedBulkCumulativeGroupedBulkConfig cumulativeGroupedBulkCumulativeGroupedBulkConfig
    )
        : base(cumulativeGroupedBulkCumulativeGroupedBulkConfig) { }

    public CumulativeGroupedBulkCumulativeGroupedBulkConfig(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    CumulativeGroupedBulkCumulativeGroupedBulkConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="CumulativeGroupedBulkCumulativeGroupedBulkConfigFromRaw.FromRawUnchecked"/>
    public static CumulativeGroupedBulkCumulativeGroupedBulkConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class CumulativeGroupedBulkCumulativeGroupedBulkConfigFromRaw
    : IFromRawJson<CumulativeGroupedBulkCumulativeGroupedBulkConfig>
{
    /// <inheritdoc/>
    public CumulativeGroupedBulkCumulativeGroupedBulkConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => CumulativeGroupedBulkCumulativeGroupedBulkConfig.FromRawUnchecked(rawData);
}

/// <summary>
/// Configuration for a dimension value entry
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValue,
        CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValueFromRaw
    >)
)]
public sealed record class CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValue
    : JsonModel
{
    /// <summary>
    /// Grouping key value
    /// </summary>
    public required string GroupingKey
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "grouping_key"); }
        init { JsonModel.Set(this._rawData, "grouping_key", value); }
    }

    /// <summary>
    /// Tier lower bound
    /// </summary>
    public required string TierLowerBound
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "tier_lower_bound"); }
        init { JsonModel.Set(this._rawData, "tier_lower_bound", value); }
    }

    /// <summary>
    /// Unit amount for this combination
    /// </summary>
    public required string UnitAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_amount"); }
        init { JsonModel.Set(this._rawData, "unit_amount", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.GroupingKey;
        _ = this.TierLowerBound;
        _ = this.UnitAmount;
    }

    public CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValue() { }

    public CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValue(
        CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValue cumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValue
    )
        : base(cumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValue) { }

    public CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValue(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValue(
        FrozenDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValueFromRaw.FromRawUnchecked"/>
    public static CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValue FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValueFromRaw
    : IFromRawJson<CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValue>
{
    /// <inheritdoc/>
    public CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValue FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => CumulativeGroupedBulkCumulativeGroupedBulkConfigDimensionValue.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(CumulativeGroupedBulkPriceTypeConverter))]
public enum CumulativeGroupedBulkPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class CumulativeGroupedBulkPriceTypeConverter : JsonConverter<CumulativeGroupedBulkPriceType>
{
    public override CumulativeGroupedBulkPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => CumulativeGroupedBulkPriceType.UsagePrice,
            "fixed_price" => CumulativeGroupedBulkPriceType.FixedPrice,
            "composite_price" => CumulativeGroupedBulkPriceType.CompositePrice,
            _ => (CumulativeGroupedBulkPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        CumulativeGroupedBulkPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                CumulativeGroupedBulkPriceType.UsagePrice => "usage_price",
                CumulativeGroupedBulkPriceType.FixedPrice => "fixed_price",
                CumulativeGroupedBulkPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<CumulativeGroupedAllocation, CumulativeGroupedAllocationFromRaw>)
)]
public sealed record class CumulativeGroupedAllocation : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, CumulativeGroupedAllocationBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, CumulativeGroupedAllocationBillingMode>
            >(this.RawData, "billing_mode");
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, CumulativeGroupedAllocationCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, CumulativeGroupedAllocationCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<CumulativeGroupedAllocationCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<
                List<CumulativeGroupedAllocationCompositePriceFilter>
            >(this.RawData, "composite_price_filters");
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required CumulativeGroupedAllocationConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<CumulativeGroupedAllocationConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    /// <summary>
    /// Configuration for cumulative_grouped_allocation pricing
    /// </summary>
    public required CumulativeGroupedAllocationConfig CumulativeGroupedAllocationConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<CumulativeGroupedAllocationConfig>(
                this.RawData,
                "cumulative_grouped_allocation_config"
            );
        }
        init { JsonModel.Set(this._rawData, "cumulative_grouped_allocation_config", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, CumulativeGroupedAllocationPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, CumulativeGroupedAllocationPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        this.CumulativeGroupedAllocationConfig.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"cumulative_grouped_allocation\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public CumulativeGroupedAllocation()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>(
            "\"cumulative_grouped_allocation\""
        );
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public CumulativeGroupedAllocation(CumulativeGroupedAllocation cumulativeGroupedAllocation)
        : base(cumulativeGroupedAllocation) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public CumulativeGroupedAllocation(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>(
            "\"cumulative_grouped_allocation\""
        );
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    CumulativeGroupedAllocation(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="CumulativeGroupedAllocationFromRaw.FromRawUnchecked"/>
    public static CumulativeGroupedAllocation FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class CumulativeGroupedAllocationFromRaw : IFromRawJson<CumulativeGroupedAllocation>
{
    /// <inheritdoc/>
    public CumulativeGroupedAllocation FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => CumulativeGroupedAllocation.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(CumulativeGroupedAllocationBillingModeConverter))]
public enum CumulativeGroupedAllocationBillingMode
{
    InAdvance,
    InArrear,
}

sealed class CumulativeGroupedAllocationBillingModeConverter
    : JsonConverter<CumulativeGroupedAllocationBillingMode>
{
    public override CumulativeGroupedAllocationBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => CumulativeGroupedAllocationBillingMode.InAdvance,
            "in_arrear" => CumulativeGroupedAllocationBillingMode.InArrear,
            _ => (CumulativeGroupedAllocationBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        CumulativeGroupedAllocationBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                CumulativeGroupedAllocationBillingMode.InAdvance => "in_advance",
                CumulativeGroupedAllocationBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(CumulativeGroupedAllocationCadenceConverter))]
public enum CumulativeGroupedAllocationCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class CumulativeGroupedAllocationCadenceConverter
    : JsonConverter<CumulativeGroupedAllocationCadence>
{
    public override CumulativeGroupedAllocationCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => CumulativeGroupedAllocationCadence.OneTime,
            "monthly" => CumulativeGroupedAllocationCadence.Monthly,
            "quarterly" => CumulativeGroupedAllocationCadence.Quarterly,
            "semi_annual" => CumulativeGroupedAllocationCadence.SemiAnnual,
            "annual" => CumulativeGroupedAllocationCadence.Annual,
            "custom" => CumulativeGroupedAllocationCadence.Custom,
            _ => (CumulativeGroupedAllocationCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        CumulativeGroupedAllocationCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                CumulativeGroupedAllocationCadence.OneTime => "one_time",
                CumulativeGroupedAllocationCadence.Monthly => "monthly",
                CumulativeGroupedAllocationCadence.Quarterly => "quarterly",
                CumulativeGroupedAllocationCadence.SemiAnnual => "semi_annual",
                CumulativeGroupedAllocationCadence.Annual => "annual",
                CumulativeGroupedAllocationCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        CumulativeGroupedAllocationCompositePriceFilter,
        CumulativeGroupedAllocationCompositePriceFilterFromRaw
    >)
)]
public sealed record class CumulativeGroupedAllocationCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, CumulativeGroupedAllocationCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, CumulativeGroupedAllocationCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<
        string,
        CumulativeGroupedAllocationCompositePriceFilterOperator
    > Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, CumulativeGroupedAllocationCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public CumulativeGroupedAllocationCompositePriceFilter() { }

    public CumulativeGroupedAllocationCompositePriceFilter(
        CumulativeGroupedAllocationCompositePriceFilter cumulativeGroupedAllocationCompositePriceFilter
    )
        : base(cumulativeGroupedAllocationCompositePriceFilter) { }

    public CumulativeGroupedAllocationCompositePriceFilter(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    CumulativeGroupedAllocationCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="CumulativeGroupedAllocationCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static CumulativeGroupedAllocationCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class CumulativeGroupedAllocationCompositePriceFilterFromRaw
    : IFromRawJson<CumulativeGroupedAllocationCompositePriceFilter>
{
    /// <inheritdoc/>
    public CumulativeGroupedAllocationCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => CumulativeGroupedAllocationCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(CumulativeGroupedAllocationCompositePriceFilterFieldConverter))]
public enum CumulativeGroupedAllocationCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class CumulativeGroupedAllocationCompositePriceFilterFieldConverter
    : JsonConverter<CumulativeGroupedAllocationCompositePriceFilterField>
{
    public override CumulativeGroupedAllocationCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => CumulativeGroupedAllocationCompositePriceFilterField.PriceID,
            "item_id" => CumulativeGroupedAllocationCompositePriceFilterField.ItemID,
            "price_type" => CumulativeGroupedAllocationCompositePriceFilterField.PriceType,
            "currency" => CumulativeGroupedAllocationCompositePriceFilterField.Currency,
            "pricing_unit_id" => CumulativeGroupedAllocationCompositePriceFilterField.PricingUnitID,
            _ => (CumulativeGroupedAllocationCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        CumulativeGroupedAllocationCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                CumulativeGroupedAllocationCompositePriceFilterField.PriceID => "price_id",
                CumulativeGroupedAllocationCompositePriceFilterField.ItemID => "item_id",
                CumulativeGroupedAllocationCompositePriceFilterField.PriceType => "price_type",
                CumulativeGroupedAllocationCompositePriceFilterField.Currency => "currency",
                CumulativeGroupedAllocationCompositePriceFilterField.PricingUnitID =>
                    "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(CumulativeGroupedAllocationCompositePriceFilterOperatorConverter))]
public enum CumulativeGroupedAllocationCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class CumulativeGroupedAllocationCompositePriceFilterOperatorConverter
    : JsonConverter<CumulativeGroupedAllocationCompositePriceFilterOperator>
{
    public override CumulativeGroupedAllocationCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => CumulativeGroupedAllocationCompositePriceFilterOperator.Includes,
            "excludes" => CumulativeGroupedAllocationCompositePriceFilterOperator.Excludes,
            _ => (CumulativeGroupedAllocationCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        CumulativeGroupedAllocationCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                CumulativeGroupedAllocationCompositePriceFilterOperator.Includes => "includes",
                CumulativeGroupedAllocationCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(CumulativeGroupedAllocationConversionRateConfigConverter))]
public record class CumulativeGroupedAllocationConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public CumulativeGroupedAllocationConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public CumulativeGroupedAllocationConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public CumulativeGroupedAllocationConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of CumulativeGroupedAllocationConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of CumulativeGroupedAllocationConversionRateConfig"
            ),
        };
    }

    public static implicit operator CumulativeGroupedAllocationConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator CumulativeGroupedAllocationConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of CumulativeGroupedAllocationConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(CumulativeGroupedAllocationConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class CumulativeGroupedAllocationConversionRateConfigConverter
    : JsonConverter<CumulativeGroupedAllocationConversionRateConfig>
{
    public override CumulativeGroupedAllocationConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new CumulativeGroupedAllocationConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        CumulativeGroupedAllocationConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

/// <summary>
/// Configuration for cumulative_grouped_allocation pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<
        CumulativeGroupedAllocationConfig,
        CumulativeGroupedAllocationConfigFromRaw
    >)
)]
public sealed record class CumulativeGroupedAllocationConfig : JsonModel
{
    /// <summary>
    /// The overall allocation across all groups
    /// </summary>
    public required string CumulativeAllocation
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "cumulative_allocation"); }
        init { JsonModel.Set(this._rawData, "cumulative_allocation", value); }
    }

    /// <summary>
    /// The allocation per individual group
    /// </summary>
    public required string GroupAllocation
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "group_allocation"); }
        init { JsonModel.Set(this._rawData, "group_allocation", value); }
    }

    /// <summary>
    /// The event property used to group usage before applying allocations
    /// </summary>
    public required string GroupingKey
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "grouping_key"); }
        init { JsonModel.Set(this._rawData, "grouping_key", value); }
    }

    /// <summary>
    /// The amount to charge for each unit outside of the allocation
    /// </summary>
    public required string UnitAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_amount"); }
        init { JsonModel.Set(this._rawData, "unit_amount", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.CumulativeAllocation;
        _ = this.GroupAllocation;
        _ = this.GroupingKey;
        _ = this.UnitAmount;
    }

    public CumulativeGroupedAllocationConfig() { }

    public CumulativeGroupedAllocationConfig(
        CumulativeGroupedAllocationConfig cumulativeGroupedAllocationConfig
    )
        : base(cumulativeGroupedAllocationConfig) { }

    public CumulativeGroupedAllocationConfig(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    CumulativeGroupedAllocationConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="CumulativeGroupedAllocationConfigFromRaw.FromRawUnchecked"/>
    public static CumulativeGroupedAllocationConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class CumulativeGroupedAllocationConfigFromRaw : IFromRawJson<CumulativeGroupedAllocationConfig>
{
    /// <inheritdoc/>
    public CumulativeGroupedAllocationConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => CumulativeGroupedAllocationConfig.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(CumulativeGroupedAllocationPriceTypeConverter))]
public enum CumulativeGroupedAllocationPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class CumulativeGroupedAllocationPriceTypeConverter
    : JsonConverter<CumulativeGroupedAllocationPriceType>
{
    public override CumulativeGroupedAllocationPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => CumulativeGroupedAllocationPriceType.UsagePrice,
            "fixed_price" => CumulativeGroupedAllocationPriceType.FixedPrice,
            "composite_price" => CumulativeGroupedAllocationPriceType.CompositePrice,
            _ => (CumulativeGroupedAllocationPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        CumulativeGroupedAllocationPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                CumulativeGroupedAllocationPriceType.UsagePrice => "usage_price",
                CumulativeGroupedAllocationPriceType.FixedPrice => "fixed_price",
                CumulativeGroupedAllocationPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<PriceMinimum, PriceMinimumFromRaw>))]
public sealed record class PriceMinimum : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, PriceMinimumBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PriceMinimumBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, PriceMinimumCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PriceMinimumCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<PriceMinimumCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<PriceMinimumCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required PriceMinimumConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<PriceMinimumConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// Configuration for minimum pricing
    /// </summary>
    public required PriceMinimumMinimumConfig MinimumConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<PriceMinimumMinimumConfig>(
                this.RawData,
                "minimum_config"
            );
        }
        init { JsonModel.Set(this._rawData, "minimum_config", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, PriceMinimumPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PriceMinimumPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        this.MinimumConfig.Validate();
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"minimum\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public PriceMinimum()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"minimum\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public PriceMinimum(PriceMinimum priceMinimum)
        : base(priceMinimum) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public PriceMinimum(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"minimum\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    PriceMinimum(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="PriceMinimumFromRaw.FromRawUnchecked"/>
    public static PriceMinimum FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class PriceMinimumFromRaw : IFromRawJson<PriceMinimum>
{
    /// <inheritdoc/>
    public PriceMinimum FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        PriceMinimum.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(PriceMinimumBillingModeConverter))]
public enum PriceMinimumBillingMode
{
    InAdvance,
    InArrear,
}

sealed class PriceMinimumBillingModeConverter : JsonConverter<PriceMinimumBillingMode>
{
    public override PriceMinimumBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => PriceMinimumBillingMode.InAdvance,
            "in_arrear" => PriceMinimumBillingMode.InArrear,
            _ => (PriceMinimumBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PriceMinimumBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PriceMinimumBillingMode.InAdvance => "in_advance",
                PriceMinimumBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(PriceMinimumCadenceConverter))]
public enum PriceMinimumCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class PriceMinimumCadenceConverter : JsonConverter<PriceMinimumCadence>
{
    public override PriceMinimumCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => PriceMinimumCadence.OneTime,
            "monthly" => PriceMinimumCadence.Monthly,
            "quarterly" => PriceMinimumCadence.Quarterly,
            "semi_annual" => PriceMinimumCadence.SemiAnnual,
            "annual" => PriceMinimumCadence.Annual,
            "custom" => PriceMinimumCadence.Custom,
            _ => (PriceMinimumCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PriceMinimumCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PriceMinimumCadence.OneTime => "one_time",
                PriceMinimumCadence.Monthly => "monthly",
                PriceMinimumCadence.Quarterly => "quarterly",
                PriceMinimumCadence.SemiAnnual => "semi_annual",
                PriceMinimumCadence.Annual => "annual",
                PriceMinimumCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        PriceMinimumCompositePriceFilter,
        PriceMinimumCompositePriceFilterFromRaw
    >)
)]
public sealed record class PriceMinimumCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, PriceMinimumCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, PriceMinimumCompositePriceFilterField>
            >(this.RawData, "field");
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, PriceMinimumCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, PriceMinimumCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public PriceMinimumCompositePriceFilter() { }

    public PriceMinimumCompositePriceFilter(
        PriceMinimumCompositePriceFilter priceMinimumCompositePriceFilter
    )
        : base(priceMinimumCompositePriceFilter) { }

    public PriceMinimumCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    PriceMinimumCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="PriceMinimumCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static PriceMinimumCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class PriceMinimumCompositePriceFilterFromRaw : IFromRawJson<PriceMinimumCompositePriceFilter>
{
    /// <inheritdoc/>
    public PriceMinimumCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => PriceMinimumCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(PriceMinimumCompositePriceFilterFieldConverter))]
public enum PriceMinimumCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class PriceMinimumCompositePriceFilterFieldConverter
    : JsonConverter<PriceMinimumCompositePriceFilterField>
{
    public override PriceMinimumCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => PriceMinimumCompositePriceFilterField.PriceID,
            "item_id" => PriceMinimumCompositePriceFilterField.ItemID,
            "price_type" => PriceMinimumCompositePriceFilterField.PriceType,
            "currency" => PriceMinimumCompositePriceFilterField.Currency,
            "pricing_unit_id" => PriceMinimumCompositePriceFilterField.PricingUnitID,
            _ => (PriceMinimumCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PriceMinimumCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PriceMinimumCompositePriceFilterField.PriceID => "price_id",
                PriceMinimumCompositePriceFilterField.ItemID => "item_id",
                PriceMinimumCompositePriceFilterField.PriceType => "price_type",
                PriceMinimumCompositePriceFilterField.Currency => "currency",
                PriceMinimumCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(PriceMinimumCompositePriceFilterOperatorConverter))]
public enum PriceMinimumCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class PriceMinimumCompositePriceFilterOperatorConverter
    : JsonConverter<PriceMinimumCompositePriceFilterOperator>
{
    public override PriceMinimumCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => PriceMinimumCompositePriceFilterOperator.Includes,
            "excludes" => PriceMinimumCompositePriceFilterOperator.Excludes,
            _ => (PriceMinimumCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PriceMinimumCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PriceMinimumCompositePriceFilterOperator.Includes => "includes",
                PriceMinimumCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(PriceMinimumConversionRateConfigConverter))]
public record class PriceMinimumConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public PriceMinimumConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public PriceMinimumConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public PriceMinimumConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of PriceMinimumConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of PriceMinimumConversionRateConfig"
            ),
        };
    }

    public static implicit operator PriceMinimumConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator PriceMinimumConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of PriceMinimumConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(PriceMinimumConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class PriceMinimumConversionRateConfigConverter
    : JsonConverter<PriceMinimumConversionRateConfig>
{
    public override PriceMinimumConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new PriceMinimumConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        PriceMinimumConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

/// <summary>
/// Configuration for minimum pricing
/// </summary>
[JsonConverter(
    typeof(JsonModelConverter<PriceMinimumMinimumConfig, PriceMinimumMinimumConfigFromRaw>)
)]
public sealed record class PriceMinimumMinimumConfig : JsonModel
{
    /// <summary>
    /// The minimum amount to apply
    /// </summary>
    public required string MinimumAmount
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// If true, subtotals from this price are prorated based on the service period
    /// </summary>
    public bool? Prorated
    {
        get { return JsonModel.GetNullableStruct<bool>(this.RawData, "prorated"); }
        init
        {
            if (value == null)
            {
                return;
            }

            JsonModel.Set(this._rawData, "prorated", value);
        }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.MinimumAmount;
        _ = this.Prorated;
    }

    public PriceMinimumMinimumConfig() { }

    public PriceMinimumMinimumConfig(PriceMinimumMinimumConfig priceMinimumMinimumConfig)
        : base(priceMinimumMinimumConfig) { }

    public PriceMinimumMinimumConfig(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    PriceMinimumMinimumConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="PriceMinimumMinimumConfigFromRaw.FromRawUnchecked"/>
    public static PriceMinimumMinimumConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }

    [SetsRequiredMembers]
    public PriceMinimumMinimumConfig(string minimumAmount)
        : this()
    {
        this.MinimumAmount = minimumAmount;
    }
}

class PriceMinimumMinimumConfigFromRaw : IFromRawJson<PriceMinimumMinimumConfig>
{
    /// <inheritdoc/>
    public PriceMinimumMinimumConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => PriceMinimumMinimumConfig.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(PriceMinimumPriceTypeConverter))]
public enum PriceMinimumPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class PriceMinimumPriceTypeConverter : JsonConverter<PriceMinimumPriceType>
{
    public override PriceMinimumPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => PriceMinimumPriceType.UsagePrice,
            "fixed_price" => PriceMinimumPriceType.FixedPrice,
            "composite_price" => PriceMinimumPriceType.CompositePrice,
            _ => (PriceMinimumPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PriceMinimumPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PriceMinimumPriceType.UsagePrice => "usage_price",
                PriceMinimumPriceType.FixedPrice => "fixed_price",
                PriceMinimumPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<Percent, PercentFromRaw>))]
public sealed record class Percent : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, PercentBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PercentBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, PercentCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PercentCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<PercentCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<PercentCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required PercentConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<PercentConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    /// <summary>
    /// Configuration for percent pricing
    /// </summary>
    public required PercentConfig PercentConfig
    {
        get { return JsonModel.GetNotNullClass<PercentConfig>(this.RawData, "percent_config"); }
        init { JsonModel.Set(this._rawData, "percent_config", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, PercentPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PercentPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"percent\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        this.PercentConfig.Validate();
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Percent()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"percent\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Percent(Percent percent)
        : base(percent) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public Percent(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"percent\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    Percent(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="PercentFromRaw.FromRawUnchecked"/>
    public static Percent FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class PercentFromRaw : IFromRawJson<Percent>
{
    /// <inheritdoc/>
    public Percent FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        Percent.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(PercentBillingModeConverter))]
public enum PercentBillingMode
{
    InAdvance,
    InArrear,
}

sealed class PercentBillingModeConverter : JsonConverter<PercentBillingMode>
{
    public override PercentBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => PercentBillingMode.InAdvance,
            "in_arrear" => PercentBillingMode.InArrear,
            _ => (PercentBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PercentBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PercentBillingMode.InAdvance => "in_advance",
                PercentBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(PercentCadenceConverter))]
public enum PercentCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class PercentCadenceConverter : JsonConverter<PercentCadence>
{
    public override PercentCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => PercentCadence.OneTime,
            "monthly" => PercentCadence.Monthly,
            "quarterly" => PercentCadence.Quarterly,
            "semi_annual" => PercentCadence.SemiAnnual,
            "annual" => PercentCadence.Annual,
            "custom" => PercentCadence.Custom,
            _ => (PercentCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PercentCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PercentCadence.OneTime => "one_time",
                PercentCadence.Monthly => "monthly",
                PercentCadence.Quarterly => "quarterly",
                PercentCadence.SemiAnnual => "semi_annual",
                PercentCadence.Annual => "annual",
                PercentCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<PercentCompositePriceFilter, PercentCompositePriceFilterFromRaw>)
)]
public sealed record class PercentCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, PercentCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PercentCompositePriceFilterField>>(
                this.RawData,
                "field"
            );
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, PercentCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, PercentCompositePriceFilterOperator>>(
                this.RawData,
                "operator"
            );
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public PercentCompositePriceFilter() { }

    public PercentCompositePriceFilter(PercentCompositePriceFilter percentCompositePriceFilter)
        : base(percentCompositePriceFilter) { }

    public PercentCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    PercentCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="PercentCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static PercentCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class PercentCompositePriceFilterFromRaw : IFromRawJson<PercentCompositePriceFilter>
{
    /// <inheritdoc/>
    public PercentCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => PercentCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(PercentCompositePriceFilterFieldConverter))]
public enum PercentCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class PercentCompositePriceFilterFieldConverter
    : JsonConverter<PercentCompositePriceFilterField>
{
    public override PercentCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => PercentCompositePriceFilterField.PriceID,
            "item_id" => PercentCompositePriceFilterField.ItemID,
            "price_type" => PercentCompositePriceFilterField.PriceType,
            "currency" => PercentCompositePriceFilterField.Currency,
            "pricing_unit_id" => PercentCompositePriceFilterField.PricingUnitID,
            _ => (PercentCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PercentCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PercentCompositePriceFilterField.PriceID => "price_id",
                PercentCompositePriceFilterField.ItemID => "item_id",
                PercentCompositePriceFilterField.PriceType => "price_type",
                PercentCompositePriceFilterField.Currency => "currency",
                PercentCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(PercentCompositePriceFilterOperatorConverter))]
public enum PercentCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class PercentCompositePriceFilterOperatorConverter
    : JsonConverter<PercentCompositePriceFilterOperator>
{
    public override PercentCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => PercentCompositePriceFilterOperator.Includes,
            "excludes" => PercentCompositePriceFilterOperator.Excludes,
            _ => (PercentCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PercentCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PercentCompositePriceFilterOperator.Includes => "includes",
                PercentCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(PercentConversionRateConfigConverter))]
public record class PercentConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public PercentConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public PercentConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public PercentConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of PercentConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of PercentConversionRateConfig"
            ),
        };
    }

    public static implicit operator PercentConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator PercentConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of PercentConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(PercentConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class PercentConversionRateConfigConverter : JsonConverter<PercentConversionRateConfig>
{
    public override PercentConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new PercentConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        PercentConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

/// <summary>
/// Configuration for percent pricing
/// </summary>
[JsonConverter(typeof(JsonModelConverter<PercentConfig, PercentConfigFromRaw>))]
public sealed record class PercentConfig : JsonModel
{
    /// <summary>
    /// What percent of the component subtotals to charge
    /// </summary>
    public required double Percent
    {
        get { return JsonModel.GetNotNullStruct<double>(this.RawData, "percent"); }
        init { JsonModel.Set(this._rawData, "percent", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.Percent;
    }

    public PercentConfig() { }

    public PercentConfig(PercentConfig percentConfig)
        : base(percentConfig) { }

    public PercentConfig(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    PercentConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="PercentConfigFromRaw.FromRawUnchecked"/>
    public static PercentConfig FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }

    [SetsRequiredMembers]
    public PercentConfig(double percent)
        : this()
    {
        this.Percent = percent;
    }
}

class PercentConfigFromRaw : IFromRawJson<PercentConfig>
{
    /// <inheritdoc/>
    public PercentConfig FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        PercentConfig.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(PercentPriceTypeConverter))]
public enum PercentPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class PercentPriceTypeConverter : JsonConverter<PercentPriceType>
{
    public override PercentPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => PercentPriceType.UsagePrice,
            "fixed_price" => PercentPriceType.FixedPrice,
            "composite_price" => PercentPriceType.CompositePrice,
            _ => (PercentPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        PercentPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                PercentPriceType.UsagePrice => "usage_price",
                PercentPriceType.FixedPrice => "fixed_price",
                PercentPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(JsonModelConverter<EventOutput, EventOutputFromRaw>))]
public sealed record class EventOutput : JsonModel
{
    public required string ID
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "id"); }
        init { JsonModel.Set(this._rawData, "id", value); }
    }

    public required BillableMetricTiny? BillableMetric
    {
        get
        {
            return JsonModel.GetNullableClass<BillableMetricTiny>(this.RawData, "billable_metric");
        }
        init { JsonModel.Set(this._rawData, "billable_metric", value); }
    }

    public required BillingCycleConfiguration BillingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNotNullClass<BillingCycleConfiguration>(
                this.RawData,
                "billing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_cycle_configuration", value); }
    }

    public required ApiEnum<string, EventOutputBillingMode> BillingMode
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, EventOutputBillingMode>>(
                this.RawData,
                "billing_mode"
            );
        }
        init { JsonModel.Set(this._rawData, "billing_mode", value); }
    }

    public required ApiEnum<string, EventOutputCadence> Cadence
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, EventOutputCadence>>(
                this.RawData,
                "cadence"
            );
        }
        init { JsonModel.Set(this._rawData, "cadence", value); }
    }

    public required IReadOnlyList<EventOutputCompositePriceFilter>? CompositePriceFilters
    {
        get
        {
            return JsonModel.GetNullableClass<List<EventOutputCompositePriceFilter>>(
                this.RawData,
                "composite_price_filters"
            );
        }
        init { JsonModel.Set(this._rawData, "composite_price_filters", value); }
    }

    public required double? ConversionRate
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "conversion_rate"); }
        init { JsonModel.Set(this._rawData, "conversion_rate", value); }
    }

    public required EventOutputConversionRateConfig? ConversionRateConfig
    {
        get
        {
            return JsonModel.GetNullableClass<EventOutputConversionRateConfig>(
                this.RawData,
                "conversion_rate_config"
            );
        }
        init { JsonModel.Set(this._rawData, "conversion_rate_config", value); }
    }

    public required System::DateTimeOffset CreatedAt
    {
        get
        {
            return JsonModel.GetNotNullStruct<System::DateTimeOffset>(this.RawData, "created_at");
        }
        init { JsonModel.Set(this._rawData, "created_at", value); }
    }

    public required Allocation? CreditAllocation
    {
        get { return JsonModel.GetNullableClass<Allocation>(this.RawData, "credit_allocation"); }
        init { JsonModel.Set(this._rawData, "credit_allocation", value); }
    }

    public required string Currency
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "currency"); }
        init { JsonModel.Set(this._rawData, "currency", value); }
    }

    [System::Obsolete("deprecated")]
    public required SharedDiscount? Discount
    {
        get { return JsonModel.GetNullableClass<SharedDiscount>(this.RawData, "discount"); }
        init { JsonModel.Set(this._rawData, "discount", value); }
    }

    /// <summary>
    /// Configuration for event_output pricing
    /// </summary>
    public required EventOutputConfig EventOutputConfig
    {
        get
        {
            return JsonModel.GetNotNullClass<EventOutputConfig>(
                this.RawData,
                "event_output_config"
            );
        }
        init { JsonModel.Set(this._rawData, "event_output_config", value); }
    }

    public required string? ExternalPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "external_price_id"); }
        init { JsonModel.Set(this._rawData, "external_price_id", value); }
    }

    public required double? FixedPriceQuantity
    {
        get { return JsonModel.GetNullableStruct<double>(this.RawData, "fixed_price_quantity"); }
        init { JsonModel.Set(this._rawData, "fixed_price_quantity", value); }
    }

    public required BillingCycleConfiguration? InvoicingCycleConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<BillingCycleConfiguration>(
                this.RawData,
                "invoicing_cycle_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "invoicing_cycle_configuration", value); }
    }

    /// <summary>
    /// A minimal representation of an Item containing only the essential identifying information.
    /// </summary>
    public required ItemSlim Item
    {
        get { return JsonModel.GetNotNullClass<ItemSlim>(this.RawData, "item"); }
        init { JsonModel.Set(this._rawData, "item", value); }
    }

    [System::Obsolete("deprecated")]
    public required Maximum? Maximum
    {
        get { return JsonModel.GetNullableClass<Maximum>(this.RawData, "maximum"); }
        init { JsonModel.Set(this._rawData, "maximum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MaximumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "maximum_amount"); }
        init { JsonModel.Set(this._rawData, "maximum_amount", value); }
    }

    /// <summary>
    /// User specified key-value pairs for the resource. If not present, this defaults
    /// to an empty dictionary. Individual keys can be removed by setting the value
    /// to `null`, and the entire metadata mapping can be cleared by setting `metadata`
    /// to `null`.
    /// </summary>
    public required IReadOnlyDictionary<string, string> Metadata
    {
        get
        {
            return JsonModel.GetNotNullClass<Dictionary<string, string>>(this.RawData, "metadata");
        }
        init { JsonModel.Set(this._rawData, "metadata", value); }
    }

    [System::Obsolete("deprecated")]
    public required Minimum? Minimum
    {
        get { return JsonModel.GetNullableClass<Minimum>(this.RawData, "minimum"); }
        init { JsonModel.Set(this._rawData, "minimum", value); }
    }

    [System::Obsolete("deprecated")]
    public required string? MinimumAmount
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "minimum_amount"); }
        init { JsonModel.Set(this._rawData, "minimum_amount", value); }
    }

    /// <summary>
    /// The pricing model type
    /// </summary>
    public JsonElement ModelType
    {
        get { return JsonModel.GetNotNullStruct<JsonElement>(this.RawData, "model_type"); }
        init { JsonModel.Set(this._rawData, "model_type", value); }
    }

    public required string Name
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "name"); }
        init { JsonModel.Set(this._rawData, "name", value); }
    }

    public required long? PlanPhaseOrder
    {
        get { return JsonModel.GetNullableStruct<long>(this.RawData, "plan_phase_order"); }
        init { JsonModel.Set(this._rawData, "plan_phase_order", value); }
    }

    public required ApiEnum<string, EventOutputPriceType> PriceType
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, EventOutputPriceType>>(
                this.RawData,
                "price_type"
            );
        }
        init { JsonModel.Set(this._rawData, "price_type", value); }
    }

    /// <summary>
    /// The price id this price replaces. This price will take the place of the replaced
    /// price in plan version migrations.
    /// </summary>
    public required string? ReplacesPriceID
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "replaces_price_id"); }
        init { JsonModel.Set(this._rawData, "replaces_price_id", value); }
    }

    public DimensionalPriceConfiguration? DimensionalPriceConfiguration
    {
        get
        {
            return JsonModel.GetNullableClass<DimensionalPriceConfiguration>(
                this.RawData,
                "dimensional_price_configuration"
            );
        }
        init { JsonModel.Set(this._rawData, "dimensional_price_configuration", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.ID;
        this.BillableMetric?.Validate();
        this.BillingCycleConfiguration.Validate();
        this.BillingMode.Validate();
        this.Cadence.Validate();
        foreach (var item in this.CompositePriceFilters ?? [])
        {
            item.Validate();
        }
        _ = this.ConversionRate;
        this.ConversionRateConfig?.Validate();
        _ = this.CreatedAt;
        this.CreditAllocation?.Validate();
        _ = this.Currency;
        this.Discount?.Validate();
        this.EventOutputConfig.Validate();
        _ = this.ExternalPriceID;
        _ = this.FixedPriceQuantity;
        this.InvoicingCycleConfiguration?.Validate();
        this.Item.Validate();
        this.Maximum?.Validate();
        _ = this.MaximumAmount;
        _ = this.Metadata;
        this.Minimum?.Validate();
        _ = this.MinimumAmount;
        if (
            !JsonElement.DeepEquals(
                this.ModelType,
                JsonSerializer.Deserialize<JsonElement>("\"event_output\"")
            )
        )
        {
            throw new OrbInvalidDataException("Invalid value given for constant");
        }
        _ = this.Name;
        _ = this.PlanPhaseOrder;
        this.PriceType.Validate();
        _ = this.ReplacesPriceID;
        this.DimensionalPriceConfiguration?.Validate();
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public EventOutput()
    {
        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"event_output\"");
    }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public EventOutput(EventOutput eventOutput)
        : base(eventOutput) { }

    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    public EventOutput(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];

        this.ModelType = JsonSerializer.Deserialize<JsonElement>("\"event_output\"");
    }

#pragma warning disable CS8618
    [System::Obsolete(
        "Required properties are deprecated: discount, maximum, maximum_amount, minimum, minimum_amount"
    )]
    [SetsRequiredMembers]
    EventOutput(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="EventOutputFromRaw.FromRawUnchecked"/>
    public static EventOutput FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class EventOutputFromRaw : IFromRawJson<EventOutput>
{
    /// <inheritdoc/>
    public EventOutput FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        EventOutput.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(EventOutputBillingModeConverter))]
public enum EventOutputBillingMode
{
    InAdvance,
    InArrear,
}

sealed class EventOutputBillingModeConverter : JsonConverter<EventOutputBillingMode>
{
    public override EventOutputBillingMode Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "in_advance" => EventOutputBillingMode.InAdvance,
            "in_arrear" => EventOutputBillingMode.InArrear,
            _ => (EventOutputBillingMode)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        EventOutputBillingMode value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                EventOutputBillingMode.InAdvance => "in_advance",
                EventOutputBillingMode.InArrear => "in_arrear",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(EventOutputCadenceConverter))]
public enum EventOutputCadence
{
    OneTime,
    Monthly,
    Quarterly,
    SemiAnnual,
    Annual,
    Custom,
}

sealed class EventOutputCadenceConverter : JsonConverter<EventOutputCadence>
{
    public override EventOutputCadence Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "one_time" => EventOutputCadence.OneTime,
            "monthly" => EventOutputCadence.Monthly,
            "quarterly" => EventOutputCadence.Quarterly,
            "semi_annual" => EventOutputCadence.SemiAnnual,
            "annual" => EventOutputCadence.Annual,
            "custom" => EventOutputCadence.Custom,
            _ => (EventOutputCadence)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        EventOutputCadence value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                EventOutputCadence.OneTime => "one_time",
                EventOutputCadence.Monthly => "monthly",
                EventOutputCadence.Quarterly => "quarterly",
                EventOutputCadence.SemiAnnual => "semi_annual",
                EventOutputCadence.Annual => "annual",
                EventOutputCadence.Custom => "custom",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(
    typeof(JsonModelConverter<
        EventOutputCompositePriceFilter,
        EventOutputCompositePriceFilterFromRaw
    >)
)]
public sealed record class EventOutputCompositePriceFilter : JsonModel
{
    /// <summary>
    /// The property of the price to filter on.
    /// </summary>
    public required ApiEnum<string, EventOutputCompositePriceFilterField> Field
    {
        get
        {
            return JsonModel.GetNotNullClass<ApiEnum<string, EventOutputCompositePriceFilterField>>(
                this.RawData,
                "field"
            );
        }
        init { JsonModel.Set(this._rawData, "field", value); }
    }

    /// <summary>
    /// Should prices that match the filter be included or excluded.
    /// </summary>
    public required ApiEnum<string, EventOutputCompositePriceFilterOperator> Operator
    {
        get
        {
            return JsonModel.GetNotNullClass<
                ApiEnum<string, EventOutputCompositePriceFilterOperator>
            >(this.RawData, "operator");
        }
        init { JsonModel.Set(this._rawData, "operator", value); }
    }

    /// <summary>
    /// The IDs or values that match this filter.
    /// </summary>
    public required IReadOnlyList<string> Values
    {
        get { return JsonModel.GetNotNullClass<List<string>>(this.RawData, "values"); }
        init { JsonModel.Set(this._rawData, "values", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        this.Field.Validate();
        this.Operator.Validate();
        _ = this.Values;
    }

    public EventOutputCompositePriceFilter() { }

    public EventOutputCompositePriceFilter(
        EventOutputCompositePriceFilter eventOutputCompositePriceFilter
    )
        : base(eventOutputCompositePriceFilter) { }

    public EventOutputCompositePriceFilter(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    EventOutputCompositePriceFilter(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="EventOutputCompositePriceFilterFromRaw.FromRawUnchecked"/>
    public static EventOutputCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }
}

class EventOutputCompositePriceFilterFromRaw : IFromRawJson<EventOutputCompositePriceFilter>
{
    /// <inheritdoc/>
    public EventOutputCompositePriceFilter FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    ) => EventOutputCompositePriceFilter.FromRawUnchecked(rawData);
}

/// <summary>
/// The property of the price to filter on.
/// </summary>
[JsonConverter(typeof(EventOutputCompositePriceFilterFieldConverter))]
public enum EventOutputCompositePriceFilterField
{
    PriceID,
    ItemID,
    PriceType,
    Currency,
    PricingUnitID,
}

sealed class EventOutputCompositePriceFilterFieldConverter
    : JsonConverter<EventOutputCompositePriceFilterField>
{
    public override EventOutputCompositePriceFilterField Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "price_id" => EventOutputCompositePriceFilterField.PriceID,
            "item_id" => EventOutputCompositePriceFilterField.ItemID,
            "price_type" => EventOutputCompositePriceFilterField.PriceType,
            "currency" => EventOutputCompositePriceFilterField.Currency,
            "pricing_unit_id" => EventOutputCompositePriceFilterField.PricingUnitID,
            _ => (EventOutputCompositePriceFilterField)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        EventOutputCompositePriceFilterField value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                EventOutputCompositePriceFilterField.PriceID => "price_id",
                EventOutputCompositePriceFilterField.ItemID => "item_id",
                EventOutputCompositePriceFilterField.PriceType => "price_type",
                EventOutputCompositePriceFilterField.Currency => "currency",
                EventOutputCompositePriceFilterField.PricingUnitID => "pricing_unit_id",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

/// <summary>
/// Should prices that match the filter be included or excluded.
/// </summary>
[JsonConverter(typeof(EventOutputCompositePriceFilterOperatorConverter))]
public enum EventOutputCompositePriceFilterOperator
{
    Includes,
    Excludes,
}

sealed class EventOutputCompositePriceFilterOperatorConverter
    : JsonConverter<EventOutputCompositePriceFilterOperator>
{
    public override EventOutputCompositePriceFilterOperator Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "includes" => EventOutputCompositePriceFilterOperator.Includes,
            "excludes" => EventOutputCompositePriceFilterOperator.Excludes,
            _ => (EventOutputCompositePriceFilterOperator)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        EventOutputCompositePriceFilterOperator value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                EventOutputCompositePriceFilterOperator.Includes => "includes",
                EventOutputCompositePriceFilterOperator.Excludes => "excludes",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}

[JsonConverter(typeof(EventOutputConversionRateConfigConverter))]
public record class EventOutputConversionRateConfig
{
    public object? Value { get; } = null;

    JsonElement? _element = null;

    public JsonElement Json
    {
        get { return this._element ??= JsonSerializer.SerializeToElement(this.Value); }
    }

    public EventOutputConversionRateConfig(
        SharedUnitConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public EventOutputConversionRateConfig(
        SharedTieredConversionRateConfig value,
        JsonElement? element = null
    )
    {
        this.Value = value;
        this._element = element;
    }

    public EventOutputConversionRateConfig(JsonElement element)
    {
        this._element = element;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedUnitConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickUnit(out var value)) {
    ///     // `value` is of type `SharedUnitConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickUnit([NotNullWhen(true)] out SharedUnitConversionRateConfig? value)
    {
        value = this.Value as SharedUnitConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Returns true and sets the <c>out</c> parameter if the instance was constructed with a variant of
    /// type <see cref="SharedTieredConversionRateConfig"/>.
    ///
    /// <para>Consider using <see cref="Switch"> or <see cref="Match"> if you need to handle every variant.</para>
    ///
    /// <example>
    /// <code>
    /// if (instance.TryPickTiered(out var value)) {
    ///     // `value` is of type `SharedTieredConversionRateConfig`
    ///     Console.WriteLine(value);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    public bool TryPickTiered([NotNullWhen(true)] out SharedTieredConversionRateConfig? value)
    {
        value = this.Value as SharedTieredConversionRateConfig;
        return value != null;
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Match">
    /// if you need your function parameters to return something.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// instance.Switch(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public void Switch(
        System::Action<SharedUnitConversionRateConfig> unit,
        System::Action<SharedTieredConversionRateConfig> tiered
    )
    {
        switch (this.Value)
        {
            case SharedUnitConversionRateConfig value:
                unit(value);
                break;
            case SharedTieredConversionRateConfig value:
                tiered(value);
                break;
            default:
                throw new OrbInvalidDataException(
                    "Data did not match any variant of EventOutputConversionRateConfig"
                );
        }
    }

    /// <summary>
    /// Calls the function parameter corresponding to the variant the instance was constructed with and
    /// returns its result.
    ///
    /// <para>Use the <c>TryPick</c> method(s) if you don't need to handle every variant, or <see cref="Switch">
    /// if you don't need your function parameters to return a value.</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance was constructed with an unknown variant (e.g. deserialized from raw data
    /// that doesn't match any variant's expected shape).
    /// </exception>
    ///
    /// <example>
    /// <code>
    /// var result = instance.Match(
    ///     (SharedUnitConversionRateConfig value) => {...},
    ///     (SharedTieredConversionRateConfig value) => {...}
    /// );
    /// </code>
    /// </example>
    /// </summary>
    public T Match<T>(
        System::Func<SharedUnitConversionRateConfig, T> unit,
        System::Func<SharedTieredConversionRateConfig, T> tiered
    )
    {
        return this.Value switch
        {
            SharedUnitConversionRateConfig value => unit(value),
            SharedTieredConversionRateConfig value => tiered(value),
            _ => throw new OrbInvalidDataException(
                "Data did not match any variant of EventOutputConversionRateConfig"
            ),
        };
    }

    public static implicit operator EventOutputConversionRateConfig(
        SharedUnitConversionRateConfig value
    ) => new(value);

    public static implicit operator EventOutputConversionRateConfig(
        SharedTieredConversionRateConfig value
    ) => new(value);

    /// <summary>
    /// Validates that the instance was constructed with a known variant and that this variant is valid
    /// (based on its own <c>Validate</c> method).
    ///
    /// <para>This is useful for instances constructed from raw JSON data (e.g. deserialized from an API response).</para>
    ///
    /// <exception cref="OrbInvalidDataException">
    /// Thrown when the instance does not pass validation.
    /// </exception>
    /// </summary>
    public void Validate()
    {
        if (this.Value == null)
        {
            throw new OrbInvalidDataException(
                "Data did not match any variant of EventOutputConversionRateConfig"
            );
        }
        this.Switch((unit) => unit.Validate(), (tiered) => tiered.Validate());
    }

    public virtual bool Equals(EventOutputConversionRateConfig? other)
    {
        return other != null && JsonElement.DeepEquals(this.Json, other.Json);
    }

    public override int GetHashCode()
    {
        return 0;
    }
}

sealed class EventOutputConversionRateConfigConverter
    : JsonConverter<EventOutputConversionRateConfig>
{
    public override EventOutputConversionRateConfig? Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        var element = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
        string? conversionRateType;
        try
        {
            conversionRateType = element.GetProperty("conversion_rate_type").GetString();
        }
        catch
        {
            conversionRateType = null;
        }

        switch (conversionRateType)
        {
            case "unit":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedUnitConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            case "tiered":
            {
                try
                {
                    var deserialized = JsonSerializer.Deserialize<SharedTieredConversionRateConfig>(
                        element,
                        options
                    );
                    if (deserialized != null)
                    {
                        deserialized.Validate();
                        return new(deserialized, element);
                    }
                }
                catch (System::Exception e)
                    when (e is JsonException || e is OrbInvalidDataException)
                {
                    // ignore
                }

                return new(element);
            }
            default:
            {
                return new EventOutputConversionRateConfig(element);
            }
        }
    }

    public override void Write(
        Utf8JsonWriter writer,
        EventOutputConversionRateConfig value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(writer, value.Json, options);
    }
}

/// <summary>
/// Configuration for event_output pricing
/// </summary>
[JsonConverter(typeof(JsonModelConverter<EventOutputConfig, EventOutputConfigFromRaw>))]
public sealed record class EventOutputConfig : JsonModel
{
    /// <summary>
    /// The key in the event data to extract the unit rate from.
    /// </summary>
    public required string UnitRatingKey
    {
        get { return JsonModel.GetNotNullClass<string>(this.RawData, "unit_rating_key"); }
        init { JsonModel.Set(this._rawData, "unit_rating_key", value); }
    }

    /// <summary>
    /// If provided, this amount will be used as the unit rate when an event does
    /// not have a value for the `unit_rating_key`. If not provided, events missing
    /// a unit rate will be ignored.
    /// </summary>
    public string? DefaultUnitRate
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "default_unit_rate"); }
        init { JsonModel.Set(this._rawData, "default_unit_rate", value); }
    }

    /// <summary>
    /// An optional key in the event data to group by (e.g., event ID). All events
    /// will also be grouped by their unit rate.
    /// </summary>
    public string? GroupingKey
    {
        get { return JsonModel.GetNullableClass<string>(this.RawData, "grouping_key"); }
        init { JsonModel.Set(this._rawData, "grouping_key", value); }
    }

    /// <inheritdoc/>
    public override void Validate()
    {
        _ = this.UnitRatingKey;
        _ = this.DefaultUnitRate;
        _ = this.GroupingKey;
    }

    public EventOutputConfig() { }

    public EventOutputConfig(EventOutputConfig eventOutputConfig)
        : base(eventOutputConfig) { }

    public EventOutputConfig(IReadOnlyDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    EventOutputConfig(FrozenDictionary<string, JsonElement> rawData)
    {
        this._rawData = [.. rawData];
    }
#pragma warning restore CS8618

    /// <inheritdoc cref="EventOutputConfigFromRaw.FromRawUnchecked"/>
    public static EventOutputConfig FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> rawData
    )
    {
        return new(FrozenDictionary.ToFrozenDictionary(rawData));
    }

    [SetsRequiredMembers]
    public EventOutputConfig(string unitRatingKey)
        : this()
    {
        this.UnitRatingKey = unitRatingKey;
    }
}

class EventOutputConfigFromRaw : IFromRawJson<EventOutputConfig>
{
    /// <inheritdoc/>
    public EventOutputConfig FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> rawData) =>
        EventOutputConfig.FromRawUnchecked(rawData);
}

[JsonConverter(typeof(EventOutputPriceTypeConverter))]
public enum EventOutputPriceType
{
    UsagePrice,
    FixedPrice,
    CompositePrice,
}

sealed class EventOutputPriceTypeConverter : JsonConverter<EventOutputPriceType>
{
    public override EventOutputPriceType Read(
        ref Utf8JsonReader reader,
        System::Type typeToConvert,
        JsonSerializerOptions options
    )
    {
        return JsonSerializer.Deserialize<string>(ref reader, options) switch
        {
            "usage_price" => EventOutputPriceType.UsagePrice,
            "fixed_price" => EventOutputPriceType.FixedPrice,
            "composite_price" => EventOutputPriceType.CompositePrice,
            _ => (EventOutputPriceType)(-1),
        };
    }

    public override void Write(
        Utf8JsonWriter writer,
        EventOutputPriceType value,
        JsonSerializerOptions options
    )
    {
        JsonSerializer.Serialize(
            writer,
            value switch
            {
                EventOutputPriceType.UsagePrice => "usage_price",
                EventOutputPriceType.FixedPrice => "fixed_price",
                EventOutputPriceType.CompositePrice => "composite_price",
                _ => throw new OrbInvalidDataException(
                    string.Format("Invalid value '{0}' in {1}", value, nameof(value))
                ),
            },
            options
        );
    }
}
