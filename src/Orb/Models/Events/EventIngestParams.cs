using System;
using System.Collections.Frozen;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using Orb.Core;
using Orb.Exceptions;

namespace Orb.Models.Events;

/// <summary>
/// Orb's event ingestion model and API is designed around two core principles:
///
/// <para>1. **Data fidelity**: The accuracy of your billing model depends on a robust
/// foundation of events. Orb's API protocol encourages usage patterns that ensure
/// that your data is consistently complete and correct. 2. **Fast integration**:
/// Sending events into Orb requires no tedious setup steps or explicit field schema
/// for your event shape, making it instant to start streaming in usage in real-time.</para>
///
/// <para>## Event shape</para>
///
/// <para>Events are the starting point for all usage calculations in the system,
/// and are simple at their core:</para>
///
/// <para>```ts {   // customer_id and external_customer_id are used to   // attribute
/// usage to a given Customer. Exactly one of these   // should be specified in a
/// given ingestion event.</para>
///
/// <para>  // `customer_id` is the Orb generated identifier for the Customer,
/// // which is returned from the Create customer API call.   customer_id: string,</para>
///
/// <para>  // external_customer_id is an alternate identifier which is associated
///   // with a Customer at creation time. This is treated as an alias for   // customer_id,
/// and is usually set to an identifier native to your system.   external_customer_id: string,</para>
///
/// <para>  // A string name identifying the event, usually a usage   // action.
/// By convention, this should not contain any whitespace.   event_name: string,</para>
///
/// <para>  // An ISO 8601 format date with no timezone offset.   // This should represent
/// the time that usage occurred   // and is important to attribute usage to a given
///   // billing period. See the notes below on determining the timestamp.   // e.g.
/// 2020-12-09T16:09:53Z   timestamp: string,</para>
///
/// <para>  // A unique value, generated by the client, that is   // used to de-duplicate
/// events.   // Exactly one event with a given   // idempotency key will be ingested,
/// which allows for   // safe request retries.   idempotency_key: string</para>
///
/// <para>  // Optional custom metadata to attach to the event.   // This might include
/// a numeric value used for aggregation,   // or a string/boolean value used for
/// filtering.   // The schema of this dictionary need not be pre-declared, and
///  // properties can be added at any time.   properties: {     [key: string]?:
/// string | number | boolean,   }, } ```</para>
///
/// <para>## Required fields Because events streamed to Orb are meant to be as flexible
/// as possible, there are only a few required fields in every event.</para>
///
/// <para>- We recommend that `idempotency_key` are unique strings that you generated
/// with V4 UUIDs, but only require that they uniquely identify an event (i.e. don’t
/// collide). - The `timestamp` field in the event body will be used to determine
/// which billable period a given event falls into. For example, with a monthly billing
/// cycle starting from the first of December, Orb will calculate metrics based on
/// events that fall into the range `12-01 00:00:00 <= timestamp < 01-01 00:00:00`.</para>
///
/// <para>## Logging metadata</para>
///
/// <para>Orb allows tagging events with metadata using a flexible properties dictionary.
/// Since Orb does not enforce a rigid schema for this field-set, key-value pairs
/// can be added dynamically as your events evolve.</para>
///
/// <para>This dictionary can be helpful for a wide variety of use cases:</para>
///
/// <para>- Numeric properties on events like `compute_time_ms` can later be inputs
/// to our flexible query engine to determine usage. - Logging a region or cluster
/// with each event can help you provide customers more granular visibility into their
/// usage. - If you are using matrix pricing and matching a matrix price key with
/// a property, you should ensure the value for that property is sent as a string.</para>
///
/// <para>We encourage logging this metadata with an eye towards future use cases
/// to ensure full coverage for historical data. The datatype of the value in the
/// properties dictionary is important for metric creation from an event source. Values
/// that you wish to numerically aggregate should be of numeric type in the event.</para>
///
/// <para>## Determining event timestamp For cases where usage is being reported in
/// real time as it is occurring, timestamp should correspond to the time that usage occurred.</para>
///
/// <para>In cases where usage is reported in aggregate for a historical timeframe
/// at a regular interval, we recommend setting the event `timestamp` to the midpoint
/// of the interval. As an example, if you have an hourly reporter that sends data
/// once an hour for the previous hour of usage, setting the `timestamp` to the half-hour
/// mark will ensure that the usage is counted within the correct period.</para>
///
/// <para>Note that other time-related fields (e.g. time elapsed) can be added to
/// the properties dictionary as necessary.</para>
///
/// <para>In cases where usage is reported in aggregate for a historical timeframe,
/// the timestamp must be within the grace period set for your account. Events with
/// `timestamp < current_time - grace_period` will not be accepted as a valid event,
/// and will throw validation errors. Enforcing the grace period enables Orb to accurately
/// map usage to the correct billing cycle and ensure that all usage is billed for
/// in the corresponding billing period.</para>
///
/// <para>In general, Orb does not expect events with future dated timestamps. In
/// cases where the timestamp is at least 24 hours ahead of the current time, the
/// event will not be accepted as a valid event, and will throw validation errors.</para>
///
/// <para>## Event validation</para>
///
/// <para>Orb’s validation ensures that you recognize errors in your events as quickly
/// as possible, and the API provides informative error messages to help you fix problems quickly.</para>
///
/// <para>We validate the following:</para>
///
/// <para>- Exactly one of `customer_id` and `external_customer_id` should be specified.
/// - If the `customer_id` is specified, the customer in Orb must exist. - If the
/// `external_customer_id` is specified, the customer in Orb does not need to exist.
/// Events will be attributed to any future customers with the `external_customer_id`
/// on subscription creation. - `timestamp` must conform to ISO 8601 and represent
/// a timestamp at most 1 hour in the future. This timestamp should be sent in UTC
/// timezone (no timezone offset).</para>
///
/// <para>## Idempotency and retry semantics</para>
///
/// <para>Orb's idempotency guarantees allow you to implement safe retry logic in
/// the event of network or machine failures, ensuring data fidelity. Each event in
/// the request payload is associated with an idempotency key, and Orb guarantees
/// that a single idempotency key will be successfully ingested at most once. Note
/// that when Orb encounters events with duplicate idempotency keys and differing
/// event bodies in a batch of events, the entire batch will be rejected.</para>
///
/// <para>- Successful responses return a 200 HTTP status code. The response contains
/// information about previously processed events. - Requests that return a `4xx`
/// HTTP status code indicate a payload error and contain at least one event with
/// a validation failure. An event with a validation failure can be re-sent to the
/// ingestion endpoint (after the payload is fixed) with the original idempotency
/// key since that key is not marked as processed. - Requests that return a `5xx`
/// HTTP status code indicate a server-side failure. These requests should be retried
/// in their entirety.</para>
///
/// <para>## API usage and limits The ingestion API is designed made for real-time
/// streaming ingestion and architected for high throughput. Even if events are later
/// deemed unnecessary or filtered out, we encourage you to log them to Orb if they
/// may be relevant to billing calculations in the future.</para>
///
/// <para>To take advantage of the real-time features of the Orb platform and avoid
/// any chance of dropped events by producers, we recommend reporting events to Orb
/// frequently. Optionally, events can also be briefly aggregated at the source, as
/// this API accepts an array of event bodies.</para>
///
/// <para>Orb does not currently enforce a hard rate-limit for API usage or a maximum
/// request payload size, but please give us a heads up if you’re changing either
/// of these factors by an order of magnitude from initial setup.</para>
///
/// <para>## Testing in debug mode The ingestion API supports a debug mode, which
/// returns additional verbose output to indicate which event idempotency keys were
/// newly ingested or duplicates from previous requests. To enable this mode, mark
/// `debug=true` as a query parameter.</para>
///
/// <para>If `debug=true` is not specified, the response will only contain `validation_failed`.
/// Orb will still honor the idempotency guarantees set [here](/events-and-metrics/event-ingestion#event-volume-and-concurrency)
/// in all cases.</para>
///
/// <para>We strongly recommend that you only use debug mode as part of testing your
/// initial Orb integration. Once you're ready to switch to production, disable debug
/// mode to take advantage of improved performance and maximal throughput.</para>
///
/// <para>#### Example: ingestion response with `debug=true`</para>
///
/// <para>```json {   "debug": {     "duplicate": [],     "ingested": [       "B7E83HDMfJPAunXW",
///       "SJs5DQJ3TnwSqEZE",       "8SivfDsNKwCeAXim"     ]   },   "validation_failed":
/// [] } ```</para>
///
/// <para>#### Example: ingestion response with `debug=false`</para>
///
/// <para>```json {   "validation_failed": [] } ```</para>
/// </summary>
public sealed record class EventIngestParams : ParamsBase
{
    readonly FreezableDictionary<string, JsonElement> _bodyProperties = [];
    public IReadOnlyDictionary<string, JsonElement> BodyProperties
    {
        get { return this._bodyProperties.Freeze(); }
    }

    public required List<Event> Events
    {
        get
        {
            if (!this._bodyProperties.TryGetValue("events", out JsonElement element))
                throw new OrbInvalidDataException(
                    "'events' cannot be null",
                    new ArgumentOutOfRangeException("events", "Missing required argument")
                );

            return JsonSerializer.Deserialize<List<Event>>(element, ModelBase.SerializerOptions)
                ?? throw new OrbInvalidDataException(
                    "'events' cannot be null",
                    new ArgumentNullException("events")
                );
        }
        init
        {
            this._bodyProperties["events"] = JsonSerializer.SerializeToElement(
                value,
                ModelBase.SerializerOptions
            );
        }
    }

    /// <summary>
    /// If this ingestion request is part of a backfill, this parameter ties the ingested
    /// events to the backfill
    /// </summary>
    public string? BackfillID
    {
        get
        {
            if (!this._queryProperties.TryGetValue("backfill_id", out JsonElement element))
                return null;

            return JsonSerializer.Deserialize<string?>(element, ModelBase.SerializerOptions);
        }
        init
        {
            this._queryProperties["backfill_id"] = JsonSerializer.SerializeToElement(
                value,
                ModelBase.SerializerOptions
            );
        }
    }

    /// <summary>
    /// Flag to enable additional debug information in the endpoint response
    /// </summary>
    public bool? Debug
    {
        get
        {
            if (!this._queryProperties.TryGetValue("debug", out JsonElement element))
                return null;

            return JsonSerializer.Deserialize<bool?>(element, ModelBase.SerializerOptions);
        }
        init
        {
            if (value == null)
            {
                return;
            }

            this._queryProperties["debug"] = JsonSerializer.SerializeToElement(
                value,
                ModelBase.SerializerOptions
            );
        }
    }

    public EventIngestParams() { }

    public EventIngestParams(
        IReadOnlyDictionary<string, JsonElement> headerProperties,
        IReadOnlyDictionary<string, JsonElement> queryProperties,
        IReadOnlyDictionary<string, JsonElement> bodyProperties
    )
    {
        this._headerProperties = [.. headerProperties];
        this._queryProperties = [.. queryProperties];
        this._bodyProperties = [.. bodyProperties];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    EventIngestParams(
        FrozenDictionary<string, JsonElement> headerProperties,
        FrozenDictionary<string, JsonElement> queryProperties,
        FrozenDictionary<string, JsonElement> bodyProperties
    )
    {
        this._headerProperties = [.. headerProperties];
        this._queryProperties = [.. queryProperties];
        this._bodyProperties = [.. bodyProperties];
    }
#pragma warning restore CS8618

    public static EventIngestParams FromRawUnchecked(
        IReadOnlyDictionary<string, JsonElement> headerProperties,
        IReadOnlyDictionary<string, JsonElement> queryProperties,
        IReadOnlyDictionary<string, JsonElement> bodyProperties
    )
    {
        return new(
            FrozenDictionary.ToFrozenDictionary(headerProperties),
            FrozenDictionary.ToFrozenDictionary(queryProperties),
            FrozenDictionary.ToFrozenDictionary(bodyProperties)
        );
    }

    public override Uri Url(ClientOptions options)
    {
        return new UriBuilder(options.BaseUrl.ToString().TrimEnd('/') + "/ingest")
        {
            Query = this.QueryString(options),
        }.Uri;
    }

    internal override StringContent? BodyContent()
    {
        return new(
            JsonSerializer.Serialize(this.BodyProperties),
            Encoding.UTF8,
            "application/json"
        );
    }

    internal override void AddHeadersToRequest(HttpRequestMessage request, ClientOptions options)
    {
        ParamsBase.AddDefaultHeaders(request, options);
        foreach (var item in this.HeaderProperties)
        {
            ParamsBase.AddHeaderElementToRequest(request, item.Key, item.Value);
        }
    }
}

[JsonConverter(typeof(ModelConverter<Event>))]
public sealed record class Event : ModelBase, IFromRaw<Event>
{
    /// <summary>
    /// A name to meaningfully identify the action or event type.
    /// </summary>
    public required string EventName
    {
        get
        {
            if (!this._properties.TryGetValue("event_name", out JsonElement element))
                throw new OrbInvalidDataException(
                    "'event_name' cannot be null",
                    new ArgumentOutOfRangeException("event_name", "Missing required argument")
                );

            return JsonSerializer.Deserialize<string>(element, ModelBase.SerializerOptions)
                ?? throw new OrbInvalidDataException(
                    "'event_name' cannot be null",
                    new ArgumentNullException("event_name")
                );
        }
        init
        {
            this._properties["event_name"] = JsonSerializer.SerializeToElement(
                value,
                ModelBase.SerializerOptions
            );
        }
    }

    /// <summary>
    /// A unique value, generated by the client, that is used to de-duplicate events.
    /// Exactly one event with a given idempotency key will be ingested, which allows
    /// for safe request retries.
    /// </summary>
    public required string IdempotencyKey
    {
        get
        {
            if (!this._properties.TryGetValue("idempotency_key", out JsonElement element))
                throw new OrbInvalidDataException(
                    "'idempotency_key' cannot be null",
                    new ArgumentOutOfRangeException("idempotency_key", "Missing required argument")
                );

            return JsonSerializer.Deserialize<string>(element, ModelBase.SerializerOptions)
                ?? throw new OrbInvalidDataException(
                    "'idempotency_key' cannot be null",
                    new ArgumentNullException("idempotency_key")
                );
        }
        init
        {
            this._properties["idempotency_key"] = JsonSerializer.SerializeToElement(
                value,
                ModelBase.SerializerOptions
            );
        }
    }

    /// <summary>
    /// A dictionary of custom properties. Values in this dictionary must be numeric,
    /// boolean, or strings. Nested dictionaries are disallowed.
    /// </summary>
    public required Dictionary<string, JsonElement> Properties1
    {
        get
        {
            if (!this._properties.TryGetValue("properties", out JsonElement element))
                throw new OrbInvalidDataException(
                    "'properties' cannot be null",
                    new ArgumentOutOfRangeException("properties", "Missing required argument")
                );

            return JsonSerializer.Deserialize<Dictionary<string, JsonElement>>(
                    element,
                    ModelBase.SerializerOptions
                )
                ?? throw new OrbInvalidDataException(
                    "'properties' cannot be null",
                    new ArgumentNullException("properties")
                );
        }
        init
        {
            this._properties["properties"] = JsonSerializer.SerializeToElement(
                value,
                ModelBase.SerializerOptions
            );
        }
    }

    /// <summary>
    /// An ISO 8601 format date with no timezone offset (i.e. UTC). This should represent
    /// the time that usage was recorded, and is particularly important to attribute
    /// usage to a given billing period.
    /// </summary>
    public required DateTime Timestamp
    {
        get
        {
            if (!this._properties.TryGetValue("timestamp", out JsonElement element))
                throw new OrbInvalidDataException(
                    "'timestamp' cannot be null",
                    new ArgumentOutOfRangeException("timestamp", "Missing required argument")
                );

            return JsonSerializer.Deserialize<DateTime>(element, ModelBase.SerializerOptions);
        }
        init
        {
            this._properties["timestamp"] = JsonSerializer.SerializeToElement(
                value,
                ModelBase.SerializerOptions
            );
        }
    }

    /// <summary>
    /// The Orb Customer identifier
    /// </summary>
    public string? CustomerID
    {
        get
        {
            if (!this._properties.TryGetValue("customer_id", out JsonElement element))
                return null;

            return JsonSerializer.Deserialize<string?>(element, ModelBase.SerializerOptions);
        }
        init
        {
            this._properties["customer_id"] = JsonSerializer.SerializeToElement(
                value,
                ModelBase.SerializerOptions
            );
        }
    }

    /// <summary>
    /// An alias for the Orb customer, whose mapping is specified when creating the customer
    /// </summary>
    public string? ExternalCustomerID
    {
        get
        {
            if (!this._properties.TryGetValue("external_customer_id", out JsonElement element))
                return null;

            return JsonSerializer.Deserialize<string?>(element, ModelBase.SerializerOptions);
        }
        init
        {
            this._properties["external_customer_id"] = JsonSerializer.SerializeToElement(
                value,
                ModelBase.SerializerOptions
            );
        }
    }

    public override void Validate()
    {
        _ = this.EventName;
        _ = this.IdempotencyKey;
        _ = this.Properties1;
        _ = this.Timestamp;
        _ = this.CustomerID;
        _ = this.ExternalCustomerID;
    }

    public Event() { }

    public Event(IReadOnlyDictionary<string, JsonElement> properties)
    {
        this._properties = [.. properties];
    }

#pragma warning disable CS8618
    [SetsRequiredMembers]
    Event(FrozenDictionary<string, JsonElement> properties)
    {
        this._properties = [.. properties];
    }
#pragma warning restore CS8618

    public static Event FromRawUnchecked(IReadOnlyDictionary<string, JsonElement> properties)
    {
        return new(FrozenDictionary.ToFrozenDictionary(properties));
    }
}
